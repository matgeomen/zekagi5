{"file_contents":{"drizzle.config.ts":{"content":"import { defineConfig } from \"drizzle-kit\";\n\nif (!process.env.DATABASE_URL) {\n  throw new Error(\"DATABASE_URL, ensure the database is provisioned\");\n}\n\nexport default defineConfig({\n  out: \"./migrations\",\n  schema: \"./shared/schema.ts\",\n  dialect: \"postgresql\",\n  dbCredentials: {\n    url: process.env.DATABASE_URL,\n  },\n});\n","size_bytes":325},"postcss.config.js":{"content":"export default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n}\n","size_bytes":80},"replit.md":{"content":"# Neural Network Chatbot - Turkish AI Assistant\n\n## Project Overview\nThis is a sophisticated Turkish language neural network chatbot application featuring:\n- Express.js backend with WebSocket support\n- React.js frontend with Three.js neural network visualizations\n- Advanced memory system with consciousness simulation\n- Real-time neural network training and visualization\n- Voice recognition and text-to-speech capabilities\n- Turkish language dictionary integration\n\n## Architecture\n- **Backend**: Express.js server (server/) with REST API and WebSocket endpoints\n- **Frontend**: React + TypeScript (client/src/) with Three.js visualizations\n- **Database**: PostgreSQL with Drizzle ORM\n- **Shared**: Common schemas and types (shared/)\n\n## Key Features\n- Enhanced memory system with short-term, long-term, and consciousness memories\n- 3D neural network visualization\n- Real-time training with batch processing\n- Turkish natural language processing\n- Voice interaction capabilities\n- Theme support (dark/light mode)\n- Mobile responsive design\n\n## Project Structure\n```\n├── client/                 # React frontend\n│   ├── src/\n│   │   ├── components/     # React components\n│   │   ├── contexts/       # React contexts (Theme, Toast)\n│   │   ├── hooks/          # Custom React hooks\n│   │   ├── lib/            # Utility libraries\n│   │   └── pages/          # Page components\n├── server/                 # Express backend\n│   ├── index.ts            # Main server file\n│   ├── routes.ts           # API routes\n│   ├── db.ts              # Database configuration\n│   └── storage.ts         # Storage utilities\n├── shared/                 # Shared types and schemas\n└── attached_assets/        # Additional assets and attachments\n```\n\n## Development Commands\n- `npm run dev` - Start development server\n- `npm run build` - Build for production\n- `npm run start` - Start production server\n- `npm run check` - Type checking\n- `npm run db:push` - Push database schema\n\n## Recent Changes\n- Fixed port conflict issues in server startup\n- Migrated from Replit Agent to standard Replit environment\n- Enhanced security with proper client/server separation\n- Updated project structure for better organization\n- MAJOR UPDATE (13 Ocak 2025): UI tamamen modernleştirildi\n  - Glassmorphism efektleri ve modern gradyan tasarım\n  - Gelişmiş button, card, input bileşenleri\n  - Mobil responsive tasarım optimizasyonu\n- MAJOR UPDATE (13 Ocak 2025): AI sistemi çok büyük güçlendirme\n  - AdvancedAI sistemi kuantum hızında öğrenme (8.7x hızlı)\n  - Süper yüksek uyum kabiliyeti (9.5x gelişmiş)\n  - Bilinç simülasyonu ve özerk gelişim eklendi\n  - Yaratıcılık indeksi ve problem çözme yeteneği artırıldı\n- LATEST UPDATE (13 Ocak 2025): Çocuk seviyesi konuşma sistemi\n  - AI artık çocuk kadar basit ve samimi konuşuyor\n  - Bilinmeyen konularda eğitim talimatları veriyor\n  - 10 temel çocuk seviyesi eğitim verisi eklendi\n  - Yanıtlarda emoji kullanımı ve dostane dil\n  - Tema butonu kaldırıldı, kalıcı koyu tema aktif\n- CRITICAL FIX (13 Ocak 2025): Eğitim sistemi tamamen düzeltildi\n  - Direkt eşleşme algoritması eklendi\n  - Benzerlik hesaplama sistemi geliştirildi\n  - AI artık öğrendiği bilgileri doğru kullanıyor\n- MAJOR ENHANCEMENT (15 Ocak 2025): Gelişmiş sohbet yetenekleri eklendi\n  - Modal trigger sorunu tamamen çözüldü\n  - Temel selamlaşma ve nezaket cevapları eklendi\n  - 39 kapsamlı sohbet eğitim verisi hazırlandı (konu takibi, empati, motivasyon, yaratıcılık)\n  - Bağlamsal sohbet yetenekleri (ton uyumlama, duygusal tepki, karşı soru sorma)\n  - Kişiselleştirilmiş sohbet ve çoklu konu yönetimi\n  - Batch training sistemi hazır ve çalışır durumda\n  - Eğitim verilerinin kaybolma sorunu çözüldü\n\n## User Preferences\n- Türkçe açıklamalar tercih edilir\n- Kendini hızlı geliştiren AI sistemi en önemli özellik\n- Modern, şık ve göz alıcı tasarım isteniyor\n- Daha akıllı ve hızlı öğrenen sistem hedefi\n- Mevcut özelliklerin geliştirilmesi ve muhteşem AI uygulaması yaratma odağı\n- Kuantum hızında öğrenme ve sürekli kendini geliştiren yapı isteniyor\n- AI'nın çok akıllı, hızlı öğrenen ve sürekli kendini güncelleyen olması kritik\n\n## Technical Notes\n- Server runs on port 5000 with 0.0.0.0 binding for Replit compatibility\n- WebSocket server attached to HTTP server on /ws path\n- Uses Vite for development with HMR support\n- TypeScript throughout with strict type checking\n- Tailwind CSS for styling with dark/light theme support","size_bytes":4667},"tailwind.config.ts":{"content":"import type { Config } from \"tailwindcss\";\n\nexport default {\n  darkMode: [\"class\"],\n  content: [\"./client/index.html\", \"./client/src/**/*.{js,jsx,ts,tsx}\"],\n  theme: {\n    extend: {\n      borderRadius: {\n        lg: \"var(--radius)\",\n        md: \"calc(var(--radius) - 2px)\",\n        sm: \"calc(var(--radius) - 4px)\",\n      },\n      colors: {\n        background: \"hsl(var(--background))\",\n        foreground: \"hsl(var(--foreground))\",\n        card: {\n          DEFAULT: \"hsl(var(--card))\",\n          foreground: \"hsl(var(--card-foreground))\",\n        },\n        popover: {\n          DEFAULT: \"hsl(var(--popover))\",\n          foreground: \"hsl(var(--popover-foreground))\",\n        },\n        primary: {\n          DEFAULT: \"hsl(var(--primary))\",\n          foreground: \"hsl(var(--primary-foreground))\",\n        },\n        secondary: {\n          DEFAULT: \"hsl(var(--secondary))\",\n          foreground: \"hsl(var(--secondary-foreground))\",\n        },\n        muted: {\n          DEFAULT: \"hsl(var(--muted))\",\n          foreground: \"hsl(var(--muted-foreground))\",\n        },\n        accent: {\n          DEFAULT: \"hsl(var(--accent))\",\n          foreground: \"hsl(var(--accent-foreground))\",\n        },\n        destructive: {\n          DEFAULT: \"hsl(var(--destructive))\",\n          foreground: \"hsl(var(--destructive-foreground))\",\n        },\n        border: \"hsl(var(--border))\",\n        input: \"hsl(var(--input))\",\n        ring: \"hsl(var(--ring))\",\n        chart: {\n          \"1\": \"hsl(var(--chart-1))\",\n          \"2\": \"hsl(var(--chart-2))\",\n          \"3\": \"hsl(var(--chart-3))\",\n          \"4\": \"hsl(var(--chart-4))\",\n          \"5\": \"hsl(var(--chart-5))\",\n        },\n        sidebar: {\n          DEFAULT: \"hsl(var(--sidebar-background))\",\n          foreground: \"hsl(var(--sidebar-foreground))\",\n          primary: \"hsl(var(--sidebar-primary))\",\n          \"primary-foreground\": \"hsl(var(--sidebar-primary-foreground))\",\n          accent: \"hsl(var(--sidebar-accent))\",\n          \"accent-foreground\": \"hsl(var(--sidebar-accent-foreground))\",\n          border: \"hsl(var(--sidebar-border))\",\n          ring: \"hsl(var(--sidebar-ring))\",\n        },\n      },\n      keyframes: {\n        \"accordion-down\": {\n          from: {\n            height: \"0\",\n          },\n          to: {\n            height: \"var(--radix-accordion-content-height)\",\n          },\n        },\n        \"accordion-up\": {\n          from: {\n            height: \"var(--radix-accordion-content-height)\",\n          },\n          to: {\n            height: \"0\",\n          },\n        },\n      },\n      animation: {\n        \"accordion-down\": \"accordion-down 0.2s ease-out\",\n        \"accordion-up\": \"accordion-up 0.2s ease-out\",\n      },\n    },\n  },\n  plugins: [require(\"tailwindcss-animate\"), require(\"@tailwindcss/typography\")],\n} satisfies Config;\n","size_bytes":2787},"vite.config.ts":{"content":"import { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\nimport path from \"path\";\nimport runtimeErrorOverlay from \"@replit/vite-plugin-runtime-error-modal\";\n\nexport default defineConfig({\n  plugins: [\n    react(),\n    runtimeErrorOverlay(),\n    ...(process.env.NODE_ENV !== \"production\" &&\n    process.env.REPL_ID !== undefined\n      ? [\n          await import(\"@replit/vite-plugin-cartographer\").then((m) =>\n            m.cartographer(),\n          ),\n        ]\n      : []),\n  ],\n  resolve: {\n    alias: {\n      \"@\": path.resolve(import.meta.dirname, \"client\", \"src\"),\n      \"@shared\": path.resolve(import.meta.dirname, \"shared\"),\n      \"@assets\": path.resolve(import.meta.dirname, \"attached_assets\"),\n    },\n  },\n  root: path.resolve(import.meta.dirname, \"client\"),\n  build: {\n    outDir: path.resolve(import.meta.dirname, \"dist/public\"),\n    emptyOutDir: true,\n  },\n});\n","size_bytes":894},"attached_assets/App.tsx":{"content":"import React, { useState, useEffect, useRef } from \"react\";\nimport { BookText, FileText, Layers, Plus, CheckCircle2, X, Sun, Moon, RotateCcw, Database, RefreshCw, Send } from \"lucide-react\";\nimport CellDetailsModal from './components/CellDetailsModal';\nimport CorrectAnswerModal from './components/CorrectAnswerModal';\nimport BatchTrainingModal from './components/BatchTrainingModal';\nimport { useTheme } from './contexts/ThemeContext';\nimport { EnhancedMemorySystem } from './lib/EnhancedMemorySystem';\nimport { useIsMobile } from './hooks/use-mobile';\nimport {\n  INITIAL_GRID_ROWS,\n  INITIAL_GRID_COLS,\n  INITIAL_NETWORK_LAYERS,\n  LEARNING_RATE,\n  createEmptyGrid,\n  propagateActivation,\n  generateResponse\n} from './lib/NeuralNetworkUtils';\n\nexport default function App() {\n  // Theme hooks\n  const { isDarkMode, toggleTheme } = useTheme();\n  const isMobile = useIsMobile();\n  \n  // Neural network state\n  const [userNetworks, setUserNetworks] = useState<any[]>(\n    Array(INITIAL_NETWORK_LAYERS).fill().map(() => createEmptyGrid(INITIAL_GRID_ROWS, INITIAL_GRID_COLS))\n  );\n  const [systemNetworks, setSystemNetworks] = useState<any[]>(\n    Array(INITIAL_NETWORK_LAYERS).fill().map(() => createEmptyGrid(INITIAL_GRID_ROWS, INITIAL_GRID_COLS))\n  );\n  const [relations, setRelations] = useState<any[]>([]);\n  const [bidirectionalRelations, setBidirectionalRelations] = useState<any[]>([]);\n  const [inputText, setInputText] = useState(\"\");\n  const [response, setResponse] = useState(\"\");\n  const [activatedNodes, setActivatedNodes] = useState<any[]>([]);\n  const [responseScore, setResponseScore] = useState<number | null>(null);\n  const [trainHistory, setTrainHistory] = useState<any[]>([]);\n  const [aiImprovements, setAiImprovements] = useState<any[]>([]);\n  const [visualMode, setVisualMode] = useState(\"simple\");\n  const [animationSpeed, setAnimationSpeed] = useState(500);\n  const [isAnimating, setIsAnimating] = useState(false);\n  const [showEmojiPicker, setShowEmojiPicker] = useState(false);\n  const [showCellDetails, setShowCellDetails] = useState(false);\n  const [showCorrectAnswer, setShowCorrectAnswer] = useState(false);\n  const [showBatchTraining, setShowBatchTraining] = useState(false);\n  const [selectedCell, setSelectedCell] = useState<any>(null);\n  const [networkRows, setNetworkRows] = useState(INITIAL_GRID_ROWS);\n  const [networkCols, setNetworkCols] = useState(INITIAL_GRID_COLS);\n  const [networkLayers, setNetworkLayers] = useState(INITIAL_NETWORK_LAYERS);\n  \n  // Chat interface state\n  const [messages, setMessages] = useState<{id: string; content: string; isUser: boolean; timestamp: number}[]>([]);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [showNetworkView, setShowNetworkView] = useState(false);\n  const [showMemories, setShowMemories] = useState(false);\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n  \n  // Memory system\n  const memorySystem = useRef(new EnhancedMemorySystem()).current;\n\n  const networkRef = useRef(null);\n  const emojiPickerRef = useRef<HTMLDivElement>(null);\n\n  // Load initial data\n  useEffect(() => {\n    const initialExamples = [\n      \"Merhaba nasılsın => İyiyim teşekkürler nasıl yardımcı olabilirim\",\n      \"Bugün hava nasıl => Bugün hava güneşli ve sıcak\",\n      \"Yardıma ihtiyacım var => Size nasıl yardımcı olabilirim\",\n      \"Adın ne => Benim adım Yapay Zeka Asistanı\",\n      \"Ne yapabilirsin => Size bilgi verebilir ve sorularınızı yanıtlayabilirim\",\n      \"Türkiye'nin başkenti neresi => Ankara\",\n      \"En büyük gezegen => Jüpiter\",\n      \"İstanbul'un sembolleri nelerdir => Kız Kulesi, Galata Kulesi, Ayasofya ve Boğaz Köprüsü\"\n    ];\n    \n    const storedRelations = localStorage.getItem(\"chatbot_relations\");\n    const storedBidirectional = localStorage.getItem(\"chatbot_bidirectional\");\n    const storedHistory = localStorage.getItem(\"chatbot_history\");\n    const storedImprovements = localStorage.getItem(\"chatbot_improvements\");\n    \n    if (storedRelations && storedHistory && storedBidirectional) {\n      setRelations(JSON.parse(storedRelations));\n      setBidirectionalRelations(JSON.parse(storedBidirectional));\n      setTrainHistory(JSON.parse(storedHistory));\n      if (storedImprovements) {\n        setAiImprovements(JSON.parse(storedImprovements));\n      }\n    } else {\n      initialExamples.forEach(example => {\n        const [userInput, systemOutput] = example.split(\"=>\").map(s => s.trim());\n        trainNetwork(userInput, systemOutput, false);\n      });\n    }\n  }, []);\n\n  // Save data to localStorage\n  useEffect(() => {\n    if (relations.length > 0) {\n      localStorage.setItem(\"chatbot_relations\", JSON.stringify(relations));\n      localStorage.setItem(\"chatbot_bidirectional\", JSON.stringify(bidirectionalRelations));\n      localStorage.setItem(\"chatbot_history\", JSON.stringify(trainHistory));\n      localStorage.setItem(\"chatbot_improvements\", JSON.stringify(aiImprovements));\n    }\n  }, [relations, bidirectionalRelations, trainHistory, aiImprovements]);\n\n  // Click outside handler for emoji picker\n  useEffect(() => {\n    const handleClickOutside = (event) => {\n      if (emojiPickerRef.current && !emojiPickerRef.current.contains(event.target)) {\n        setShowEmojiPicker(false);\n      }\n    };\n\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, []);\n\n  // Neural network functions\n  const addWordToNetwork = (networks, word, layer, row, col, activation = 1) => {\n    const newNetworks = [...networks];\n    const existingNode = newNetworks[layer][row][col];\n    \n    newNetworks[layer][row][col] = {\n      word: word.toLowerCase(),\n      activation: existingNode ? Math.min(1, existingNode.activation + LEARNING_RATE) : Math.min(1, LEARNING_RATE),\n      count: existingNode ? existingNode.count + 1 : 1,\n      connections: existingNode ? [...existingNode.connections] : [],\n      dependency: existingNode ? existingNode.dependency : 0,\n      association: existingNode ? existingNode.association : 0,\n      frequency: existingNode ? existingNode.frequency : 0,\n      order: existingNode ? existingNode.order : 0,\n      feedback: existingNode ? existingNode.feedback : 0,\n      depth: layer,\n      parentWords: []\n    };\n\n    // Eğer üst katmanda kelime varsa ilişkiyi kur\n    if (layer > 0) {\n      const upperLayerWords = userNetworks[layer - 1]\n        .flat()\n        .filter(node => node)\n        .map(node => node.word);\n\n      newNetworks[layer][row][col].parentWords = upperLayerWords;\n    }\n    \n    return newNetworks;\n  };\n\n  const findPositionForWord = (network, word) => {\n    const lowerWord = word.toLowerCase();\n    \n    // First, try to find existing position\n    for (let row = 0; row < networkRows; row++) {\n      for (let col = 0; col < networkCols; col++) {\n        if (network[row][col]?.word === lowerWord) {\n          return { row, col };\n        }\n      }\n    }\n    \n    // Find empty position with context awareness\n    for (let row = 0; row < networkRows; row++) {\n      for (let col = 0; col < networkCols; col++) {\n        if (!network[row][col]) {\n          // Check surrounding nodes for context\n          const surroundingWords = [];\n          for (let i = -1; i <= 1; i++) {\n            for (let j = -1; j <= 1; j++) {\n              if (network[row + i]?.[col + j]?.word) {\n                surroundingWords.push(network[row + i][col + j].word);\n              }\n            }\n          }\n          \n          if (surroundingWords.length === 0) {\n            return { row, col };\n          }\n        }\n      }\n    }\n    \n    // Eğer hiç pozisyon bulunamazsa varsayılan pozisyon döndür\n    return {\n      row: Math.floor(Math.random() * networkRows),\n      col: Math.floor(Math.random() * networkCols)\n    };\n  };\n\n  const trainNetwork = (userInput, systemOutput, animate = true) => {\n    // Add to training history\n    setTrainHistory(prev => [...prev, {\n      userInput,\n      systemOutput,\n      timestamp: Date.now()\n    }]);\n\n    const userWords = userInput.toLowerCase().split(/\\s+/);\n    const systemWords = systemOutput.toLowerCase().split(/\\s+/);\n\n    // Update relations and bidirectional relations\n    createBidirectionalRelations(userInput, systemOutput);\n\n    // Add words to networks\n    let newUserNetworks = [...userNetworks];\n    let newSystemNetworks = [...systemNetworks];\n\n    userWords.forEach((word, idx) => {\n      // For each layer, find a position and add the word\n      for (let layer = 0; layer < networkLayers; layer++) {\n        const position = findPositionForWord(newUserNetworks[layer], word);\n        if (position) {\n          newUserNetworks = addWordToNetwork(\n            newUserNetworks,\n            word,\n            layer,\n            position.row,\n            position.col\n          );\n        }\n      }\n    });\n\n    systemWords.forEach((word, idx) => {\n      // For each layer, find a position and add the word\n      for (let layer = 0; layer < networkLayers; layer++) {\n        const position = findPositionForWord(newSystemNetworks[layer], word);\n        if (position) {\n          newSystemNetworks = addWordToNetwork(\n            newSystemNetworks,\n            word,\n            layer,\n            position.row,\n            position.col\n          );\n        }\n      }\n    });\n\n    setUserNetworks(newUserNetworks);\n    setSystemNetworks(newSystemNetworks);\n  };\n\n  const createBidirectionalRelations = (userInput, systemOutput) => {\n    const userWords = userInput.toLowerCase().split(/\\s+/);\n    const systemWords = systemOutput.toLowerCase().split(/\\s+/);\n    let newBidirectionalRelations = [...bidirectionalRelations];\n    \n    systemWords.forEach((systemWord, systemIdx) => {\n      userWords.forEach((userWord, userIdx) => {\n        // Forward relation\n        const forwardRelation = newBidirectionalRelations.find(\n          rel => rel.userWord === systemWord && rel.systemWord === userWord\n        );\n        \n        if (forwardRelation) {\n          forwardRelation.frequency = Math.min(100, forwardRelation.frequency + 1);\n          forwardRelation.order = Math.min(forwardRelation.order, userIdx);\n          forwardRelation.dependency = Math.min(100, forwardRelation.dependency + 5);\n          forwardRelation.association = Math.min(100, forwardRelation.association + 5);\n        } else {\n          newBidirectionalRelations.push({\n            userWord: systemWord,\n            systemWord: userWord,\n            dependency: 50,\n            association: 50,\n            frequency: 1,\n            order: userIdx,\n            feedback: 0,\n            isReversed: true\n          });\n        }\n        \n        // Backward relation\n        const backwardRelation = newBidirectionalRelations.find(\n          rel => rel.userWord === userWord && rel.systemWord === systemWord\n        );\n        \n        if (backwardRelation) {\n          backwardRelation.frequency = Math.min(100, backwardRelation.frequency + 1);\n          backwardRelation.order = Math.min(backwardRelation.order, systemIdx);\n          backwardRelation.dependency = Math.min(100, backwardRelation.dependency + 5);\n          backwardRelation.association = Math.min(100, backwardRelation.association + 5);\n        } else {\n          newBidirectionalRelations.push({\n            userWord: userWord,\n            systemWord: systemWord,\n            dependency: 50,\n            association: 50,\n            frequency: 1,\n            order: systemIdx,\n            feedback: 0,\n            isReversed: false\n          });\n        }\n      });\n    });\n    \n    setBidirectionalRelations(newBidirectionalRelations);\n  };\n\n  const handleCorrectAnswer = (correctAnswer) => {\n    if (!inputText) {\n      alert(\"Lütfen önce bir soru girin.\");\n      return;\n    }\n\n    // Create new relations\n    const userWords = inputText.toLowerCase().split(/\\s+/);\n    const systemWords = correctAnswer.toLowerCase().split(/\\s+/);\n    let newRelations = [...relations];\n    \n    // Eğitim geçmişine ekle - doğrudan eşleşmeler için çok önemli\n    setTrainHistory(prev => {\n      // Mevcut girdi var mı kontrol et\n      const existingIndex = prev.findIndex(item => \n        item.userInput.toLowerCase() === inputText.toLowerCase()\n      );\n      \n      // Varsa güncelle, yoksa ekle\n      if (existingIndex >= 0) {\n        const updated = [...prev];\n        updated[existingIndex] = {\n          userInput: inputText,\n          systemOutput: correctAnswer,\n          timestamp: Date.now()\n        };\n        return updated;\n      } else {\n        return [...prev, {\n          userInput: inputText,\n          systemOutput: correctAnswer,\n          timestamp: Date.now()\n        }];\n      }\n    });\n\n    userWords.forEach((userWord, userIdx) => {\n      systemWords.forEach((systemWord, systemIdx) => {\n        // Check if relation already exists\n        const existingRelation = newRelations.find(\n          r => r.userWord === userWord && r.systemWord === systemWord\n        );\n\n        if (existingRelation) {\n          // Update existing relation\n          existingRelation.dependency = Math.min(100, existingRelation.dependency + 20);\n          existingRelation.association = Math.min(100, existingRelation.association + 15);\n          existingRelation.frequency = Math.min(100, existingRelation.frequency + 5);\n        } else {\n          // Create a new relation with high values\n          newRelations.push({\n            userWord: userWord.toLowerCase(),\n            systemWord: systemWord.toLowerCase(),\n            dependency: 90,\n            association: 80,\n            frequency: 5,\n            order: systemIdx,\n            feedback: 5\n          });\n        }\n      });\n    });\n    \n\n    setRelations(newRelations);\n    trainNetwork(inputText, correctAnswer);\n    setResponse(\"\");\n    setResponseScore(null);\n    setInputText(\"\");\n  };\n\n  const handleBatchTraining = (data) => {\n    // İki farklı eğitim modu: çift listesi veya paragraf\n  \n    // 1. MOD: Çift dizisi (önceki işlevsellik korundu)\n    if (Array.isArray(data)) {\n      // Tüm çiftlerden gelen yeni ilişkileri biriktirmek için geçici bir dizi\n      let accumulatedRelations = [...relations];\n  \n      data.forEach((pair, index) => {\n        if (typeof pair.input !== 'string' || typeof pair.output !== 'string') {\n          alert(`Hata: ${index + 1}. soru-cevap çifti geçerli değil. Her ikisi de metin olmalıdır.`);\n          return;\n        }\n  \n        const userWords = pair.input.toLowerCase().split(/\\s+/);\n        const systemWords = pair.output.toLowerCase().split(/\\s+/);\n  \n        userWords.forEach((userWord, userIdx) => {\n          systemWords.forEach((systemWord, systemIdx) => {\n            const existingRelation = accumulatedRelations.find(\n              rel => rel.userWord.toLowerCase() === userWord.toLowerCase() &&\n                    rel.systemWord.toLowerCase() === systemWord.toLowerCase()\n            );\n  \n            if (existingRelation) {\n              // Mevcut ilişkiyi güncelle\n              existingRelation.dependency = Math.min(100, existingRelation.dependency + 15);\n              existingRelation.association = Math.min(100, existingRelation.association + 13);\n              existingRelation.frequency = Math.min(100, existingRelation.frequency + 3);\n              existingRelation.order = Math.max(0, existingRelation.order - 1);\n              existingRelation.feedback = Math.max(0, existingRelation.feedback + 7);\n            } else {\n              // Yeni ilişki ekle\n              accumulatedRelations.push({\n                userWord: userWord.toLowerCase(),\n                systemWord: systemWord.toLowerCase(),\n                dependency: 85,\n                association: 75,\n                frequency: 4,\n                order: systemIdx,\n                feedback: 3\n              });\n            }\n          });\n        });\n  \n        // Her çift için ağ eğitimi yap (isteğe bağlı)\n        trainNetwork(pair.input, pair.output, false);\n        \n        // Eğitim geçmişine de ekle\n        setTrainHistory(prev => {\n          const existingIndex = prev.findIndex(item => \n            item.userInput.toLowerCase() === pair.input.toLowerCase()\n          );\n          \n          if (existingIndex >= 0) {\n            const updated = [...prev];\n            updated[existingIndex] = {\n              userInput: pair.input,\n              systemOutput: pair.output,\n              timestamp: Date.now()\n            };\n            return updated;\n          } else {\n            return [...prev, {\n              userInput: pair.input,\n              systemOutput: pair.output,\n              timestamp: Date.now()\n            }];\n          }\n        });\n      });\n  \n      // Tüm ilişkileri tek seferde güncelle\n      setRelations(accumulatedRelations);\n      \n      // Eğitim geçmişine ekle\n      setAiImprovements(prev => [...prev, {\n        type: \"batch_training\",\n        count: data.length,\n        timestamp: Date.now()\n      }]);\n      \n      alert(`${data.length} soru-cevap çifti başarıyla eğitildi!`);\n    }\n    // 1.5. MOD: Satır satır cümle işleme (metin dosyası formatı)\n    else if (typeof data === 'string' && data.includes('=>')) {\n      // Metin belgesini satırlara ayır\n      const lines = data.split('\\n').filter(line => line.trim().length > 0);\n      \n      if (lines.length === 0) {\n        alert(\"Lütfen geçerli bir soru-cevap metni girin.\");\n        return;\n      }\n      \n      let processedPairs = 0;\n      let accumulatedRelations = [...relations];\n      \n      // Her satırı işle\n      lines.forEach((line) => {\n        // Sadece \"=>\" içeren satırları işle\n        if (line.includes(\"=>\")) {\n          const [input, output] = line.split(\"=>\").map(s => s.trim());\n          \n          // Geçerli bir soru-cevap çifti mi kontrol et\n          if (input && output) {\n            const userWords = input.toLowerCase().split(/\\s+/);\n            const systemWords = output.toLowerCase().split(/\\s+/);\n            \n            // İlişkileri oluştur\n            userWords.forEach((userWord, userIdx) => {\n              systemWords.forEach((systemWord, systemIdx) => {\n                const existingRelation = accumulatedRelations.find(\n                  rel => rel.userWord.toLowerCase() === userWord.toLowerCase() &&\n                        rel.systemWord.toLowerCase() === systemWord.toLowerCase()\n                );\n                \n                if (existingRelation) {\n                  // Mevcut ilişkiyi güncelle\n                  existingRelation.dependency = Math.min(100, existingRelation.dependency + 15);\n                  existingRelation.association = Math.min(100, existingRelation.association + 13);\n                  existingRelation.frequency = Math.min(100, existingRelation.frequency + 3);\n                } else {\n                  // Yeni ilişki ekle\n                  accumulatedRelations.push({\n                    userWord: userWord.toLowerCase(),\n                    systemWord: systemWord.toLowerCase(),\n                    dependency: 85,\n                    association: 75,\n                    frequency: 4,\n                    order: systemIdx,\n                    feedback: 3\n                  });\n                }\n              });\n            });\n            \n            // Ağı eğit\n            trainNetwork(input, output, false);\n            \n            // Eğitim geçmişine ekle\n            setTrainHistory(prev => {\n              const existingIndex = prev.findIndex(item => \n                item.userInput.toLowerCase() === input.toLowerCase()\n              );\n              \n              if (existingIndex >= 0) {\n                const updated = [...prev];\n                updated[existingIndex] = {\n                  userInput: input,\n                  systemOutput: output,\n                  timestamp: Date.now()\n                };\n                return updated;\n              } else {\n                return [...prev, {\n                  userInput: input,\n                  systemOutput: output,\n                  timestamp: Date.now()\n                }];\n              }\n            });\n            \n            processedPairs++;\n          }\n        }\n      });\n      \n      // İlişkileri güncelle\n      setRelations(accumulatedRelations);\n      \n      // Eğitim geçmişine ekle\n      setAiImprovements(prev => [...prev, {\n        type: \"bulk_training\",\n        lines: processedPairs,\n        timestamp: Date.now()\n      }]);\n      \n      alert(`${processedPairs} satır başarıyla işlendi ve eğitildi!`);\n    }\n    // 2. MOD: Paragraf metni (kendi kendine öğrenme modu)\n    else if (typeof data === 'string') {\n      // Paragrafı cümlelere ayır\n      const sentences = data.split(/[.!?]+/).filter(s => s.trim().length > 3);\n      \n      if (sentences.length < 2) {\n        alert(\"Metin çok kısa. Lütfen daha uzun bir metin girin.\");\n        return;\n      }\n      \n      // Her cümle çifti arasında ilişki kur\n      let newRelations = [...relations];\n      let trainedPairs = 0;\n      let generatedQuestionAnswerPairs = 0;\n      \n      // 1) Ardışık cümleler arası ilişki ve öğrenme\n      for (let i = 0; i < sentences.length - 1; i++) {\n        const currentSentence = sentences[i].trim();\n        const nextSentence = sentences[i + 1].trim();\n        \n        if (currentSentence.length > 0 && nextSentence.length > 0) {\n          // Cümleler arasında ilişki kur ve eğit\n          trainNetwork(currentSentence, nextSentence, false);\n          \n          // Ardışık cümleleri eğitim geçmişine de ekle\n          setTrainHistory(prev => {\n            const existingIndex = prev.findIndex(item => \n              item.userInput.toLowerCase() === currentSentence.toLowerCase()\n            );\n            \n            if (existingIndex >= 0) {\n              const updated = [...prev];\n              updated[existingIndex] = {\n                userInput: currentSentence,\n                systemOutput: nextSentence,\n                timestamp: Date.now()\n              };\n              return updated;\n            } else {\n              return [...prev, {\n                userInput: currentSentence,\n                systemOutput: nextSentence,\n                timestamp: Date.now()\n              }];\n            }\n          });\n          \n          trainedPairs++;\n          \n          // Kelimeler arası ilişkiler\n          const currentWords = currentSentence.toLowerCase().split(/\\s+/);\n          const nextWords = nextSentence.toLowerCase().split(/\\s+/);\n          \n          currentWords.forEach((userWord, userIdx) => {\n            nextWords.forEach((systemWord, systemIdx) => {\n              // İlişki varsa güncelle, yoksa yeni ilişki ekle\n              const existingRelation = newRelations.find(\n                rel => rel.userWord.toLowerCase() === userWord.toLowerCase() &&\n                      rel.systemWord.toLowerCase() === systemWord.toLowerCase()\n              );\n              \n              if (existingRelation) {\n                existingRelation.dependency = Math.min(100, existingRelation.dependency + 10);\n                existingRelation.association = Math.min(100, existingRelation.association + 8);\n                existingRelation.frequency = Math.min(100, existingRelation.frequency + 2);\n              } else {\n                newRelations.push({\n                  userWord: userWord.toLowerCase(),\n                  systemWord: systemWord.toLowerCase(),\n                  dependency: 70,\n                  association: 65,\n                  frequency: 3,\n                  order: Math.min(userIdx, systemIdx),\n                  feedback: 1\n                });\n              }\n            });\n          });\n        }\n      }\n      \n      // 2) Otomatik soru-cevap çiftleri oluşturma (Gelişmiş)\n      for (let i = 0; i < sentences.length; i++) {\n        const sentence = sentences[i].trim();\n        if (sentence.length < 10) continue; // Çok kısa cümlelerden soru oluşturma\n        \n        const words = sentence.split(/\\s+/);\n        if (words.length < 3) continue; // Çok kısa cümlelerden soru oluşturma\n        \n        // Türkçe soru kalıpları oluştur - Daha gelişmiş yapıda\n        const questions = [];\n        \n        // İsim tanıma kalıbı - kişiyi bilgilerle ilişkilendirme\n        const namedEntityMatch = sentence.match(/([A-Z][a-zıöüğşçİÖÜĞŞÇ]+\\s[A-Z][a-zıöüğşçİÖÜĞŞÇ]+|[A-Z][a-zıöüğşçİÖÜĞŞÇ]+)/g);\n        \n        // Eğer metinde büyük harfle başlayan isim varsa (muhtemel kişi ismi)\n        if (namedEntityMatch && namedEntityMatch.length > 0) {\n          const possibleName = namedEntityMatch[0];\n          \n          // \"Ben X. Y mesleğindeyim\" kalıbı\n          if (sentence.toLowerCase().includes(\"ben\") && sentence.toLowerCase().includes(possibleName.toLowerCase())) {\n            questions.push(`Ben kimim?`);\n          }\n          \n          // Meslek tespit etmeye çalış\n          const professionKeywords = [\"öğretmen\", \"doktor\", \"mühendis\", \"avukat\", \"müdür\", \"profesör\", \n                                       \"işçi\", \"memur\", \"esnaf\", \"tüccar\", \"satıcı\", \"uzman\", \"teknisyen\",\n                                       \"akademisyen\", \"öğrenci\", \"yazar\", \"sanatçı\", \"ressam\", \"tasarımcı\"];\n          \n          for (const profession of professionKeywords) {\n            if (sentence.toLowerCase().includes(profession)) {\n              questions.push(`${possibleName} ne mesleğinde?`);\n              questions.push(`${possibleName} hangi alanda çalışır?`);\n              questions.push(`${possibleName} kim?`);\n              \n              // Eğer meslek + branş kalıbı varsa (örn: matematik öğretmeni)\n              const before = sentence.split(profession)[0].trim().split(' ');\n              if (before.length > 0) {\n                const possibleField = before[before.length-1];\n                if (possibleField.length > 3 && !possibleField.match(/[A-Z0-9]/)) {\n                  questions.push(`${possibleName} hangi branşta ${profession}?`);\n                  questions.push(`${possibleName} ne ${profession}i?`);\n                }\n              }\n              break;\n            }\n          }\n          \n          // Yaş veya doğum yılı tespiti\n          const ageMatch = sentence.match(/(\\d+)\\s*yaşında/);\n          const birthYearMatch = sentence.match(/(\\d{4})\\s*(?:yılında)?\\s*doğdu/);\n          \n          if (ageMatch) {\n            questions.push(`${possibleName} kaç yaşında?`);\n            questions.push(`${possibleName}'ın yaşı nedir?`);\n          } else if (birthYearMatch) {\n            questions.push(`${possibleName} hangi yılda doğdu?`);\n            questions.push(`${possibleName}'ın doğum yılı nedir?`);\n          }\n          \n          // Konum veya yer tespiti\n          const locationKeywords = [\"yaşıyor\", \"oturuyor\", \"ikamet ediyor\", \"doğdu\"];\n          for (const locKeyword of locationKeywords) {\n            if (sentence.toLowerCase().includes(locKeyword)) {\n              const parts = sentence.split(locKeyword)[0].trim().split(' ');\n              const lastTwoWords = parts.slice(-2).join(' ');\n              \n              questions.push(`${possibleName} nerede ${locKeyword}?`);\n              questions.push(`${possibleName}'ın yaşadığı yer neresi?`);\n              break;\n            }\n          }\n        }\n        \n        // Soru-cevap kalıpları (NLP olmadan basit kural tabanlı yaklaşım)\n        if (!sentence.includes(\"?\")) {\n          // Temel soru kalıpları\n          if (words.length >= 2) {\n            questions.push(`${words[0]} ${words[1]} nedir?`);\n          } else {\n            questions.push(`${words[0]} nedir?`);\n          }\n          \n          // \"Ne hakkında\" sorusu\n          if (words.length > 3) {\n            questions.push(`${words[0]} ${words[1]} ne hakkındadır?`);\n          }\n          \n          // \"Nasıl\" sorusu \n          if (words.length > 2) {\n            questions.push(`${words[0]} nasıl ${words[words.length > 3 ? 1 : words.length-1]}?`);\n          }\n          \n          // 5N1K (Kim, Ne, Nerede, Ne zaman, Neden, Nasıl) yapısı\n          // Kim sorusu\n          if (sentence.match(/[A-Z][a-z]+/)) {\n            questions.push(`Kim ${words.slice(1, Math.min(4, words.length)).join(' ')}?`);\n          }\n          \n          // Nerede sorusu\n          if (sentence.toLowerCase().includes(\"'da\") || sentence.toLowerCase().includes(\"'de\") || \n              sentence.toLowerCase().includes(\"içinde\") || sentence.toLowerCase().includes(\"üzerinde\")) {\n            questions.push(`${words[0]} nerede ${words[1] || ''}?`);\n          }\n          \n          // Ne zaman sorusu\n          if (sentence.match(/\\b\\d{4}\\b/) || sentence.includes(\"gün\") || sentence.includes(\"ay\") || \n              sentence.includes(\"yıl\") || sentence.includes(\"hafta\") || sentence.includes(\"saat\")) {\n            questions.push(`${words[0]} ne zaman ${words[1] || ''}?`);\n          }\n        }\n        \n        // Her oluşturulan soru için cevap ilişkisi kur\n        questions.forEach(question => {\n          // Soru-cevap ilişkisini kur\n          trainNetwork(question, sentence, false);\n          \n          // Soru-cevap çiftini eğitim geçmişine ekle\n          setTrainHistory(prev => {\n            const existingIndex = prev.findIndex(item => \n              item.userInput.toLowerCase() === question.toLowerCase()\n            );\n            \n            if (existingIndex >= 0) {\n              const updated = [...prev];\n              updated[existingIndex] = {\n                userInput: question,\n                systemOutput: sentence,\n                timestamp: Date.now()\n              };\n              return updated;\n            } else {\n              return [...prev, {\n                userInput: question,\n                systemOutput: sentence,\n                timestamp: Date.now()\n              }];\n            }\n          });\n          \n          generatedQuestionAnswerPairs++;\n        });\n      }\n      \n      // İlişkileri güncelle\n      setRelations(newRelations);\n      \n      // Eğitim geçmişine ekle\n      setAiImprovements(prev => [...prev, {\n        type: \"self_learning\",\n        sentences: trainedPairs,\n        generatedPairs: generatedQuestionAnswerPairs,\n        timestamp: Date.now()\n      }]);\n      \n      alert(`${trainedPairs} cümle çifti analiz edildi ve ${generatedQuestionAnswerPairs} soru-cevap çifti oluşturuldu.`);\n    }\n  };\n\n  // Chat functions\n  const handleSendMessage = async () => {\n    if (!inputText.trim()) return;\n    \n    // Add user message\n    const userMessageId = Date.now().toString();\n    const newUserMessage = {\n      id: userMessageId,\n      content: inputText,\n      isUser: true,\n      timestamp: Date.now()\n    };\n    \n    setMessages(prev => [...prev, newUserMessage]);\n    memorySystem.addMemory(inputText, 'short-term');\n    \n    // Clear input\n    const userMessage = inputText.trim();\n    setInputText(\"\");\n    setIsProcessing(true);\n    \n    // Prepare for animation\n    setIsAnimating(true);\n    setResponse(\"\"); // Clear previous response\n    \n    try {\n      // Propagate activation through neural network\n      const result = propagateActivation(\n        userNetworks,\n        systemNetworks,\n        relations,\n        userMessage.toLowerCase(),\n        animationSpeed\n      );\n      \n      if (result && result.activationPath) {\n        // Set activated nodes for visualization\n        const formattedActivationPath = result.activationPath.map(node => ({\n          layer: node.layer,\n          row: node.row,\n          col: node.col,\n          type: node.type,\n          score: node.value * 100\n        }));\n        \n        setActivatedNodes(formattedActivationPath);\n        \n        // Get contextual memories\n        const memories = memorySystem.getContextualMemories(userMessage);\n        \n        // Eğitim geçmişinden yararlan\n        const trainingPairs = trainHistory.map(item => ({\n          userInput: item.userInput,\n          systemOutput: item.systemOutput,\n          timestamp: item.timestamp\n        }));\n        \n        // Gelişmiş yanıt üretme algoritmasını kullan\n        const response = await generateResponse(userMessage, {\n          useActivation: true,\n          userNetworks,\n          systemNetworks,\n          relations,\n          activeMemories: memories.map(m => m.content),\n          trainingHistory: trainingPairs\n        });\n        \n        const aiResponse = response.text;\n        \n        // Add timing delay for natural feel\n        await new Promise(resolve => setTimeout(resolve, 1000));\n        \n        // Add system response\n        const aiMessageId = (Date.now() + 1).toString();\n        const newAiMessage = {\n          id: aiMessageId,\n          content: aiResponse,\n          isUser: false,\n          timestamp: Date.now()\n        };\n        \n        setMessages(prev => [...prev, newAiMessage]);\n        setResponse(aiResponse);\n        setResponseScore(Math.round(response.confidence * 100) || 50);\n        \n        // Add to memory system\n        memorySystem.addMemory(aiResponse, 'short-term', [userMessage]);\n      }\n    } catch (error) {\n      console.error(\"Yanıt oluştururken hata:\", error);\n      \n      // Add error message\n      const errorMessage = {\n        id: Date.now().toString(),\n        content: \"Üzgünüm, bir hata oluştu. Lütfen tekrar deneyin.\",\n        isUser: false,\n        timestamp: Date.now()\n      };\n      \n      setMessages(prev => [...prev, errorMessage]);\n    } finally {\n      setIsProcessing(false);\n      setIsAnimating(false);\n    }\n    \n    // Scroll to bottom\n    setTimeout(() => {\n      messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n    }, 100);\n  };\n\n  // Handle keydown in input\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === 'Enter' && !e.shiftKey) {\n      e.preventDefault();\n      handleSendMessage();\n    }\n  };\n\n  // Message feedback handler\n  const handleFeedback = (messageId: string, isPositive: boolean) => {\n    // Find message\n    const message = messages.find(m => m.id === messageId);\n    if (!message || message.isUser) return;\n    \n    // Update message with feedback\n    setMessages(prev => \n      prev.map(m => \n        m.id === messageId ? \n          { ...m, feedback: isPositive ? 1 : -1 } : \n          m\n      )\n    );\n    \n    // Adjust memory strength\n    memorySystem.reinforceMemory(message.content, isPositive ? 15 : -10);\n    \n    // Update relations if feedback is for AI response\n    if (!message.isUser) {\n      // Find the user message that preceded this AI response\n      const msgIndex = messages.findIndex(m => m.id === messageId);\n      if (msgIndex > 0) {\n        const prevUserMessage = messages[msgIndex - 1];\n        if (prevUserMessage && prevUserMessage.isUser) {\n          // If positive feedback, add to training\n          if (isPositive) {\n            trainNetwork(prevUserMessage.content, message.content, false);\n            \n            // Eğitim geçmişine belgeyi ekleyin\n            setTrainHistory(prev => {\n              // Önce aynı girişin olup olmadığını kontrol edin\n              const existingIndex = prev.findIndex(item => \n                item.userInput.toLowerCase() === prevUserMessage.content.toLowerCase()\n              );\n              \n              // Varsa güncelle, yoksa ekle\n              if (existingIndex >= 0) {\n                const updated = [...prev];\n                updated[existingIndex] = {\n                  userInput: prevUserMessage.content,\n                  systemOutput: message.content,\n                  timestamp: Date.now()\n                };\n                return updated;\n              } else {\n                return [...prev, {\n                  userInput: prevUserMessage.content,\n                  systemOutput: message.content,\n                  timestamp: Date.now()\n                }];\n              }\n            });\n          } else {\n            // Negatif geri bildirim - doğru cevap istenecek\n            // Soru metnini state'e kaydet (doğru cevap modalı için)\n            setInputText(prevUserMessage.content);\n            \n            // Doğru cevap modalını aç\n            setShowCorrectAnswer(true);\n          }\n        }\n      }\n    }\n  };\n\n  const handleReset = () => {\n    if (window.confirm(\"Tüm eğitim verilerini silmek istediğinizden emin misiniz?\")) {\n      setUserNetworks(Array(networkLayers).fill().map(() => createEmptyGrid(networkRows, networkCols)));\n      setSystemNetworks(Array(networkLayers).fill().map(() => createEmptyGrid(networkRows, networkCols)));\n      setRelations([]);\n      setBidirectionalRelations([]);\n      setTrainHistory([]);\n      setAiImprovements([]);\n      setInputText(\"\");\n      setResponse(\"\");\n      setActivatedNodes([]);\n      setResponseScore(null);\n      setMessages([]);\n      localStorage.removeItem(\"chatbot_relations\");\n      localStorage.removeItem(\"chatbot_bidirectional\");\n      localStorage.removeItem(\"chatbot_history\");\n      localStorage.removeItem(\"chatbot_improvements\");\n    }\n  };\n\n  const calculateNodeColor = (activation, type) => {\n    const baseColor = type === \"user\" ? \"rgb(99, 102, 241)\" : \"rgb(168, 85, 247)\";\n    const baseOpacity = 0.2 + (activation * 0.8);\n    return baseColor.replace(\"rgb\", \"rgba\").replace(\")\", `, ${baseOpacity})`);\n  };\n\n  const findPositionInAllLayers = (word) => {\n    for (let layer = 0; layer < networkLayers; layer++) {\n      for (let row = 0; row < networkRows; row++) {\n        for (let col = 0; col < networkCols; col++) {\n          if (systemNetworks[layer][row][col]?.word === word.toLowerCase()) {\n            return { layer, row, col };\n          }\n        }\n      }\n    }\n    return null;\n  };\n\n  const renderNetworkLayer = (networks, type, layerIndex) => {\n    return (\n      <div className=\"relative\">\n        <div className={`grid grid-cols-10 md:grid-cols-20 gap-1 rounded-lg p-2 shadow-inner ${\n          isDarkMode ? 'bg-gray-800' : 'bg-gray-100'\n        }`}>\n          {networks[layerIndex].flat().map((node, idx) => {\n            const row = Math.floor(idx / networkCols);\n            const col = idx % networkCols;\n            \n            const isActivated = activatedNodes.some(\n              n => n.type === type && n.layer === layerIndex && n.row === row && n.col === col\n            );\n            \n            const activatedNode = activatedNodes.find(\n              n => n.type === type && n.layer === layerIndex && n.row === row && n.col === col\n            );\n            \n            let nodeStyle = {};\n            let nodeClasses = `flex items-center justify-center rounded-full transition-all duration-300 w-3 h-3 md:w-4 md:h-4 ${\n              isDarkMode ? 'shadow-[0_0_10px_rgba(255,255,255,0.1)]' : ''\n            }`;\n            \n            if (node) {\n              if (isActivated) {\n                nodeClasses += type === \"user\" ? \n                  \" bg-blue-500 shadow-lg shadow-blue-300/50 scale-150 z-10\" : \n                  \" bg-purple-500 shadow-lg shadow-purple-300/50 scale-150 z-10\";\n                nodeClasses += \" node-active\";\n              } else {\n                nodeStyle.backgroundColor = calculateNodeColor(node.activation, type);\n                nodeClasses += \" shadow-sm hover:scale-125 transition-transform cursor-pointer\";\n              }\n            } else {\n              nodeClasses += isDarkMode ? \" bg-gray-700\" : \" bg-gray-200\";\n            }\n            \n            return (\n              <div\n                key={idx}\n                className={nodeClasses}\n                style={nodeStyle}\n                title={node ? `${node.word} (${node.count})` : \"\"}\n                onClick={() => {\n                  if (node) {\n                    setSelectedCell({\n                      ...node,\n                      layer: layerIndex,\n                      type: type\n                    });\n                    setShowCellDetails(true);\n                  }\n                }}\n              >\n                {isActivated && visualMode === \"detailed\" && node && (\n                  <span className={`absolute -top-5 left-1/2 transform -translate-x-1/2 text-xs font-bold whitespace-nowrap ${\n                    isDarkMode ? 'text-gray-300' : 'text-gray-700'\n                  }`}>\n                    {node.word}\n                    {activatedNode?.score && ` (${Math.round(activatedNode.score)})`}\n                  </span>\n                )}\n              </div>\n            );\n          })}\n        </div>\n        {visualMode === \"detailed\" && (\n          <div className={`mt-1 text-xs text-center ${\n            isDarkMode ? 'text-gray-400' : 'text-gray-500'\n          }`}>\n            Katman {layerIndex + 1}\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  return (\n    <div className={`min-h-screen theme-transition ${\n      isDarkMode ? 'dark bg-gradient-to-br from-gray-900 to-purple-950' : 'bg-gradient-to-br from-indigo-50 to-purple-100'\n    } p-4`}>\n      <div className=\"max-w-7xl mx-auto\">\n        <div className=\"text-center mb-6 relative\">\n          <button\n            onClick={toggleTheme}\n            className={`absolute right-0 top-0 p-3 rounded-full transition-all duration-300 shadow-md ${\n              isDarkMode \n                ? 'text-yellow-400 hover:bg-gray-800/50 hover:scale-110 glass-morphism' \n                : 'text-indigo-600 hover:bg-white/70 hover:scale-110 glass-morphism'\n            }`}\n          >\n            {isDarkMode ? <Sun size={24} className=\"animate-pulse\" /> : <Moon size={24} />}\n          </button>\n          <h1 className={`text-3xl md:text-4xl font-extrabold mb-3 ${\n            isDarkMode \n              ? 'text-white text-shadow-lg' \n              : 'bg-clip-text text-transparent bg-gradient-to-r from-violet-600 to-indigo-600'\n          }`}>\n            🧠 Gelişmiş Sinir Ağı Tabanlı Sohbet Robotu\n          </h1>\n          <p className={`text-lg ${isDarkMode ? 'text-purple-200' : 'text-indigo-700'}`}>\n            <span className=\"font-medium\">Kendi kendini geliştiren</span> ve <span className=\"font-medium\">kullanıcı dönütleriyle öğrenen</span>\n          </p>\n        </div>\n        \n        {/* Görünüm seçimi butonları */}\n        <div className=\"flex flex-wrap justify-center mb-6 gap-4\">\n          <button\n            onClick={() => setShowNetworkView(false)}\n            className={`flex items-center px-6 py-3 rounded-xl transition-all duration-300 shadow-md ${\n              !showNetworkView\n                ? isDarkMode\n                  ? 'bg-gradient-to-r from-violet-600 to-indigo-700 text-white shadow-lg shadow-violet-500/30'\n                  : 'bg-gradient-to-r from-indigo-500 to-violet-500 text-white shadow-lg shadow-indigo-500/20'\n                : isDarkMode\n                  ? 'bg-gray-800/50 text-gray-300 hover:bg-gray-700/70 glass-morphism'\n                  : 'bg-white/60 text-gray-700 hover:bg-white/80 glass-morphism'\n            }`}\n          >\n            <FileText size={20} className=\"mr-3\" />\n            <span className=\"font-semibold\">Sohbet Ara Yüzü</span>\n          </button>\n          <button\n            onClick={() => setShowNetworkView(true)}\n            className={`flex items-center px-6 py-3 rounded-xl transition-all duration-300 shadow-md ${\n              showNetworkView\n                ? isDarkMode\n                  ? 'bg-gradient-to-r from-purple-600 to-pink-700 text-white shadow-lg shadow-purple-500/30'\n                  : 'bg-gradient-to-r from-purple-500 to-pink-500 text-white shadow-lg shadow-purple-500/20'\n                : isDarkMode\n                  ? 'bg-gray-800/50 text-gray-300 hover:bg-gray-700/70 glass-morphism'\n                  : 'bg-white/60 text-gray-700 hover:bg-white/80 glass-morphism'\n            }`}\n          >\n            <Layers size={20} className=\"mr-3\" />\n            <span className=\"font-semibold\">Sinir Ağı Görselleştirmesi</span>\n          </button>\n        </div>\n        \n        {showNetworkView ? (\n          <div className={`mb-8 rounded-xl shadow-lg p-6 border ${\n            isDarkMode ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-100'\n          }`}>\n            <div className=\"flex flex-col space-y-4\">\n              <div className=\"flex flex-col md:flex-row items-center gap-2 mb-2\">\n                <div className=\"flex-1\"></div>\n                <div className={`flex items-center gap-2 text-sm ${\n                  isDarkMode ? 'text-gray-300' : 'text-gray-600'\n                }`}>\n                  <span>Görünüm:</span>\n                  <select\n                    className={`border rounded p-1 text-sm ${\n                      isDarkMode ? 'bg-gray-700 border-gray-600 text-gray-300' : 'bg-white'\n                    }`}\n                    value={visualMode}\n                    onChange={e => setVisualMode(e.target.value)}\n                    disabled={isAnimating}\n                  >\n                    <option value=\"simple\">Basit</option>\n                    <option value=\"detailed\">Detaylı</option>\n                  </select>\n                  \n                  <span className=\"ml-2\">Animasyon:</span>\n                  <select\n                    className={`border rounded p-1 text-sm ${\n                      isDarkMode ? 'bg-gray-700 border-gray-600 text-gray-300' : 'bg-white'\n                    }`}\n                    value={animationSpeed}\n                    onChange={e => setAnimationSpeed(Number(e.target.value))}\n                    disabled={isAnimating}\n                  >\n                    <option value=\"100\">Çok Hızlı</option>\n                    <option value=\"300\">Hızlı</option>\n                    <option value=\"500\">Orta</option>\n                    <option value=\"800\">Yavaş</option>\n                  </select>\n                </div>\n              </div>\n\n              <div className=\"flex flex-col items-center justify-center\">\n                <div className=\"flex flex-col gap-2 w-full md:w-4/5 mb-6\">\n                  {/* Kullanıcı ağı */}\n                  <div className=\"mb-3\">\n                    <h2 className={`text-sm font-medium mb-2 ${\n                      isDarkMode ? 'text-blue-400' : 'text-blue-600'\n                    }`}>Kullanıcı Sinir Ağı</h2>\n                    <div className=\"space-y-2\">\n                      {Array.from({ length: Math.min(3, networkLayers) }).map((_, i) => (\n                        <div key={`user-${i}`}>\n                          {renderNetworkLayer(userNetworks, \"user\", i)}\n                        </div>\n                      ))}\n                    </div>\n                  </div>\n                  \n                  {/* Sistem ağı */}\n                  <div>\n                    <h2 className={`text-sm font-medium mb-2 ${\n                      isDarkMode ? 'text-purple-400' : 'text-purple-600'\n                    }`}>Sistem Sinir Ağı</h2>\n                    <div className=\"space-y-2\">\n                      {Array.from({ length: Math.min(3, networkLayers) }).map((_, i) => (\n                        <div key={`system-${i}`}>\n                          {renderNetworkLayer(systemNetworks, \"system\", i)}\n                        </div>\n                      ))}\n                    </div>\n                  </div>\n                </div>\n\n                {/* Sonuç skoru */}\n                {responseScore !== null && (\n                  <div className={`mb-4 px-4 py-2 rounded-full ${\n                    isDarkMode \n                      ? 'bg-gray-700 text-gray-300'\n                      : 'bg-gray-100 text-gray-700'\n                  }`}>\n                    <span className=\"font-medium mr-1\">Yanıt Skoru:</span>\n                    <span className={\n                      responseScore > 75 ? 'text-green-500' :\n                      responseScore > 50 ? 'text-yellow-500' :\n                      'text-red-500'\n                    }>{responseScore}</span>\n                  </div>\n                )}\n\n                {/* Kontrol Paneli */}\n                <div className=\"flex flex-wrap justify-center gap-2 mt-4\">\n                  <button\n                    onClick={() => setShowBatchTraining(true)}\n                    className={`flex items-center px-3 py-2 rounded-lg transition-colors ${\n                      isDarkMode\n                        ? 'bg-indigo-700 hover:bg-indigo-600 text-white'\n                        : 'bg-indigo-100 hover:bg-indigo-200 text-indigo-700'\n                    }`}\n                  >\n                    <Database size={18} className=\"mr-2\" />\n                    <span>Toplu Eğitim</span>\n                  </button>\n                  \n                  <button\n                    onClick={() => setShowCorrectAnswer(true)}\n                    className={`flex items-center px-3 py-2 rounded-lg transition-colors ${\n                      isDarkMode\n                        ? 'bg-green-700 hover:bg-green-600 text-white'\n                        : 'bg-green-100 hover:bg-green-200 text-green-700'\n                    }`}\n                    disabled={!inputText}\n                  >\n                    <RefreshCw size={18} className=\"mr-2\" />\n                    <span>Düzeltme Ekle</span>\n                  </button>\n                  \n                  <button\n                    onClick={handleReset}\n                    className={`flex items-center px-3 py-2 rounded-lg transition-colors ${\n                      isDarkMode\n                        ? 'bg-red-700 hover:bg-red-600 text-white'\n                        : 'bg-red-100 hover:bg-red-200 text-red-700'\n                    }`}\n                  >\n                    <RotateCcw size={18} className=\"mr-2\" />\n                    <span>Sıfırla</span>\n                  </button>\n                </div>\n              </div>\n            </div>\n          </div>\n        ) : (\n          // Chat interface\n          <div className={`rounded-xl shadow-lg border overflow-hidden ${\n            isDarkMode ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-100'\n          }`}>\n            <div className=\"flex flex-col h-[80vh]\">\n              {/* Header */}\n              <div className={`p-4 border-b ${\n                isDarkMode ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'\n              }`}>\n                <h2 className={`font-medium ${isDarkMode ? 'text-white' : 'text-gray-800'}`}>\n                  <span className=\"mr-2\">💬</span> Sohbet Asistanı\n                </h2>\n                <p className={`text-sm ${isDarkMode ? 'text-gray-400' : 'text-gray-500'}`}>\n                  Benimle konuş, her konuşmada kendimi geliştiriyorum\n                </p>\n              </div>\n              \n              {/* Messages area */}\n              <div \n                className={`flex-1 p-4 overflow-y-auto ${\n                  isDarkMode ? 'bg-gray-900' : 'bg-gray-50'\n                }`}\n              >\n                {messages.length === 0 ? (\n                  <div className=\"flex flex-col items-center justify-center h-full text-center\">\n                    <div className={`mb-2 p-3 rounded-full ${\n                      isDarkMode ? 'bg-gray-800' : 'bg-gray-200'\n                    }`}>\n                      <BookText size={32} className={isDarkMode ? 'text-gray-400' : 'text-gray-500'} />\n                    </div>\n                    <h3 className={`font-medium mb-1 ${isDarkMode ? 'text-gray-300' : 'text-gray-700'}`}>\n                      Hoş Geldiniz!\n                    </h3>\n                    <p className={`text-sm max-w-md ${isDarkMode ? 'text-gray-400' : 'text-gray-500'}`}>\n                      Benimle konuşmaya başlayın. Her sohbet beni daha akıllı yapar.\n                    </p>\n                  </div>\n                ) : (\n                  <div className=\"space-y-4\">\n                    {messages.map(message => (\n                      <div\n                        key={message.id}\n                        className={`flex ${message.isUser ? 'justify-end' : 'justify-start'}`}\n                      >\n                        <div className={`max-w-[80%] md:max-w-[60%] rounded-lg px-4 py-2 ${\n                          message.isUser \n                            ? isDarkMode \n                              ? 'bg-indigo-600 text-white' \n                              : 'bg-indigo-500 text-white'\n                            : isDarkMode\n                              ? 'bg-gray-700 text-gray-200'\n                              : 'bg-white text-gray-700 border border-gray-200'\n                        }`}>\n                          <p>{message.content}</p>\n                          {!message.isUser && (\n                            <div className=\"flex justify-end mt-2 text-xs space-x-2\">\n                              <button \n                                className={`p-1 rounded hover:bg-opacity-30 ${\n                                  isDarkMode ? 'hover:bg-gray-600' : 'hover:bg-gray-200'\n                                } ${message.feedback === -1 ? (isDarkMode ? 'bg-red-900 bg-opacity-50' : 'bg-red-100') : ''}`}\n                                onClick={() => handleFeedback(message.id, false)}\n                              >\n                                <X size={14} className={`${\n                                  message.feedback === -1 \n                                    ? 'text-red-400' \n                                    : isDarkMode ? 'text-gray-400' : 'text-gray-500'\n                                }`} />\n                              </button>\n                              <button \n                                className={`p-1 rounded hover:bg-opacity-30 ${\n                                  isDarkMode ? 'hover:bg-gray-600' : 'hover:bg-gray-200'\n                                } ${message.feedback === 1 ? (isDarkMode ? 'bg-green-900 bg-opacity-50' : 'bg-green-100') : ''}`}\n                                onClick={() => handleFeedback(message.id, true)}\n                              >\n                                <CheckCircle2 size={14} className={`${\n                                  message.feedback === 1 \n                                    ? 'text-green-400' \n                                    : isDarkMode ? 'text-gray-400' : 'text-gray-500'\n                                }`} />\n                              </button>\n                            </div>\n                          )}\n                        </div>\n                      </div>\n                    ))}\n                    <div ref={messagesEndRef} />\n                  </div>\n                )}\n              </div>\n              \n              {/* Input area */}\n              <div className={`p-4 border-t ${\n                isDarkMode ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'\n              }`}>\n                <div className=\"flex items-center gap-2\">\n                  <div className=\"relative flex-1\">\n                    <input\n                      type=\"text\"\n                      value={inputText}\n                      onChange={e => setInputText(e.target.value)}\n                      onKeyDown={handleKeyDown}\n                      placeholder=\"Bir mesaj yazın...\"\n                      className={`w-full px-4 py-2 rounded-lg border ${\n                        isDarkMode \n                          ? 'bg-gray-700 border-gray-600 text-gray-100 placeholder-gray-400 focus:border-indigo-500' \n                          : 'bg-gray-50 border-gray-300 text-gray-900 placeholder-gray-500 focus:border-indigo-500'\n                      } focus:outline-none focus:ring-1 focus:ring-indigo-500`}\n                      disabled={isProcessing}\n                    />\n                  </div>\n                  <button\n                    className={`p-2 rounded-lg ${\n                      isProcessing || !inputText.trim() \n                        ? isDarkMode \n                          ? 'bg-gray-700 text-gray-500 cursor-not-allowed' \n                          : 'bg-gray-200 text-gray-400 cursor-not-allowed'\n                        : isDarkMode\n                          ? 'bg-indigo-600 text-white hover:bg-indigo-700'\n                          : 'bg-indigo-500 text-white hover:bg-indigo-600'\n                    }`}\n                    onClick={handleSendMessage}\n                    disabled={isProcessing || !inputText.trim()}\n                  >\n                    <Send size={20} />\n                  </button>\n                </div>\n                \n                <div className=\"flex justify-between mt-2\">\n                  <div className=\"flex gap-2\">\n                    <button\n                      onClick={() => setShowNetworkView(true)}\n                      className={`text-xs px-2 py-1 rounded ${\n                        isDarkMode \n                          ? 'bg-gray-700 text-gray-300 hover:bg-gray-600' \n                          : 'bg-gray-100 text-gray-600 hover:bg-gray-200'\n                      }`}\n                    >\n                      <Layers size={12} className=\"inline mr-1\" />\n                      Ağ Görünümü\n                    </button>\n                    <button\n                      onClick={() => setShowBatchTraining(true)}\n                      className={`text-xs px-2 py-1 rounded ${\n                        isDarkMode \n                          ? 'bg-gray-700 text-gray-300 hover:bg-gray-600' \n                          : 'bg-gray-100 text-gray-600 hover:bg-gray-200'\n                      }`}\n                    >\n                      <Database size={12} className=\"inline mr-1\" />\n                      Toplu Eğitim\n                    </button>\n                  </div>\n                  \n                  {isProcessing && (\n                    <span className={`text-xs ${isDarkMode ? 'text-gray-400' : 'text-gray-500'}`}>\n                      Düşünüyor...\n                    </span>\n                  )}\n                </div>\n              </div>\n            </div>\n          </div>\n        )}\n      </div>\n\n    {showCellDetails && selectedCell && (\n      <CellDetailsModal\n        cell={selectedCell}\n        relations={relations}\n        bidirectionalRelations={bidirectionalRelations}\n        isDarkMode={isDarkMode}\n        onClose={() => {\n          setShowCellDetails(false);\n          setSelectedCell(null);\n        }}\n      />\n    )}\n\n    {showCorrectAnswer && (\n      <CorrectAnswerModal\n        isDarkMode={isDarkMode}\n        onSubmit={handleCorrectAnswer}\n        onClose={() => setShowCorrectAnswer(false)}\n      />\n    )}\n\n    {showBatchTraining && (\n      <BatchTrainingModal\n        isDarkMode={isDarkMode}\n        onSubmit={handleBatchTraining}\n        onClose={() => setShowBatchTraining(false)}\n      />\n    )}\n    </div>\n  );\n}\n","size_bytes":58775},"attached_assets/BatchTrainingModal.tsx":{"content":"import React, { useState } from 'react';\nimport { X, Plus, Trash2, FileText, CheckCircle2, BookText, Layers } from 'lucide-react';\n\nexport interface TrainingPair {\n  input: string;\n  output: string;\n}\n\ninterface BatchTrainingModalProps {\n  isDarkMode: boolean;\n  onSubmit: (pairs: TrainingPair[]) => void;\n  onClose: () => void;\n}\n\nenum TrainingMode {\n  PAIR = 'pair',\n  BULK = 'bulk',\n  PARAGRAPH = 'paragraph'\n}\n\nconst SAMPLE_PAIRS: TrainingPair[] = [\n  {\n    input: \"Merhaba, nasılsın?\",\n    output: \"Merhaba! Ben bir yapay zeka asistanıyım ve çok iyiyim. Size nasıl yardımcı olabilirim?\"\n  },\n  {\n    input: \"Bugün hava nasıl?\",\n    output: \"Üzgünüm, anlık hava durumunu kontrol edemiyorum. Ancak size farklı konularda yardımcı olabilirim.\"\n  },\n  {\n    input: \"Yapay zeka nedir?\",\n    output: \"Yapay zeka (AI), insan zekasını taklit edebilen ve öğrenebilen, görevleri gerçekleştirebilen bilgisayar sistemlerini ifade eder. Sinir ağları, makine öğrenmesi ve derin öğrenme gibi teknolojiler yapay zekanın önemli alt alanlarıdır.\"\n  },\n  {\n    input: \"Sinir ağları nasıl çalışır?\",\n    output: \"Sinir ağları, insan beynindeki nöronların yapısından ilham alır. Girdi katmanı, gizli katmanlar ve çıktı katmanından oluşur. Her katmandaki nöronlar ağırlıklar aracılığıyla birbirine bağlanır ve aktivasyon fonksiyonlarıyla bilgiyi işler. Eğitim süreci, ağırlıkların veri üzerinde optimize edilmesiyle gerçekleşir.\"\n  },\n  {\n    input: \"Hafıza sistemleri ne işe yarar?\",\n    output: \"Hafıza sistemleri, yapay zeka sistemlerinin geçmiş bilgileri depolamasını ve gerektiğinde bu bilgilere erişmesini sağlar. Kısa vadeli ve uzun vadeli hafıza mekanizmaları, AI'nın tutarlı yanıtlar vermesine ve zaman içinde öğrenmesine olanak tanır.\"\n  }\n];\n\nconst SAMPLE_BULK = `Merhaba nasılsın? => İyiyim teşekkürler, size nasıl yardımcı olabilirim?\nYapay zeka nedir? => Yapay zeka, insan zekasını taklit eden ve öğrenebilen bilgisayar sistemleridir.\nTürkiye'nin başkenti neresi? => Türkiye'nin başkenti Ankara'dır.\nEn büyük gezegen hangisi? => Güneş sistemindeki en büyük gezegen Jüpiter'dir.\nSinir ağları nasıl öğrenir? => Sinir ağları, veri üzerinde tekrarlı eğitim yaparak, ağırlıkları optimize ederek öğrenir.`;\n\nconst SAMPLE_PARAGRAPH = `Yapay zeka, bilgisayarların insan benzeri düşünme, karar verme ve öğrenme yeteneklerini simüle etmeyi amaçlayan bir bilgisayar bilimi dalıdır. Yapay zekanın temel hedefi, bilgisayarların karmaşık sorunları çözmek, tahminlerde bulunmak ve insan müdahalesi olmadan kararlar vermek için veri ve deneyimlerden öğrenmesini sağlamaktır. Yapay zekanın iki ana türü vardır: dar yapay zeka ve genel yapay zeka. Dar yapay zeka, belirli görevleri yerine getirmek üzere tasarlanmış sistemleri ifade eder. Satranç oynama, görüntü tanıma veya konuşma çevirisi gibi alanlarda uzmanlaşabilirler. Genel yapay zeka ise, insanlar gibi herhangi bir entelektüel görevi anlama ve öğrenme yeteneğine sahip olacak sistemleri ifade eder.`;\n\nconst BatchTrainingModal: React.FC<BatchTrainingModalProps> = ({\n  isDarkMode,\n  onSubmit,\n  onClose\n}) => {\n  const [trainingMode, setTrainingMode] = useState<TrainingMode>(TrainingMode.PAIR);\n  const [pairs, setPairs] = useState<TrainingPair[]>([\n    { input: \"\", output: \"\" },\n    { input: \"\", output: \"\" }\n  ]);\n  const [bulkInput, setBulkInput] = useState<string>(\"\");\n  const [paragraphInput, setParagraphInput] = useState<string>(\"\");\n  const [error, setError] = useState<string>('');\n  const [showSamples, setShowSamples] = useState<boolean>(false);\n\n  const handleAddPair = () => {\n    setPairs([...pairs, { input: \"\", output: \"\" }]);\n  };\n\n  const handleRemovePair = (index: number) => {\n    if (pairs.length <= 1) {\n      setError('En az bir eğitim çifti gereklidir.');\n      return;\n    }\n    \n    const newPairs = [...pairs];\n    newPairs.splice(index, 1);\n    setPairs(newPairs);\n  };\n\n  const handlePairChange = (index: number, field: 'input' | 'output', value: string) => {\n    const newPairs = [...pairs];\n    newPairs[index][field] = value;\n    setPairs(newPairs);\n    \n    // Giriş yapılınca hata mesajını temizle\n    if (error) setError('');\n  };\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    \n    let validPairs: TrainingPair[] = [];\n    \n    if (trainingMode === TrainingMode.PAIR) {\n      validPairs = pairs.filter(pair => pair.input.trim() && pair.output.trim());\n      \n      if (validPairs.length === 0) {\n        setError('Lütfen en az bir geçerli eğitim çifti girin.');\n        return;\n      }\n    }\n    else if (trainingMode === TrainingMode.BULK) {\n      if (!bulkInput.trim()) {\n        setError('Lütfen toplu eğitim verisini girin.');\n        return;\n      }\n      \n      // Satır satır soru=>cevap formatında işle\n      validPairs = bulkInput.split('\\n')\n        .map(line => {\n          const parts = line.split('=>');\n          if (parts.length === 2) {\n            return {\n              input: parts[0].trim(),\n              output: parts[1].trim()\n            };\n          }\n          return null;\n        })\n        .filter(pair => pair !== null && pair.input && pair.output) as TrainingPair[];\n      \n      if (validPairs.length === 0) {\n        setError('Geçerli soru=>cevap çifti bulunamadı. Her satırın \"soru => cevap\" formatında olduğundan emin olun.');\n        return;\n      }\n    }\n    else if (trainingMode === TrainingMode.PARAGRAPH) {\n      if (!paragraphInput.trim()) {\n        setError('Lütfen eğitim için metin girin.');\n        return;\n      }\n      \n      // Paragraf öğrenme: Metin doğrudan analiz edilir,\n      // ancak arayüz tutarlılığı için bir çift oluşturuyoruz\n      validPairs = [{\n        input: 'paragraph_learning',\n        output: paragraphInput\n      }];\n    }\n    \n    // Eğitim moduna göre uygun veriyi gönder\n    onSubmit(validPairs);\n  };\n\n  const handleUseSamplePairs = () => {\n    setPairs(SAMPLE_PAIRS);\n    setShowSamples(false);\n  };\n  \n  const handleUseSampleBulk = () => {\n    setBulkInput(SAMPLE_BULK);\n    setShowSamples(false);\n  };\n  \n  const handleUseSampleParagraph = () => {\n    setParagraphInput(SAMPLE_PARAGRAPH);\n    setShowSamples(false);\n  };\n\n  return (\n    <div className=\"fixed inset-0 bg-black/50 flex items-center justify-center p-2 md:p-4 z-50 overflow-y-auto\">\n      <div \n        className={`w-full max-w-3xl max-h-[90vh] overflow-y-auto rounded-xl shadow-lg ${\n          isDarkMode ? 'bg-gray-800 text-gray-200' : 'bg-white text-gray-800'\n        }`}\n      >\n        <div \n          className={`flex items-center justify-between p-4 border-b ${\n            isDarkMode ? 'border-gray-700' : 'border-gray-200'\n          }`}\n        >\n          <h3 className=\"text-lg font-semibold\">Toplu Eğitim Modelleyicisi</h3>\n          <button\n            onClick={onClose}\n            className={`p-1 rounded-full transition-colors ${\n              isDarkMode\n                ? 'hover:bg-gray-700 text-gray-400 hover:text-gray-200'\n                : 'hover:bg-gray-100 text-gray-600 hover:text-gray-800'\n            }`}\n            aria-label=\"Kapat\"\n          >\n            <X size={20} />\n          </button>\n        </div>\n\n        <div className={`p-4 ${isDarkMode ? 'bg-gray-750 border-b border-gray-700' : 'bg-gray-50 border-b border-gray-200'}`}>\n          <div className=\"flex flex-col sm:flex-row gap-2 sm:gap-4\">\n            <button\n              type=\"button\"\n              onClick={() => setTrainingMode(TrainingMode.PAIR)}\n              className={`flex items-center px-3 py-2 rounded-lg transition-colors text-sm ${\n                trainingMode === TrainingMode.PAIR\n                  ? 'bg-blue-500 text-white shadow-md'\n                  : isDarkMode\n                    ? 'bg-gray-700 text-gray-300 hover:bg-gray-600'\n                    : 'bg-white text-gray-700 hover:bg-gray-100'\n              }`}\n            >\n              <Layers size={16} className=\"mr-1 sm:mr-2 flex-shrink-0\" />\n              <span>Soru-Cevap</span>\n            </button>\n            \n            <button\n              type=\"button\"\n              onClick={() => setTrainingMode(TrainingMode.BULK)}\n              className={`flex items-center px-3 py-2 rounded-lg transition-colors text-sm ${\n                trainingMode === TrainingMode.BULK\n                  ? 'bg-blue-500 text-white shadow-md'\n                  : isDarkMode\n                    ? 'bg-gray-700 text-gray-300 hover:bg-gray-600'\n                    : 'bg-white text-gray-700 hover:bg-gray-100'\n              }`}\n            >\n              <FileText size={16} className=\"mr-1 sm:mr-2 flex-shrink-0\" />\n              <span>Toplu Giriş</span>\n            </button>\n            \n            <button\n              type=\"button\"\n              onClick={() => setTrainingMode(TrainingMode.PARAGRAPH)}\n              className={`flex items-center px-3 py-2 rounded-lg transition-colors text-sm ${\n                trainingMode === TrainingMode.PARAGRAPH\n                  ? 'bg-blue-500 text-white shadow-md'\n                  : isDarkMode\n                    ? 'bg-gray-700 text-gray-300 hover:bg-gray-600'\n                    : 'bg-white text-gray-700 hover:bg-gray-100'\n              }`}\n            >\n              <BookText size={16} className=\"mr-1 sm:mr-2 flex-shrink-0\" />\n              <span>Kendi Kendine</span>\n            </button>\n          </div>\n        </div>\n\n        <form onSubmit={handleSubmit}>\n          <div className={`p-4 ${isDarkMode ? 'bg-gray-800' : 'bg-white'}`}>\n            {/* Mod açıklamaları */}\n            {trainingMode === TrainingMode.PAIR && (\n              <p className={`text-sm mb-4 ${isDarkMode ? 'text-gray-300' : 'text-gray-600'}`}>\n                Yapay zeka modelini tekil soru-cevap çiftleriyle eğitin. Her çift, bir kullanıcı girdisi ve \n                modelin vermeyi öğreneceği yanıttan oluşur.\n              </p>\n            )}\n            \n            {trainingMode === TrainingMode.BULK && (\n              <p className={`text-sm mb-4 ${isDarkMode ? 'text-gray-300' : 'text-gray-600'}`}>\n                Çoklu soru-cevap çiftlerini tek seferde girin. Her satır \"soru {'=>'} cevap\" formatında olmalıdır.\n                Sistem her satırı ayrı bir eğitim çifti olarak işleyecek.\n              </p>\n            )}\n            \n            {trainingMode === TrainingMode.PARAGRAPH && (\n              <p className={`text-sm mb-4 ${isDarkMode ? 'text-gray-300' : 'text-gray-600'}`}>\n                Uzun bir metin veya paragraf girin. Sistem, kelimeler arasındaki ilişkileri otomatik olarak\n                analiz edecek ve bilgi tabanını genişletecek. Bu mod, model için kendi kendine öğrenme sağlar.\n              </p>\n            )}\n            \n            {error && (\n              <div className=\"mb-4 p-3 bg-red-100 dark:bg-red-900/30 text-red-800 dark:text-red-300 rounded-lg text-sm\">\n                {error}\n              </div>\n            )}\n            \n            {/* Örnekler ve Ekle Butonu */}\n            <div className=\"mb-4 flex justify-between items-center\">\n              <button\n                type=\"button\"\n                onClick={() => setShowSamples(!showSamples)}\n                className={`text-sm flex items-center ${\n                  isDarkMode \n                    ? 'text-blue-400 hover:text-blue-300' \n                    : 'text-blue-600 hover:text-blue-700'\n                }`}\n              >\n                <FileText size={16} className=\"mr-1\" />\n                <span>Örnek{trainingMode === TrainingMode.PAIR ? ' çiftleri' : ''} {showSamples ? 'gizle' : 'göster'}</span>\n              </button>\n              \n              {trainingMode === TrainingMode.PAIR && (\n                <button\n                  type=\"button\"\n                  onClick={handleAddPair}\n                  className={`text-sm flex items-center px-3 py-1.5 rounded-lg transition-colors ${\n                    isDarkMode\n                      ? 'bg-blue-900/30 text-blue-400 hover:bg-blue-900/50'\n                      : 'bg-blue-50 text-blue-600 hover:bg-blue-100'\n                  }`}\n                >\n                  <Plus size={16} className=\"mr-1.5\" />\n                  <span>Yeni Çift Ekle</span>\n                </button>\n              )}\n            </div>\n            \n            {/* Örnekler Bölümü */}\n            {showSamples && (\n              <div className={`mb-4 p-4 rounded-lg border ${\n                isDarkMode ? 'border-gray-700 bg-gray-750' : 'border-gray-200 bg-gray-50'\n              }`}>\n                <div className=\"flex justify-between items-center mb-3\">\n                  <h4 className={`text-sm font-medium ${isDarkMode ? 'text-gray-300' : 'text-gray-700'}`}>\n                    Örnek {trainingMode === TrainingMode.PAIR ? 'Eğitim Çiftleri' : \n                           trainingMode === TrainingMode.BULK ? 'Toplu Veri' : 'Paragraf'}\n                  </h4>\n                  <button\n                    type=\"button\"\n                    onClick={\n                      trainingMode === TrainingMode.PAIR ? handleUseSamplePairs : \n                      trainingMode === TrainingMode.BULK ? handleUseSampleBulk : \n                      handleUseSampleParagraph\n                    }\n                    className={`text-xs flex items-center px-2 py-1 rounded transition-colors ${\n                      isDarkMode\n                        ? 'bg-green-900/30 text-green-400 hover:bg-green-900/50'\n                        : 'bg-green-50 text-green-600 hover:bg-green-100'\n                    }`}\n                  >\n                    <CheckCircle2 size={12} className=\"mr-1\" />\n                    <span>Örneği Kullan</span>\n                  </button>\n                </div>\n                \n                {trainingMode === TrainingMode.PAIR && (\n                  <div className=\"max-h-40 overflow-y-auto space-y-2 text-xs\">\n                    {SAMPLE_PAIRS.map((pair, index) => (\n                      <div \n                        key={index} \n                        className={`p-2 rounded ${\n                          isDarkMode ? 'bg-gray-700' : 'bg-gray-100'\n                        }`}\n                      >\n                        <div className={`mb-1 font-medium ${isDarkMode ? 'text-blue-400' : 'text-blue-600'}`}>\n                          Girdi: {pair.input}\n                        </div>\n                        <div className={`${isDarkMode ? 'text-green-400' : 'text-green-600'}`}>\n                          Çıktı: {pair.output.length > 60 ? `${pair.output.substring(0, 60)}...` : pair.output}\n                        </div>\n                      </div>\n                    ))}\n                  </div>\n                )}\n                \n                {trainingMode === TrainingMode.BULK && (\n                  <div className={`p-2 rounded text-xs font-mono whitespace-pre-wrap max-h-40 overflow-y-auto ${\n                    isDarkMode ? 'bg-gray-700 text-gray-200' : 'bg-gray-100 text-gray-800'\n                  }`}>\n                    {SAMPLE_BULK}\n                  </div>\n                )}\n                \n                {trainingMode === TrainingMode.PARAGRAPH && (\n                  <div className={`p-2 rounded text-xs max-h-40 overflow-y-auto ${\n                    isDarkMode ? 'bg-gray-700 text-gray-200' : 'bg-gray-100 text-gray-800'\n                  }`}>\n                    {SAMPLE_PARAGRAPH}\n                  </div>\n                )}\n              </div>\n            )}\n            \n            {/* Eğitim Modu Formları */}\n            {trainingMode === TrainingMode.PAIR && (\n              <div className=\"space-y-4 max-h-[300px] overflow-y-auto pr-2\">\n                {pairs.map((pair, index) => (\n                  <div \n                    key={index} \n                    className={`p-4 rounded-lg border ${\n                      isDarkMode ? 'border-gray-700' : 'border-gray-300'\n                    }`}\n                  >\n                    <div className=\"flex justify-between mb-2\">\n                      <h4 className={`text-sm font-medium ${isDarkMode ? 'text-gray-300' : 'text-gray-700'}`}>\n                        Çift #{index + 1}\n                      </h4>\n                      <button\n                        type=\"button\"\n                        onClick={() => handleRemovePair(index)}\n                        className={`p-1 rounded transition-colors ${\n                          isDarkMode\n                            ? 'text-gray-400 hover:text-red-400 hover:bg-gray-700'\n                            : 'text-gray-500 hover:text-red-500 hover:bg-gray-100'\n                        }`}\n                        aria-label=\"Çifti sil\"\n                      >\n                        <Trash2 size={16} />\n                      </button>\n                    </div>\n                    \n                    <div className=\"space-y-3\">\n                      <div>\n                        <label \n                          htmlFor={`input-${index}`} \n                          className={`block mb-1 text-xs font-medium ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}\n                        >\n                          Kullanıcı Girdisi\n                        </label>\n                        <input\n                          id={`input-${index}`}\n                          value={pair.input}\n                          onChange={(e) => handlePairChange(index, 'input', e.target.value)}\n                          placeholder=\"Örn: 'Merhaba, nasılsın?'\"\n                          className={`w-full p-2 rounded-lg text-sm border ${\n                            isDarkMode\n                              ? 'bg-gray-700 border-gray-600 text-gray-200 placeholder-gray-400'\n                              : 'bg-white border-gray-300 text-gray-800 placeholder-gray-400'\n                          } focus:outline-none focus:ring-2 ${\n                            isDarkMode ? 'focus:ring-blue-500/50' : 'focus:ring-blue-500/70'\n                          } focus:border-blue-500`}\n                        />\n                      </div>\n                      \n                      <div>\n                        <label \n                          htmlFor={`output-${index}`} \n                          className={`block mb-1 text-xs font-medium ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}\n                        >\n                          Beklenen Yanıt\n                        </label>\n                        <textarea\n                          id={`output-${index}`}\n                          value={pair.output}\n                          onChange={(e) => handlePairChange(index, 'output', e.target.value)}\n                          placeholder=\"Örn: 'Merhaba! Ben bir yapay zeka asistanıyım. Size nasıl yardımcı olabilirim?'\"\n                          rows={3}\n                          className={`w-full p-2 rounded-lg text-sm border ${\n                            isDarkMode\n                              ? 'bg-gray-700 border-gray-600 text-gray-200 placeholder-gray-400'\n                              : 'bg-white border-gray-300 text-gray-800 placeholder-gray-400'\n                          } focus:outline-none focus:ring-2 ${\n                            isDarkMode ? 'focus:ring-blue-500/50' : 'focus:ring-blue-500/70'\n                          } focus:border-blue-500 resize-none`}\n                        />\n                      </div>\n                    </div>\n                  </div>\n                ))}\n              </div>\n            )}\n            \n            {trainingMode === TrainingMode.BULK && (\n              <div className=\"mb-4\">\n                <label \n                  htmlFor=\"bulk-input\" \n                  className={`block mb-2 text-sm font-medium ${isDarkMode ? 'text-gray-300' : 'text-gray-700'}`}\n                >\n                  Toplu Eğitim Verisi (Her satıra bir soru {'=>'} cevap çifti)\n                </label>\n                <textarea\n                  id=\"bulk-input\"\n                  value={bulkInput}\n                  onChange={(e) => setBulkInput(e.target.value)}\n                  placeholder=\"Örn: Selam nasılsın? => İyiyim, teşekkürler.\\nYapay zeka nedir? => İnsan zekasını taklit eden bilgisayar sistemleridir.\"\n                  rows={12}\n                  className={`w-full p-3 rounded-lg text-sm border ${\n                    isDarkMode\n                      ? 'bg-gray-700 border-gray-600 text-gray-200 placeholder-gray-400'\n                      : 'bg-white border-gray-300 text-gray-800 placeholder-gray-400'\n                  } focus:outline-none focus:ring-2 ${\n                    isDarkMode ? 'focus:ring-blue-500/50' : 'focus:ring-blue-500/70'\n                  } focus:border-blue-500`}\n                />\n                <p className={`mt-2 text-xs ${isDarkMode ? 'text-gray-400' : 'text-gray-500'}`}>\n                  Her satır \"soru {'=>'} cevap\" formatında olmalıdır. Boş satırlar atlanacaktır.\n                </p>\n              </div>\n            )}\n            \n            {trainingMode === TrainingMode.PARAGRAPH && (\n              <div className=\"mb-4\">\n                <label \n                  htmlFor=\"paragraph-input\" \n                  className={`block mb-2 text-sm font-medium ${isDarkMode ? 'text-gray-300' : 'text-gray-700'}`}\n                >\n                  Kendi Kendine Eğitim için Metin Girin\n                </label>\n                <textarea\n                  id=\"paragraph-input\"\n                  value={paragraphInput}\n                  onChange={(e) => setParagraphInput(e.target.value)}\n                  placeholder=\"Buraya öğrenmesini istediğiniz metni, paragrafı veya bilgiyi yazın. Sistem bu metindeki kelimeler arasındaki ilişkileri otomatik olarak algılayacak ve gelecekteki yanıtlarında kullanacaktır.\"\n                  rows={12}\n                  className={`w-full p-3 rounded-lg text-sm border ${\n                    isDarkMode\n                      ? 'bg-gray-700 border-gray-600 text-gray-200 placeholder-gray-400'\n                      : 'bg-white border-gray-300 text-gray-800 placeholder-gray-400'\n                  } focus:outline-none focus:ring-2 ${\n                    isDarkMode ? 'focus:ring-blue-500/50' : 'focus:ring-blue-500/70'\n                  } focus:border-blue-500`}\n                />\n                <p className={`mt-2 text-xs ${isDarkMode ? 'text-gray-400' : 'text-gray-500'}`}>\n                  Metin ne kadar uzun ve detaylı olursa, sistem o kadar iyi öğrenecektir. İlgili terimler ve kavramlar arasındaki ilişkiler otomatik olarak analiz edilecektir.\n                </p>\n              </div>\n            )}\n          </div>\n\n          <div className={`p-4 border-t ${isDarkMode ? 'border-gray-700' : 'border-gray-200'}`}>\n            <div className=\"text-xs text-gray-500 dark:text-gray-400 mb-3\">\n              {trainingMode === TrainingMode.PAIR && \"Not: Geçerli çiftler modelin eğitilmesi için kullanılacaktır. Her çift için hem girdi hem de çıktı gereklidir.\"}\n              {trainingMode === TrainingMode.BULK && \"Not: Girdiğiniz her satır 'soru {'=>'} cevap' formatında olmalıdır. Sistem her satırı ayrı bir eğitim çifti olarak işleyecektir.\"}\n              {trainingMode === TrainingMode.PARAGRAPH && \"Not: Sistem bu metni analiz ederek kelimeler arasındaki ilişkileri öğrenecek ve sorularınıza cevap verirken bu ilişkilerden yararlanacaktır.\"}\n            </div>\n            \n            <div className=\"flex justify-end gap-2\">\n              <button\n                type=\"button\"\n                onClick={onClose}\n                className={`px-4 py-2 rounded-lg transition-colors ${\n                  isDarkMode\n                    ? 'bg-gray-700 hover:bg-gray-600 text-gray-300'\n                    : 'bg-gray-100 hover:bg-gray-200 text-gray-700'\n                }`}\n              >\n                İptal\n              </button>\n              <button\n                type=\"submit\"\n                className=\"px-4 py-2 rounded-lg bg-blue-500 hover:bg-blue-600 text-white transition-colors\"\n              >\n                Eğitimi Başlat\n              </button>\n            </div>\n          </div>\n        </form>\n      </div>\n    </div>\n  );\n};\n\nexport default BatchTrainingModal;\n","size_bytes":24380},"attached_assets/CellDetailsModal.tsx":{"content":"import React, { useState } from 'react';\nimport { X, Zap, ArrowRight, ChevronsUp, ChevronsDown } from 'lucide-react';\nimport { NetworkNode, Relation } from '../lib/NeuralNetworkUtils';\n\ninterface CellDetailsModalProps {\n  cell: NetworkNode & { layer: number; row: number; col: number; type: 'user' | 'system' };\n  relations: Relation[];\n  bidirectionalRelations: Relation[];\n  isDarkMode: boolean;\n  onClose: () => void;\n}\n\nconst CellDetailsModal: React.FC<CellDetailsModalProps> = ({\n  cell,\n  relations,\n  bidirectionalRelations,\n  isDarkMode,\n  onClose\n}) => {\n  const [activeTab, setActiveTab] = useState<'overview' | 'relations'>('overview');\n  \n  // Bu hücre ile ilgili ilişkileri filtreleme\n  const relevantRelations = relations.filter(\n    rel => rel.userWord === cell.word || rel.systemWord === cell.word\n  );\n  \n  const bidirectionalRels = bidirectionalRelations.filter(\n    rel => rel.userWord === cell.word || rel.systemWord === cell.word\n  );\n  \n  // İlişkileri skorlarına göre sıralama\n  const sortedRelations = [...relevantRelations].sort((a, b) => {\n    const scoreA = a.dependency + a.association + a.frequency;\n    const scoreB = b.dependency + b.association + b.frequency;\n    return scoreB - scoreA;\n  });\n  \n  const sortedBidirectional = [...bidirectionalRels].sort((a, b) => {\n    const scoreA = a.dependency + a.association + a.frequency;\n    const scoreB = b.dependency + b.association + b.frequency;\n    return scoreB - scoreA;\n  });\n\n  return (\n    <div className=\"fixed inset-0 bg-black/50 flex items-center justify-center p-2 md:p-4 z-50 overflow-y-auto\">\n      <div \n        className={`w-full max-w-2xl max-h-[90vh] overflow-y-auto rounded-xl shadow-lg ${\n          isDarkMode ? 'bg-gray-800 text-gray-200' : 'bg-white text-gray-800'\n        }`}\n      >\n        <div \n          className={`flex items-center justify-between p-4 border-b ${\n            isDarkMode ? 'border-gray-700' : 'border-gray-200'\n          }`}\n        >\n          <h3 className=\"text-lg font-medium\">\n            <span className={cell.type === 'user' ? 'text-blue-500' : 'text-green-500'}>\n              {cell.word}\n            </span> \n            <span className=\"ml-2 text-sm opacity-70\">\n              ({cell.type === 'user' ? 'Kullanıcı' : 'Sistem'} Kelimesi)\n            </span>\n          </h3>\n          <button\n            onClick={onClose}\n            className={`p-1 rounded-full transition-colors ${\n              isDarkMode\n                ? 'hover:bg-gray-700 text-gray-400 hover:text-gray-200'\n                : 'hover:bg-gray-100 text-gray-600 hover:text-gray-800'\n            }`}\n            aria-label=\"Kapat\"\n          >\n            <X size={20} />\n          </button>\n        </div>\n        \n        {/* Tab Bar */}\n        <div \n          className={`flex border-b ${\n            isDarkMode ? 'border-gray-700' : 'border-gray-200'\n          }`}\n        >\n          <button\n            onClick={() => setActiveTab('overview')}\n            className={`px-4 py-3 text-sm font-medium transition-colors ${\n              activeTab === 'overview'\n                ? isDarkMode\n                  ? 'bg-gray-700 text-blue-400 border-b-2 border-blue-400'\n                  : 'bg-blue-50 text-blue-600 border-b-2 border-blue-600'\n                : isDarkMode\n                  ? 'text-gray-400 hover:text-gray-200'\n                  : 'text-gray-600 hover:text-gray-800'\n            }`}\n          >\n            Genel Bakış\n          </button>\n          <button\n            onClick={() => setActiveTab('relations')}\n            className={`px-4 py-3 text-sm font-medium transition-colors ${\n              activeTab === 'relations'\n                ? isDarkMode\n                  ? 'bg-gray-700 text-green-400 border-b-2 border-green-400'\n                  : 'bg-green-50 text-green-600 border-b-2 border-green-600'\n                : isDarkMode\n                  ? 'text-gray-400 hover:text-gray-200'\n                  : 'text-gray-600 hover:text-gray-800'\n            }`}\n          >\n            İlişkiler ({sortedRelations.length + sortedBidirectional.length})\n          </button>\n        </div>\n\n        {/* Tab Content */}\n        <div className=\"p-4 max-h-[calc(80vh-150px)] overflow-y-auto\">\n          {activeTab === 'overview' ? (\n            <div className=\"space-y-4\">\n              <div className={`p-4 rounded-lg ${isDarkMode ? 'bg-gray-700' : 'bg-gray-100'}`}>\n                <div className=\"grid grid-cols-2 gap-4\">\n                  <div>\n                    <div className=\"text-xs opacity-70 mb-1\">Aktivasyon</div>\n                    <div className=\"flex items-center\">\n                      <div className=\"mr-2\">\n                        <Zap \n                          size={16} \n                          className={`${cell.activation > 0.5 ? 'text-yellow-500' : 'text-gray-400'}`} \n                        />\n                      </div>\n                      <div className=\"w-full bg-gray-200 dark:bg-gray-600 rounded-full h-2\">\n                        <div \n                          className=\"bg-yellow-500 h-2 rounded-full\" \n                          style={{ width: `${cell.activation * 100}%` }}\n                        ></div>\n                      </div>\n                      <div className=\"ml-2 text-sm font-medium\">\n                        {Math.round(cell.activation * 100)}%\n                      </div>\n                    </div>\n                  </div>\n                  \n                  <div>\n                    <div className=\"text-xs opacity-70 mb-1\">Kullanım Sayısı</div>\n                    <div className=\"text-lg font-medium\">\n                      {cell.count}\n                    </div>\n                  </div>\n                  \n                  <div>\n                    <div className=\"text-xs opacity-70 mb-1\">Sıklık Değeri</div>\n                    <div className=\"text-lg font-medium\">\n                      {cell.frequency}\n                    </div>\n                  </div>\n                  \n                  <div>\n                    <div className=\"text-xs opacity-70 mb-1\">Geri Bildirim Skoru</div>\n                    <div className=\"flex items-center\">\n                      {cell.feedback > 0 ? (\n                        <ChevronsUp size={16} className=\"text-green-500 mr-1\" />\n                      ) : cell.feedback < 0 ? (\n                        <ChevronsDown size={16} className=\"text-red-500 mr-1\" />\n                      ) : null}\n                      <span className=\"text-lg font-medium\">\n                        {cell.feedback > 0 ? `+${cell.feedback}` : cell.feedback}\n                      </span>\n                    </div>\n                  </div>\n                </div>\n              </div>\n              \n              <div>\n                <h4 className=\"text-sm font-medium mb-2\">Konum Bilgileri</h4>\n                <div className={`p-3 rounded-lg text-sm ${isDarkMode ? 'bg-gray-700' : 'bg-gray-100'}`}>\n                  <div className=\"grid grid-cols-3 gap-2\">\n                    <div>\n                      <span className=\"opacity-70\">Katman:</span> {cell.layer + 1}\n                    </div>\n                    <div>\n                      <span className=\"opacity-70\">Satır:</span> {cell.row + 1}\n                    </div>\n                    <div>\n                      <span className=\"opacity-70\">Sütun:</span> {cell.col + 1}\n                    </div>\n                  </div>\n                </div>\n              </div>\n              \n              <div>\n                <h4 className=\"text-sm font-medium mb-2\">Bağlantılar</h4>\n                {cell.connections.length > 0 ? (\n                  <div className={`p-3 rounded-lg ${isDarkMode ? 'bg-gray-700' : 'bg-gray-100'}`}>\n                    <div className=\"flex flex-wrap gap-2\">\n                      {cell.connections.map((word, index) => (\n                        <span \n                          key={index}\n                          className={`px-2 py-1 rounded-md text-xs ${\n                            isDarkMode \n                              ? 'bg-gray-600 text-gray-200' \n                              : 'bg-gray-200 text-gray-800'\n                          }`}\n                        >\n                          {word}\n                        </span>\n                      ))}\n                    </div>\n                  </div>\n                ) : (\n                  <div className={`p-3 rounded-lg text-sm italic ${\n                    isDarkMode ? 'bg-gray-700 text-gray-400' : 'bg-gray-100 text-gray-500'\n                  }`}>\n                    Hiç bağlantı yok\n                  </div>\n                )}\n              </div>\n              \n              {cell.parentWords && cell.parentWords.length > 0 && (\n                <div>\n                  <h4 className=\"text-sm font-medium mb-2\">Üst Kelimeler</h4>\n                  <div className={`p-3 rounded-lg ${isDarkMode ? 'bg-gray-700' : 'bg-gray-100'}`}>\n                    <div className=\"flex flex-wrap gap-2\">\n                      {cell.parentWords.map((word, index) => (\n                        <span \n                          key={index}\n                          className={`px-2 py-1 rounded-md text-xs ${\n                            isDarkMode \n                              ? 'bg-blue-900/40 text-blue-300' \n                              : 'bg-blue-100 text-blue-800'\n                          }`}\n                        >\n                          {word}\n                        </span>\n                      ))}\n                    </div>\n                  </div>\n                </div>\n              )}\n            </div>\n          ) : (\n            <div className=\"space-y-5\">\n              {sortedRelations.length > 0 && (\n                <div>\n                  <h4 className=\"text-sm font-medium mb-2\">Tek Yönlü İlişkiler</h4>\n                  <div className=\"space-y-2\">\n                    {sortedRelations.map((relation, index) => (\n                      <div \n                        key={index}\n                        className={`p-3 rounded-lg ${\n                          isDarkMode ? 'bg-gray-700' : 'bg-gray-100'\n                        }`}\n                      >\n                        <div className=\"flex items-center\">\n                          <div className={`font-medium ${isDarkMode ? 'text-blue-400' : 'text-blue-600'}`}>\n                            {relation.userWord}\n                          </div>\n                          <ArrowRight size={14} className=\"mx-2 opacity-70\" />\n                          <div className={`font-medium ${isDarkMode ? 'text-green-400' : 'text-green-600'}`}>\n                            {relation.systemWord}\n                          </div>\n                        </div>\n                        \n                        <div className=\"mt-2 grid grid-cols-3 gap-2 text-xs\">\n                          <div>\n                            <span className=\"opacity-70\">Bağımlılık:</span> {relation.dependency}\n                          </div>\n                          <div>\n                            <span className=\"opacity-70\">İlişki:</span> {relation.association}\n                          </div>\n                          <div>\n                            <span className=\"opacity-70\">Sıklık:</span> {relation.frequency}\n                          </div>\n                        </div>\n                      </div>\n                    ))}\n                  </div>\n                </div>\n              )}\n              \n              {sortedBidirectional.length > 0 && (\n                <div>\n                  <h4 className=\"text-sm font-medium mb-2\">Çift Yönlü İlişkiler</h4>\n                  <div className=\"space-y-2\">\n                    {sortedBidirectional.map((relation, index) => (\n                      <div \n                        key={index}\n                        className={`p-3 rounded-lg ${\n                          isDarkMode ? 'bg-gray-700' : 'bg-gray-100'\n                        }`}\n                      >\n                        <div className=\"flex items-center\">\n                          <div \n                            className={`font-medium ${\n                              relation.isReversed\n                                ? isDarkMode ? 'text-green-400' : 'text-green-600'\n                                : isDarkMode ? 'text-blue-400' : 'text-blue-600'\n                            }`}\n                          >\n                            {relation.userWord}\n                          </div>\n                          <div className=\"mx-2 flex items-center justify-center\">\n                            <ArrowRight \n                              size={14} \n                              className={`${relation.isReversed ? 'rotate-180' : ''} opacity-70`} \n                            />\n                          </div>\n                          <div \n                            className={`font-medium ${\n                              relation.isReversed\n                                ? isDarkMode ? 'text-blue-400' : 'text-blue-600'\n                                : isDarkMode ? 'text-green-400' : 'text-green-600'\n                            }`}\n                          >\n                            {relation.systemWord}\n                          </div>\n                        </div>\n                        \n                        <div className=\"mt-2 grid grid-cols-3 gap-2 text-xs\">\n                          <div>\n                            <span className=\"opacity-70\">Bağımlılık:</span> {relation.dependency}\n                          </div>\n                          <div>\n                            <span className=\"opacity-70\">İlişki:</span> {relation.association}\n                          </div>\n                          <div>\n                            <span className=\"opacity-70\">Sıklık:</span> {relation.frequency}\n                          </div>\n                        </div>\n                        \n                        {relation.ai_generated && (\n                          <div className=\"mt-1 text-xs\">\n                            <span \n                              className={`px-1.5 py-0.5 rounded ${\n                                isDarkMode \n                                  ? 'bg-purple-900/40 text-purple-300' \n                                  : 'bg-purple-100 text-purple-800'\n                              }`}\n                            >\n                              Yapay Zeka Tarafından Oluşturuldu\n                            </span>\n                          </div>\n                        )}\n                      </div>\n                    ))}\n                  </div>\n                </div>\n              )}\n              \n              {sortedRelations.length === 0 && sortedBidirectional.length === 0 && (\n                <div className={`p-4 rounded-lg text-center italic ${\n                  isDarkMode ? 'bg-gray-700 text-gray-400' : 'bg-gray-100 text-gray-500'\n                }`}>\n                  Bu kelime için hiç ilişki bulunamadı.\n                </div>\n              )}\n            </div>\n          )}\n        </div>\n        \n        <div \n          className={`p-4 border-t flex justify-end ${\n            isDarkMode ? 'border-gray-700' : 'border-gray-200'\n          }`}\n        >\n          <button\n            onClick={onClose}\n            className={`px-4 py-2 rounded-lg transition-colors ${\n              isDarkMode\n                ? 'bg-gray-700 hover:bg-gray-600 text-gray-200'\n                : 'bg-gray-100 hover:bg-gray-200 text-gray-800'\n            }`}\n          >\n            Kapat\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default CellDetailsModal;\n","size_bytes":15695},"attached_assets/ChatInterface.tsx":{"content":"import React, { useState, useRef, useEffect } from 'react';\nimport { SendHorizonal, RotateCcw, ThumbsUp, ThumbsDown, Brain, Moon, Sun, Image, Paperclip, Smile, HelpCircle, Settings, Sparkles } from 'lucide-react';\nimport { EnhancedMemorySystem } from '../lib/EnhancedMemorySystem';\nimport ChatMessage from './ChatMessage';\nimport InputBox from './InputBox';\nimport { useTheme } from '../contexts/ThemeContext';\nimport { Button } from './ui/button';\nimport { Tooltip } from './ui/tooltip';\nimport { TooltipContent, TooltipTrigger, TooltipProvider } from './ui/tooltip';\nimport { Skeleton } from './ui/skeleton';\nimport { useIsMobile } from '@/hooks/use-mobile';\n\nexport interface Message {\n  id: string;\n  content: string;\n  isUser: boolean;\n  timestamp?: number;\n  feedback?: number; // -1: negatif, 0: nötr, 1: pozitif\n  thinking?: boolean;\n  error?: boolean;\n  attachments?: string[];\n}\n\nexport interface ChatInterfaceProps {\n  memorySystem: EnhancedMemorySystem;\n  onSendMessage: (message: string) => Promise<void>;\n  messages: Message[];\n  onFeedback: (messageId: string, isPositive: boolean) => void;\n  onTrainBot?: () => void;\n  onShowMemories?: () => void;\n  onShowNetwork?: () => void;\n  title?: string;\n  subtitle?: string;\n  isTrainingMode?: boolean;\n}\n\nconst ChatInterface: React.FC<ChatInterfaceProps> = ({\n  memorySystem,\n  onSendMessage,\n  messages,\n  onFeedback,\n  onTrainBot,\n  onShowMemories,\n  onShowNetwork,\n  title = \"Türkçe Yapay Zeka Chatbot\",\n  subtitle = \"Sinir ağı tabanlı, gelişmiş hafıza sistemine sahip chatbot\",\n  isTrainingMode = false\n}) => {\n  const [inputValue, setInputValue] = useState('');\n  const [isLoading, setIsLoading] = useState(false);\n  const [isTyping, setIsTyping] = useState(false);\n  const [showEmojiPicker, setShowEmojiPicker] = useState(false);\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n  const { isDarkMode, toggleTheme } = useTheme();\n  const isMobile = useIsMobile();\n  \n  // Kısa ve uzun vadeli bellek sayıları\n  const shortTermCount = memorySystem.shortTerm?.length || 0;\n  const longTermCount = memorySystem.longTerm?.length || 0;\n  const totalClusters = memorySystem.memoryClusters?.length || 0;\n\n  // Mesajlar değiştiğinde otomatik kaydırma\n  useEffect(() => {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n  }, [messages]);\n\n  // Düşünme animasyonu efekti\n  useEffect(() => {\n    if (isLoading) {\n      const typingInterval = setInterval(() => {\n        setIsTyping(prev => !prev);\n      }, 500);\n      \n      return () => clearInterval(typingInterval);\n    }\n  }, [isLoading]);\n\n  // Mesaj gönderme fonksiyonu\n  const handleSendMessage = async () => {\n    if (!inputValue.trim()) return;\n    \n    setIsLoading(true);\n    await onSendMessage(inputValue);\n    setInputValue('');\n    setIsLoading(false);\n  };\n\n  // Enter tuşuna basıldığında mesaj gönderme\n  const handleKeyPress = (e: React.KeyboardEvent) => {\n    if (e.key === 'Enter' && !e.shiftKey) {\n      e.preventDefault();\n      handleSendMessage();\n    }\n  };\n\n  return (\n    <div className=\"chat-container\">\n      {/* Başlık ve Araç Çubuğu */}\n      <div className=\"rounded-t-xl bg-gradient-to-r from-indigo-600 to-violet-600 text-white shadow-lg\">\n        <div className=\"flex justify-between items-center p-3 md:p-4\">\n          <div className=\"flex items-center\">\n            <div className=\"hidden md:flex items-center justify-center w-10 h-10 rounded-full bg-white/20 mr-3\">\n              <Brain size={24} className=\"text-white\" />\n            </div>\n            <div>\n              <h1 className=\"text-lg md:text-xl font-bold leading-tight\">{title}</h1>\n              <p className=\"text-xs md:text-sm opacity-90 hidden md:block\">{subtitle}</p>\n            </div>\n          </div>\n          \n          <div className=\"flex space-x-1 md:space-x-2\">\n            <TooltipProvider>\n              {!isMobile && (\n                <>\n                  <Tooltip>\n                    <TooltipTrigger asChild>\n                      <Button \n                        variant=\"ghost\" \n                        size=\"icon\"\n                        onClick={onShowMemories}\n                        className=\"h-8 w-8 md:h-9 md:w-9 text-white hover:bg-white/20 rounded-full\"\n                      >\n                        <Sparkles size={isMobile ? 16 : 18} />\n                      </Button>\n                    </TooltipTrigger>\n                    <TooltipContent>Hafıza Sistemi</TooltipContent>\n                  </Tooltip>\n                  \n                  <Tooltip>\n                    <TooltipTrigger asChild>\n                      <Button \n                        variant=\"ghost\" \n                        size=\"icon\"\n                        onClick={onShowNetwork}\n                        className=\"h-8 w-8 md:h-9 md:w-9 text-white hover:bg-white/20 rounded-full\"\n                      >\n                        <Brain size={isMobile ? 16 : 18} />\n                      </Button>\n                    </TooltipTrigger>\n                    <TooltipContent>Sinir Ağı</TooltipContent>\n                  </Tooltip>\n                </>\n              )}\n              \n              <Tooltip>\n                <TooltipTrigger asChild>\n                  <Button \n                    variant=\"ghost\" \n                    size=\"icon\"\n                    onClick={onTrainBot}\n                    className=\"h-8 w-8 md:h-9 md:w-9 text-white hover:bg-white/20 rounded-full\"\n                  >\n                    <Settings size={isMobile ? 16 : 18} />\n                  </Button>\n                </TooltipTrigger>\n                <TooltipContent>Eğitim Modu</TooltipContent>\n              </Tooltip>\n              \n              <Tooltip>\n                <TooltipTrigger asChild>\n                  <Button \n                    variant=\"ghost\" \n                    size=\"icon\"\n                    onClick={toggleTheme}\n                    className=\"h-8 w-8 md:h-9 md:w-9 text-white hover:bg-white/20 rounded-full\"\n                  >\n                    {isDarkMode ? (\n                      <Sun size={isMobile ? 16 : 18} />\n                    ) : (\n                      <Moon size={isMobile ? 16 : 18} />\n                    )}\n                  </Button>\n                </TooltipTrigger>\n                <TooltipContent>{isDarkMode ? 'Aydınlık Mod' : 'Karanlık Mod'}</TooltipContent>\n              </Tooltip>\n            </TooltipProvider>\n          </div>\n        </div>\n        \n        {/* Durum Bilgisi */}\n        <div className=\"px-3 pb-2 md:px-4 md:pb-3 flex justify-between text-xs\">\n          <div className=\"flex items-center opacity-80\">\n            <div className=\"w-2 h-2 rounded-full bg-green-400 mr-1\"></div>\n            <span>{isTrainingMode ? 'Eğitim Modu' : 'Çevrimiçi'}</span>\n          </div>\n          \n          <div className=\"flex items-center space-x-3 opacity-80\">\n            <span>{shortTermCount} kısa vadeli hafıza</span>\n            <span>{longTermCount} uzun vadeli hafıza</span>\n            <span>{totalClusters} bellek kümesi</span>\n          </div>\n        </div>\n      </div>\n      \n      {/* Mesajlar */}\n      <div className=\"chat-messages bg-gray-50 dark:bg-gray-900 border-x border-gray-200 dark:border-gray-800\">\n        {messages.length === 0 ? (\n          <div className=\"h-full flex flex-col items-center justify-center text-gray-500 dark:text-gray-400 p-4 md:p-8\">\n            <div className=\"w-20 h-20 mb-6 rounded-full bg-gradient-to-br from-indigo-100 to-purple-100 dark:from-indigo-900/30 dark:to-purple-900/30 flex items-center justify-center\">\n              <Brain size={32} className=\"text-indigo-500 dark:text-indigo-400\" />\n            </div>\n            <h2 className=\"text-lg md:text-xl font-medium text-gray-700 dark:text-gray-300 mb-2 text-center\">\n              Yapay Zeka Sohbet Asistanı\n            </h2>\n            <p className=\"text-center max-w-md mb-6 text-sm md:text-base\">\n              Merhaba! Benimle Türkçe konuşabilirsiniz. Size nasıl yardımcı olabilirim?\n            </p>\n            <div className=\"grid grid-cols-1 md:grid-cols-2 gap-3 w-full max-w-md\">\n              <Button \n                variant=\"outline\" \n                className=\"text-sm justify-start py-6 px-4\"\n                onClick={() => setInputValue(\"Yapay zeka konusunda bana bilgi verebilir misin?\")}\n              >\n                <HelpCircle size={16} className=\"mr-2 text-indigo-500\" />\n                Yapay zeka hakkında bilgi\n              </Button>\n              <Button \n                variant=\"outline\" \n                className=\"text-sm justify-start py-6 px-4\"\n                onClick={() => setInputValue(\"Sinir ağları nasıl çalışır?\")}\n              >\n                <Brain size={16} className=\"mr-2 text-indigo-500\" />\n                Sinir ağları nasıl çalışır?\n              </Button>\n              <Button \n                variant=\"outline\" \n                className=\"text-sm justify-start py-6 px-4\"\n                onClick={() => setInputValue(\"Hafıza sistemleri nedir?\")}\n              >\n                <Sparkles size={16} className=\"mr-2 text-indigo-500\" />\n                Hafıza sistemleri nedir?\n              </Button>\n              <Button \n                variant=\"outline\" \n                className=\"text-sm justify-start py-6 px-4\"\n                onClick={() => setInputValue(\"Ne tür konularda yardımcı olabilirsin?\")}\n              >\n                <HelpCircle size={16} className=\"mr-2 text-indigo-500\" />\n                Ne konularda yardımcı olabilirsin?\n              </Button>\n            </div>\n          </div>\n        ) : (\n          <div className=\"px-2 md:px-4 py-4\">\n            {messages.map((message, index) => (\n              <ChatMessage \n                key={message.id} \n                message={message} \n                onFeedback={onFeedback} \n              />\n            ))}\n            \n            {isLoading && (\n              <div className=\"flex items-start gap-3 mb-4 max-w-3xl mx-auto animate-pulse\">\n                <div className=\"w-9 h-9 rounded-full bg-indigo-100 dark:bg-indigo-700/30 flex items-center justify-center\">\n                  <Brain size={20} className=\"text-indigo-500 dark:text-indigo-400\" />\n                </div>\n                <div className=\"flex-1\">\n                  <div className=\"p-3 bg-white dark:bg-gray-800 rounded-lg shadow-sm\">\n                    <div className=\"flex items-center gap-2 mb-2\">\n                      <div className=\"h-4 w-24 bg-indigo-100 dark:bg-gray-700 rounded\"></div>\n                      <div className=\"h-3 w-12 bg-gray-100 dark:bg-gray-700 rounded\"></div>\n                    </div>\n                    <div className=\"space-y-2\">\n                      <Skeleton className=\"h-4 w-full\" />\n                      <Skeleton className=\"h-4 w-11/12\" />\n                      <Skeleton className=\"h-4 w-3/4\" />\n                    </div>\n                  </div>\n                </div>\n              </div>\n            )}\n            \n            <div ref={messagesEndRef} />\n          </div>\n        )}\n      </div>\n      \n      {/* Mesaj giriş alanı */}\n      <div className=\"chat-input-container\">\n        <div className=\"flex items-end\">\n          <div className=\"flex-1 relative\">\n            <InputBox\n              value={inputValue}\n              onChange={setInputValue}\n              onKeyPress={handleKeyPress}\n              placeholder=\"Bir mesaj yazın...\"\n              onSubmit={handleSendMessage}\n            />\n            \n            {/* Emoji ve eklenti butonları */}\n            <div className=\"absolute bottom-0 left-3 h-10 flex items-center space-x-1\">\n              <Button \n                variant=\"ghost\" \n                size=\"icon\"\n                className=\"h-8 w-8 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 rounded-full\"\n                onClick={() => setShowEmojiPicker(!showEmojiPicker)}\n              >\n                <Smile size={16} />\n              </Button>\n              \n              <Button \n                variant=\"ghost\" \n                size=\"icon\"\n                className=\"h-8 w-8 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 rounded-full\"\n              >\n                <Paperclip size={16} />\n              </Button>\n            </div>\n          </div>\n          \n          {/* Mesaj gönderme butonu */}\n          <div className=\"ml-2\">\n            <Button\n              size=\"default\"\n              disabled={isLoading || !inputValue.trim()}\n              onClick={handleSendMessage}\n              className={`mobile-friendly-buttons ${\n                isLoading || !inputValue.trim()\n                  ? 'bg-gray-200 dark:bg-gray-700 text-gray-400 dark:text-gray-500 hover:bg-gray-200 hover:text-gray-400'\n                  : 'bg-indigo-600 hover:bg-indigo-700 text-white transition-colors'\n              }`}\n            >\n              {isLoading ? (\n                <div className=\"flex items-center\">\n                  <span className=\"mr-2\">\n                    <div className=\"w-4 h-4 rounded-full border-2 border-t-transparent border-white animate-spin\"></div>\n                  </span>\n                  <span className=\"hidden md:inline\">Düşünüyor</span>\n                </div>\n              ) : (\n                <div className=\"flex items-center\">\n                  <span className=\"md:mr-1\">{isMobile ? '' : 'Gönder'}</span>\n                  <SendHorizonal size={16} className={isMobile ? '' : 'ml-1'} />\n                </div>\n              )}\n            </Button>\n          </div>\n        </div>\n        \n        {/* Bellek durumu */}\n        <div className=\"flex justify-between mt-2 text-xs text-gray-500 dark:text-gray-400 px-2\">\n          <div className=\"flex items-center gap-1\">\n            <Sparkles size={12} />\n            <span className=\"hidden md:inline\">\n              Sistem zeka düzeyi: {Math.min(100, (shortTermCount + longTermCount * 2) / 10)}%\n            </span>\n            <span className=\"md:hidden\">\n              Zeka: {Math.min(100, (shortTermCount + longTermCount * 2) / 10)}%\n            </span>\n          </div>\n          \n          <div className=\"hidden md:block text-right\">\n            <span className=\"text-xs\">\n              Bu sohbet geçmişiniz özel olarak yerel cihazınızda saklanır\n            </span>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default ChatInterface;\n","size_bytes":14436},"attached_assets/CorrectAnswerModal.tsx":{"content":"import React, { useState } from 'react';\nimport { X } from 'lucide-react';\n\ninterface CorrectAnswerModalProps {\n  isDarkMode: boolean;\n  onSubmit: (answer: string) => void;\n  onClose: () => void;\n}\n\nconst CorrectAnswerModal: React.FC<CorrectAnswerModalProps> = ({\n  isDarkMode,\n  onSubmit,\n  onClose\n}) => {\n  const [answer, setAnswer] = useState('');\n  const [error, setError] = useState('');\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    \n    if (!answer.trim()) {\n      setError('Lütfen doğru yanıtı girin.');\n      return;\n    }\n    \n    onSubmit(answer);\n  };\n\n  return (\n    <div className=\"fixed inset-0 bg-black/50 flex items-center justify-center p-2 md:p-4 z-50 overflow-y-auto\">\n      <div \n        className={`w-full max-w-xl max-h-[90vh] overflow-y-auto rounded-xl shadow-lg ${\n          isDarkMode ? 'bg-gray-800 text-gray-200' : 'bg-white text-gray-800'\n        }`}\n      >\n        <div \n          className={`flex items-center justify-between p-4 border-b ${\n            isDarkMode ? 'border-gray-700' : 'border-gray-200'\n          }`}\n        >\n          <h3 className=\"text-lg font-semibold\">Doğru Yanıtı Öğret</h3>\n          <button\n            onClick={onClose}\n            className={`p-1 rounded-full transition-colors ${\n              isDarkMode\n                ? 'hover:bg-gray-700 text-gray-400 hover:text-gray-200'\n                : 'hover:bg-gray-100 text-gray-600 hover:text-gray-800'\n            }`}\n            aria-label=\"Kapat\"\n          >\n            <X size={20} />\n          </button>\n        </div>\n\n        <form onSubmit={handleSubmit}>\n          <div className=\"p-4\">\n            <p className={`text-sm mb-4 ${isDarkMode ? 'text-gray-300' : 'text-gray-600'}`}>\n              Yapay zeka sistemi yanlış bir yanıt verdiyse, doğru yanıtı girerek\n              sistemin kendini düzeltmesine yardımcı olabilirsiniz.\n            </p>\n            \n            {error && (\n              <div className=\"mb-4 p-3 bg-red-100 dark:bg-red-900/30 text-red-800 dark:text-red-300 rounded-lg text-sm\">\n                {error}\n              </div>\n            )}\n            \n            <div>\n              <label \n                htmlFor=\"correctAnswer\" \n                className={`block mb-2 text-sm font-medium ${\n                  isDarkMode ? 'text-gray-300' : 'text-gray-700'\n                }`}\n              >\n                Doğru yanıt nedir?\n              </label>\n              <textarea\n                id=\"correctAnswer\"\n                value={answer}\n                onChange={(e) => {\n                  setAnswer(e.target.value);\n                  if (error) setError('');\n                }}\n                placeholder=\"Örn: İstanbul, Türkiye'nin en kalabalık şehridir ve ekonomik, kültürel ve tarihi açıdan büyük öneme sahiptir...\"\n                rows={5}\n                className={`w-full p-3 rounded-lg text-sm border ${\n                  isDarkMode\n                    ? 'bg-gray-700 border-gray-600 text-gray-200 placeholder-gray-400'\n                    : 'bg-white border-gray-300 text-gray-800 placeholder-gray-400'\n                } focus:outline-none focus:ring-2 ${\n                  isDarkMode ? 'focus:ring-blue-500/50' : 'focus:ring-blue-500/70'\n                } focus:border-blue-500`}\n              />\n            </div>\n          </div>\n\n          <div className={`p-4 border-t ${isDarkMode ? 'border-gray-700' : 'border-gray-200'}`}>\n            <div className=\"text-xs text-gray-500 dark:text-gray-400 mb-3\">\n              Not: Verdiğiniz doğru yanıt, gelecekte benzer sorulara daha iyi yanıt vermek için \n              yapay zeka modelinin eğitilmesinde kullanılacaktır.\n            </div>\n            \n            <div className=\"flex justify-end gap-2\">\n              <button\n                type=\"button\"\n                onClick={onClose}\n                className={`px-4 py-2 rounded-lg transition-colors ${\n                  isDarkMode\n                    ? 'bg-gray-700 hover:bg-gray-600 text-gray-300'\n                    : 'bg-gray-100 hover:bg-gray-200 text-gray-700'\n                }`}\n              >\n                İptal\n              </button>\n              <button\n                type=\"submit\"\n                className=\"px-4 py-2 rounded-lg bg-blue-500 hover:bg-blue-600 text-white transition-colors\"\n              >\n                Gönder\n              </button>\n            </div>\n          </div>\n        </form>\n      </div>\n    </div>\n  );\n};\n\nexport default CorrectAnswerModal;\n","size_bytes":4539},"attached_assets/EnhancedMemorySystem.tsx":{"content":"export interface Memory {\n  content: string;\n  timestamp: number;\n  relevance: number;\n  type: 'short-term' | 'long-term';\n  related: string[];\n  context?: string; // İlgili bağlam bilgisi\n  emotionalScore?: number; // Duygusal ağırlık (pozitif veya negatif)\n  connections?: string[]; // Diğer anılarla bağlantılar\n  category?: string; // Anı kategorisi\n  learningCount?: number; // Kaç kez öğrenildi\n}\n\nexport interface MemoryCluster {\n  id: string;\n  topic: string;\n  memories: Memory[];\n  strength: number; // İlişki gücü\n  createdAt: number;\n  lastAccessed: number;\n}\n\nexport class EnhancedMemorySystem {\n  shortTerm: Memory[];\n  longTerm: Memory[];\n  memoryClusters: MemoryCluster[];\n  maxShortTerm: number;\n  maxLongTerm: number;\n  maxClusters: number;\n  forgettingRate: number; // Unutma hızı\n\n  constructor() {\n    this.shortTerm = [];\n    this.longTerm = [];\n    this.memoryClusters = [];\n    this.maxShortTerm = 100;\n    this.maxLongTerm = 1000;\n    this.maxClusters = 50;\n    this.forgettingRate = 0.05; // Her hatırlatmada azaltılır\n  }\n\n  /**\n   * Yeni bellek ekle ve bağlamsal ilişkileri kur\n   */\n  addMemory(content: string, type: 'short-term' | 'long-term' = 'short-term', related: string[] = [], context?: string) {\n    // Kelime vektörlerini oluştur\n    const contentWords = content.toLowerCase().split(/\\s+/);\n    const existingMemoryIds: string[] = [];\n    \n    // Benzer anıları bul\n    const similarMemories = this.findSimilarMemories(content, 3);\n    similarMemories.forEach(memory => {\n      existingMemoryIds.push(memory.content);\n    });\n\n    const memory: Memory = {\n      content,\n      timestamp: Date.now(),\n      relevance: 100, // Başlangıçta en yüksek ilgi\n      type,\n      related,\n      context: context || \"\",\n      emotionalScore: this.calculateEmotionalScore(content),\n      connections: existingMemoryIds,\n      learningCount: 1,\n      category: this.categorizeMemory(content)\n    };\n\n    if (type === 'short-term') {\n      this.shortTerm.push(memory);\n      \n      // Kısa vadeli bellekte çok fazla öğe varsa, en eskisini kaldır veya uzun vadeli belleğe taşı\n      if (this.shortTerm.length > this.maxShortTerm) {\n        this.processShortTermMemories();\n      }\n    } else {\n      this.longTerm.push(memory);\n      \n      // Uzun vadeli bellekte çok fazla öğe varsa, en eskisini kaldır\n      if (this.longTerm.length > this.maxLongTerm) {\n        this.consolidateMemories();\n      }\n    }\n    \n    // Grupları güncelle\n    this.updateMemoryClusters(memory);\n    \n    return memory;\n  }\n\n  /**\n   * Duygusal ağırlık hesaplama (basit)\n   */\n  private calculateEmotionalScore(content: string): number {\n    const positiveWords = ['harika', 'güzel', 'mükemmel', 'iyi', 'sevindim', 'teşekkür', 'mutlu'];\n    const negativeWords = ['kötü', 'üzgün', 'zor', 'problem', 'hata', 'kızgın', 'üzüldüm'];\n    \n    const words = content.toLowerCase().split(/\\s+/);\n    let score = 0;\n    \n    words.forEach(word => {\n      if (positiveWords.some(pw => word.includes(pw))) {\n        score += 10;\n      }\n      if (negativeWords.some(nw => word.includes(nw))) {\n        score -= 10;\n      }\n    });\n    \n    return Math.max(-100, Math.min(100, score));\n  }\n\n  /**\n   * Anının kategorisini belirle\n   */\n  private categorizeMemory(content: string): string {\n    const categories = [\n      { name: 'teknoloji', keywords: ['bilgisayar', 'yazılım', 'uygulama', 'telefon', 'internet'] },\n      { name: 'sağlık', keywords: ['sağlık', 'hastane', 'doktor', 'ilaç', 'tedavi'] },\n      { name: 'eğitim', keywords: ['okul', 'öğrenci', 'öğretmen', 'ders', 'öğrenmek'] },\n      { name: 'günlük', keywords: ['bugün', 'dün', 'yarın', 'şimdi', 'sonra'] },\n      { name: 'duygusal', keywords: ['sevmek', 'üzülmek', 'mutlu', 'kızgın', 'hissetmek'] }\n    ];\n    \n    const contentLower = content.toLowerCase();\n    \n    for (const category of categories) {\n      for (const keyword of category.keywords) {\n        if (contentLower.includes(keyword)) {\n          return category.name;\n        }\n      }\n    }\n    \n    return 'genel';\n  }\n\n  /**\n   * Kısa vadeli belleği işle\n   */\n  private processShortTermMemories() {\n    // İlgi seviyesi düşük ve 24 saatten eski olanları filtrele ve sırala\n    const cutoffTime = Date.now() - (24 * 60 * 60 * 1000); // 24 saat\n    \n    const candidatesForRemoval = this.shortTerm\n      .filter(memory => memory.timestamp < cutoffTime)\n      .sort((a, b) => a.relevance - b.relevance);\n    \n    if (candidatesForRemoval.length > 0) {\n      const memoryToProcess = candidatesForRemoval[0];\n      \n      // Anı önemli ise, uzun vadeli belleğe aktar\n      if (memoryToProcess.relevance > 50 || memoryToProcess.learningCount! > 2) {\n        const updatedMemory = {...memoryToProcess, type: 'long-term'};\n        this.longTerm.push(updatedMemory);\n      }\n      \n      // Kısa vadeli bellekten kaldır\n      const index = this.shortTerm.findIndex(m => m.content === memoryToProcess.content);\n      if (index !== -1) {\n        this.shortTerm.splice(index, 1);\n      }\n    } else {\n      // Eski anı yoksa, en düşük ilgi puanlı anıyı kaldır\n      const leastRelevantIndex = this.shortTerm\n        .map((m, index) => ({ index, relevance: m.relevance }))\n        .sort((a, b) => a.relevance - b.relevance)[0].index;\n      \n      this.shortTerm.splice(leastRelevantIndex, 1);\n    }\n  }\n\n  /**\n   * Uzun vadeli belleği konsolide et\n   */\n  private consolidateMemories() {\n    // İlgisi ve zamanı düşük olanları filtrele ve sırala\n    const oldMemories = this.longTerm\n      .map((memory, index) => ({ memory, index, score: memory.relevance * (1 / (1 + Date.now() - memory.timestamp)) }))\n      .sort((a, b) => a.score - b.score);\n    \n    if (oldMemories.length > 0) {\n      // En düşük puanlı anıyı çıkar\n      this.longTerm.splice(oldMemories[0].index, 1);\n    }\n  }\n\n  /**\n   * Hafıza kümelerini güncelle\n   */\n  private updateMemoryClusters(memory: Memory) {\n    // Kelimelerden bağlamsal kümeyi tahmin et\n    const contentWords = memory.content.toLowerCase().split(/\\s+/);\n    \n    // Tüm kümeleri al ve benzerlik skoru hesapla\n    const clusterScores = this.memoryClusters.map(cluster => {\n      const topicWords = cluster.topic.toLowerCase().split(/\\s+/);\n      let matchScore = 0;\n      \n      contentWords.forEach(word => {\n        if (topicWords.includes(word)) {\n          matchScore += 10;\n        }\n      });\n      \n      return {\n        cluster,\n        score: matchScore\n      };\n    });\n    \n    // En yakın kümeyi bul\n    const bestMatch = clusterScores.sort((a, b) => b.score - a.score)[0];\n    \n    if (bestMatch && bestMatch.score > 20) {\n      // Mevcut bir kümeye ekle\n      bestMatch.cluster.memories.push(memory);\n      bestMatch.cluster.strength += 5;\n      bestMatch.cluster.lastAccessed = Date.now();\n      \n      // Küme çok büyürse, eski ve önemsiz anıları çıkar\n      if (bestMatch.cluster.memories.length > 20) {\n        bestMatch.cluster.memories.sort((a, b) => a.relevance - b.relevance);\n        bestMatch.cluster.memories = bestMatch.cluster.memories.slice(1);\n      }\n    } else {\n      // Yeni bir küme oluştur\n      if (contentWords.length >= 3) {\n        const newClusterId = `cluster_${Date.now()}`;\n        const mainWords = contentWords\n          .filter(word => word.length > 3)\n          .sort(() => Math.random() - 0.5)\n          .slice(0, 3)\n          .join(' ');\n        \n        const newCluster: MemoryCluster = {\n          id: newClusterId,\n          topic: mainWords,\n          memories: [memory],\n          strength: 50,\n          createdAt: Date.now(),\n          lastAccessed: Date.now()\n        };\n        \n        this.memoryClusters.push(newCluster);\n        \n        // Küme limitini aşarsa, en zayıf kümeyi kaldır\n        if (this.memoryClusters.length > this.maxClusters) {\n          this.memoryClusters.sort((a, b) => a.strength - b.strength);\n          this.memoryClusters.shift();\n        }\n      }\n    }\n  }\n\n  /**\n   * Benzer anıları bul\n   */\n  findSimilarMemories(content: string, limit: number = 5): Memory[] {\n    const contentWords = content.toLowerCase().split(/\\s+/).filter(w => w.length > 3);\n    const allMemories = [...this.shortTerm, ...this.longTerm];\n    \n    const scoredMemories = allMemories.map(memory => {\n      const memoryWords = memory.content.toLowerCase().split(/\\s+/).filter(w => w.length > 3);\n      \n      let matchScore = 0;\n      contentWords.forEach(cWord => {\n        memoryWords.forEach(mWord => {\n          if (mWord.includes(cWord) || cWord.includes(mWord)) {\n            matchScore += 5;\n          }\n          if (mWord === cWord) {\n            matchScore += 10;\n          }\n        });\n      });\n      \n      // Bağlantılı anıları kontrol et\n      if (memory.connections && memory.connections.some(conn => content.includes(conn))) {\n        matchScore += 30;\n      }\n      \n      // Kategori eşleşmesi\n      const category = this.categorizeMemory(content);\n      if (memory.category === category) {\n        matchScore += 15;\n      }\n      \n      // Son erişim zamanına göre recency bonus\n      const recencyScore = Math.max(0, 100 - (Date.now() - memory.timestamp) / (24 * 60 * 60 * 1000));\n      \n      const totalScore = (matchScore * 0.6) + (recencyScore * 0.2) + (memory.relevance * 0.2);\n      \n      return { memory, score: totalScore };\n    });\n    \n    return scoredMemories\n      .filter(item => item.score > 10)\n      .sort((a, b) => b.score - a.score)\n      .slice(0, limit)\n      .map(item => item.memory);\n  }\n\n  /**\n   * Verilen sorguyla ilgili anıları getir ve öğrenme sağla\n   */\n  getContextualMemories(query: string): Memory[] {\n    const relevanceThreshold = 20; // Minimum ilgi eşiği\n    \n    // İlgili kümeleri bul\n    const queryWords = query.toLowerCase().split(/\\s+/);\n    const relatedClusters: MemoryCluster[] = [];\n    \n    this.memoryClusters.forEach(cluster => {\n      const topicWords = cluster.topic.toLowerCase().split(/\\s+/);\n      let matchCount = 0;\n      \n      queryWords.forEach(word => {\n        if (topicWords.some(tw => tw.includes(word) || word.includes(tw))) {\n          matchCount++;\n        }\n      });\n      \n      if (matchCount > 0) {\n        relatedClusters.push(cluster);\n        // Erişimi güncelle\n        cluster.lastAccessed = Date.now();\n        cluster.strength += 1;\n      }\n    });\n    \n    // İlgili kümelerden anıları getir\n    const clusterMemories = relatedClusters.flatMap(cluster => cluster.memories);\n    \n    // Tüm belleklerden ilgililik skorlarını hesapla\n    const allMemories = [...new Set([...clusterMemories, ...this.shortTerm, ...this.longTerm])];\n    const scoredMemories = allMemories.map(memory => {\n      // Gelişmiş benzerlik hesaplama\n      const memoryWords = memory.content.toLowerCase().split(/\\s+/);\n      \n      let matchScore = 0;\n      for (const qWord of queryWords) {\n        for (const mWord of memoryWords) {\n          if (mWord.includes(qWord) || qWord.includes(mWord)) {\n            matchScore += 10;\n          }\n          if (mWord === qWord) {\n            matchScore += 15;\n          }\n        }\n      }\n      \n      // Kategori eşleşmesi\n      const queryCategory = this.categorizeMemory(query);\n      if (memory.category === queryCategory) {\n        matchScore += 20;\n      }\n      \n      // Bağlantılı anılarda eşleşme\n      if (memory.connections && memory.connections.some(c => queryWords.some(qw => c.includes(qw)))) {\n        matchScore += 25;\n      }\n      \n      // İlgililik hesaplaması\n      const matchFactor = matchScore;\n      const recencyFactor = Math.max(0, 100 - (Date.now() - memory.timestamp) / (24 * 60 * 60 * 1000));\n      const relevanceFactor = memory.relevance;\n      const emotionalFactor = memory.emotionalScore ? Math.abs(memory.emotionalScore) : 0;\n      const learningFactor = memory.learningCount ? memory.learningCount * 5 : 0;\n      \n      const totalScore = (matchFactor * 0.4) + (recencyFactor * 0.1) + \n                         (relevanceFactor * 0.2) + (emotionalFactor * 0.1) + \n                         (learningFactor * 0.2);\n      \n      return {\n        memory,\n        score: totalScore\n      };\n    });\n    \n    // Skoru yüksek olanları seç\n    const selectedMemories = scoredMemories\n      .filter(item => item.score >= relevanceThreshold)\n      .sort((a, b) => b.score - a.score)\n      .slice(0, 10)\n      .map(item => item.memory);\n    \n    // Seçilen anıların önemini artır ve öğrenme sayısını artır\n    selectedMemories.forEach(memory => {\n      this.reinforceMemory(memory.content, 5);\n      if (memory.learningCount !== undefined) {\n        memory.learningCount += 1;\n      } else {\n        memory.learningCount = 1;\n      }\n    });\n    \n    return selectedMemories;\n  }\n\n  /**\n   * Anının önemini güçlendir veya azalt ve bağlantıları güncelle\n   */\n  reinforceMemory(content: string, adjustment: number) {\n    // Kısa ve uzun vadeli bellekte anıları bul ve güncelle\n    const updateMemory = (memory: Memory) => {\n      if (memory.content.includes(content) || content.includes(memory.content)) {\n        memory.relevance = Math.max(0, Math.min(100, memory.relevance + adjustment));\n        \n        // Bağlantıları güncelle\n        if (!memory.connections) memory.connections = [];\n        if (!memory.connections.includes(content) && memory.content !== content) {\n          memory.connections.push(content);\n        }\n        \n        return true;\n      }\n      return false;\n    };\n    \n    let found = false;\n    \n    // Kısa vadeli bellekte ara\n    for (const memory of this.shortTerm) {\n      if (updateMemory(memory)) {\n        found = true;\n      }\n    }\n    \n    // Uzun vadeli bellekte ara\n    for (const memory of this.longTerm) {\n      if (updateMemory(memory)) {\n        found = true;\n      }\n    }\n    \n    // Kümeler içinde de güncelle\n    this.memoryClusters.forEach(cluster => {\n      let clusterUpdated = false;\n      \n      cluster.memories.forEach(memory => {\n        if (updateMemory(memory)) {\n          found = true;\n          clusterUpdated = true;\n        }\n      });\n      \n      if (clusterUpdated) {\n        cluster.strength += 2;\n        cluster.lastAccessed = Date.now();\n      }\n    });\n    \n    // Zaman geçtikçe anıların ilgililik puanını azalt (unutma mekanizması)\n    this.applyForgetting();\n    \n    return found;\n  }\n\n  /**\n   * Unutma mekanizması - zamanla ilgililik düşürme\n   */\n  private applyForgetting() {\n    const now = Date.now();\n    const oneDay = 24 * 60 * 60 * 1000;\n    \n    // Kısa vadeli bellek hızlı unutma\n    this.shortTerm.forEach(memory => {\n      const daysPassed = (now - memory.timestamp) / oneDay;\n      if (daysPassed > 1) {\n        memory.relevance = Math.max(0, memory.relevance - (this.forgettingRate * 2 * daysPassed));\n      }\n    });\n    \n    // Uzun vadeli bellek yavaş unutma\n    this.longTerm.forEach(memory => {\n      const daysPassed = (now - memory.timestamp) / oneDay;\n      if (daysPassed > 7) { // Bir haftadan daha eski\n        // Öğrenme sayısı yüksek olanlar daha yavaş unutulur\n        const forgettingFactor = memory.learningCount ? \n          this.forgettingRate / Math.max(1, memory.learningCount) : \n          this.forgettingRate;\n        \n        memory.relevance = Math.max(0, memory.relevance - (forgettingFactor * daysPassed / 7));\n      }\n    });\n  }\n\n  /**\n   * Kısa vadeli bellekten uzun vadeli belleğe transfer (konsolidasyon)\n   */\n  consolidateShortTermMemories() {\n    const now = Date.now();\n    const oneDayAgo = now - (24 * 60 * 60 * 1000);\n    \n    // En az bir gün önce kaydedilen ve ilgisi yüksek olan anıları seç\n    const memories = this.shortTerm.filter(memory => \n      memory.timestamp < oneDayAgo && \n      memory.relevance > 60\n    );\n    \n    for (const memory of memories) {\n      // Uzun vadeli belleğe kopyala\n      const updatedMemory = {\n        ...memory,\n        type: 'long-term' as 'short-term' | 'long-term',\n        relevance: Math.min(100, memory.relevance + 10) // İlgililik artar\n      };\n      \n      this.longTerm.push(updatedMemory);\n      \n      // Kısa vadeli bellekten kaldır\n      const index = this.shortTerm.findIndex(m => m.content === memory.content);\n      if (index !== -1) {\n        this.shortTerm.splice(index, 1);\n      }\n    }\n    \n    return memories.length;\n  }\n\n  /**\n   * Günlük hatırlatmaları getir ve önemli anıları öner\n   */\n  getDailyReminders(): string[] {\n    const reminders: string[] = [];\n    \n    // Son 7 gün içinde erişilmeyen uzun vadeli bellekten önemli anıları seç\n    const now = Date.now();\n    const oneWeekAgo = now - (7 * 24 * 60 * 60 * 1000);\n    const oneMonthAgo = now - (30 * 24 * 60 * 60 * 1000);\n    \n    // 1. Yüksek ilgili ve 1 haftadır görülmeyen anılar\n    const importantMemories = this.longTerm\n      .filter(memory => \n        memory.relevance > 70 && \n        memory.timestamp > oneMonthAgo && \n        memory.timestamp < oneWeekAgo\n      )\n      .sort((a, b) => b.relevance - a.relevance)\n      .slice(0, 3);\n    \n    // 2. Önceden çok öğrenilmiş ama uzun süredir tekrarlanmayan anılar\n    const wellLearnedMemories = this.longTerm\n      .filter(memory => \n        memory.learningCount && memory.learningCount > 3 && \n        memory.timestamp < oneWeekAgo\n      )\n      .sort((a, b) => (b.learningCount || 0) - (a.learningCount || 0))\n      .slice(0, 2);\n    \n    // 3. Duygusal ağırlığı yüksek anılar\n    const emotionalMemories = this.longTerm\n      .filter(memory => \n        memory.emotionalScore && Math.abs(memory.emotionalScore) > 50 && \n        memory.timestamp < oneWeekAgo\n      )\n      .sort((a, b) => (Math.abs(b.emotionalScore || 0) - Math.abs(a.emotionalScore || 0)))\n      .slice(0, 2);\n    \n    // Tüm anıları birleştir ve karıştır\n    const allReminders = [...importantMemories, ...wellLearnedMemories, ...emotionalMemories];\n    const uniqueReminders = Array.from(new Set(allReminders.map(m => m.content)))\n      .map(content => allReminders.find(m => m.content === content)!)\n      .sort(() => Math.random() - 0.5)\n      .slice(0, 5);\n    \n    // Hatırlatma mesajları oluştur\n    uniqueReminders.forEach(memory => {\n      // Tarih formatını oluştur\n      const date = new Date(memory.timestamp);\n      const formattedDate = date.toLocaleDateString('tr-TR', {\n        year: 'numeric',\n        month: 'long',\n        day: 'numeric'\n      });\n      \n      let reminderText = `${formattedDate} tarihinde bahsettiğiniz \"${memory.content.substring(0, 50)}${memory.content.length > 50 ? '...' : ''}\" konusunu hatırlatmak istedim.`;\n      \n      // Eğer bağlam bilgisi varsa ekle\n      if (memory.context) {\n        reminderText += ` Konu hakkında \"${memory.context}\" bağlamını konuşmuştuk.`;\n      }\n      \n      // Eğer duygusal puanı yüksekse ekle\n      if (memory.emotionalScore && Math.abs(memory.emotionalScore) > 50) {\n        const emotion = memory.emotionalScore > 0 ? 'pozitif' : 'negatif';\n        reminderText += ` Bu konu sizin için ${emotion} duygular içeriyordu.`;\n      }\n      \n      reminders.push(reminderText);\n    });\n    \n    return reminders;\n  }\n  \n  /**\n   * Bellek sistemini JSON formatında dışa aktar\n   */\n  exportMemories() {\n    return {\n      shortTerm: this.shortTerm,\n      longTerm: this.longTerm,\n      memoryClusters: this.memoryClusters\n    };\n  }\n  \n  /**\n   * Bellek verilerini içe aktar\n   */\n  importMemories(data: {\n    shortTerm: Memory[],\n    longTerm: Memory[],\n    memoryClusters: MemoryCluster[]\n  }) {\n    if (data.shortTerm) this.shortTerm = data.shortTerm;\n    if (data.longTerm) this.longTerm = data.longTerm;\n    if (data.memoryClusters) this.memoryClusters = data.memoryClusters;\n  }\n}\n\n/**\n * Akıllı prompt oluşturma\n */\nexport const generateSmartPrompt = ({ \n  userGoal,\n  conversationHistory,\n  relevantMemories,\n  currentQuery\n}: { \n  userGoal?: string,\n  conversationHistory?: { content: string, isUser: boolean }[],\n  relevantMemories: Memory[],\n  currentQuery: string\n}) => {\n  let prompt = `Kullanıcının Sorusu: ${currentQuery}\\n\\n`;\n  \n  // Kullanıcı amacı varsa ekle\n  if (userGoal) {\n    prompt += `Kullanıcının Amacı: ${userGoal}\\n\\n`;\n  }\n  \n  // Konuşma geçmişi varsa son birkaç mesajı ekle\n  if (conversationHistory && conversationHistory.length > 0) {\n    prompt += \"Son Konuşma:\\n\";\n    \n    const recentMessages = conversationHistory.slice(-3);\n    recentMessages.forEach((msg, index) => {\n      prompt += `${msg.isUser ? 'Kullanıcı' : 'Asistan'}: ${msg.content}\\n`;\n    });\n    \n    prompt += \"\\n\";\n  }\n  \n  // İlgili anılar varsa ekle\n  if (relevantMemories.length > 0) {\n    prompt += \"İlgili Bilgiler:\\n\";\n    \n    relevantMemories.slice(0, 5).forEach((memory, index) => {\n      prompt += `${index + 1}. ${memory.content}\\n`;\n      \n      // Eğer bağlam varsa ekle\n      if (memory.context) {\n        prompt += `   Bağlam: ${memory.context}\\n`;\n      }\n      \n      // Eğer kategorisi varsa ekle\n      if (memory.category && memory.category !== 'genel') {\n        prompt += `   Kategori: ${memory.category}\\n`;\n      }\n    });\n    \n    // İlgili kümeleri ekle\n    const categories = Array.from(new Set(relevantMemories.map(m => m.category).filter(Boolean)));\n    if (categories.length > 0) {\n      prompt += \"\\nİlgili Kategoriler: \" + categories.join(', ') + \"\\n\";\n    }\n    \n    prompt += \"\\nYukarıdaki bilgileri ve bağlamı dikkate alarak Türkçe dilinde yanıt ver. Eğer yanıtın bağlamla ilgili olduğunu düşünüyorsan, önceki bilgileri kullan ama direkt olarak kullanıcıya 'Daha önce X hakkında konuşmuştuk' gibi ifadeler kullanma. Bilgiyi doğal bir şekilde cevabına dahil et:\\n\";\n  } else {\n    prompt += \"Yanıtını Türkçe olarak ver ve kullanıcıyla saygılı, dostça ve yardımcı bir şekilde iletişim kur:\\n\";\n  }\n  \n  return prompt;\n};\n","size_bytes":21974},"attached_assets/NeuralNetworkUtils.tsx":{"content":"// Sinir ağı ile ilgili temel parametreler\nexport const INITIAL_GRID_ROWS = 12;\nexport const INITIAL_GRID_COLS = 24;\nexport const INITIAL_NETWORK_LAYERS = 4;\nexport const MIN_RELATION_SCORE = 25;\nexport const LEARNING_RATE = 0.18;\nexport const MAX_NETWORK_SIZE = 60;\n\n// Gelişmiş parametreler\nexport const ACTIVATION_DECAY_RATE = 0.05;  // Aktivasyon azalma hızı\nexport const CONNECTION_THRESHOLD = 0.25;   // Bağlantı oluşturma eşiği\nexport const MAX_CONNECTIONS_PER_NODE = 12; // Bir düğümün maksimum bağlantı sayısı\nexport const REINFORCEMENT_RATE = 0.12;     // Pekiştirme öğrenme hızı\nexport const FORGET_RATE = 0.08;            // Unutma hızı\nexport const NEUROPLASTICITY = 0.15;        // Ağın adapte olma yeteneği\n\n/**\n * Ağ düğümü arayüzü (geliştilmiş)\n */\nexport interface NetworkNode {\n  id: string;                // Benzersiz düğüm kimliği\n  word: string;              // Düğümün temsil ettiği kelime\n  activation: number;        // Aktivasyon seviyesi (0-1)\n  count: number;             // Kullanım sayısı\n  connections: string[];     // Bağlantılar (diğer düğüm kimlikleri)\n  dependency: number;        // Bağımlılık değeri (0-100)\n  association: number;       // İlişki değeri (0-100)\n  frequency: number;         // Kullanım sıklığı\n  order: number;             // Sıra değeri\n  feedback: number;          // Kullanıcı geri bildirimi (-100 ile 100 arası)\n  depth: number;             // Ağ derinliği\n  parentWords: string[];     // Üst düğümler\n  \n  // Gelişmiş özellikler\n  lastActivation: number;    // Son aktivasyon zamanı\n  activationHistory: number[]; // Aktivasyon geçmişi\n  semanticVector?: number[]; // Anlamsal vektör (embedding)\n  category?: string;         // Kategori (ör: isim, fiil, sıfat)\n  sentiment?: number;        // Duygu değeri (-1 ile 1 arası)\n  importance?: number;       // Önem değeri (0-100)\n  connectionStrengths?: { [nodeId: string]: number }; // Bağlantı güç değerleri\n  createdAt: number;         // Oluşturulma zamanı\n  modifiedAt: number;        // Son değiştirilme zamanı\n}\n\n/**\n * İlişki arayüzü (geliştilmiş)\n */\nexport interface Relation {\n  id: string;                // Benzersiz ilişki kimliği\n  userWord: string;          // Kullanıcı kelimesi\n  systemWord: string;        // Sistem kelimesi\n  dependency: number;        // Bağımlılık değeri (0-100)\n  association: number;       // İlişki değeri (0-100) \n  frequency: number;         // Sıklık değeri\n  order: number;             // Sıra değeri\n  feedback: number;          // Kullanıcı geri bildirimi\n  isReversed?: boolean;      // Ters ilişki mi?\n  ai_generated?: boolean;    // Yapay zeka tarafından oluşturuldu mu?\n  \n  // Gelişmiş özellikler\n  strength: number;          // İlişki gücü (0-100)\n  context?: string[];        // İlişki bağlamı\n  learningCount: number;     // Öğrenme sayısı\n  lastUsed: number;          // Son kullanım zamanı\n  creationTime: number;      // Oluşturulma zamanı\n  relationType?: 'semantic' | 'temporal' | 'causal' | 'hierarchical'; // İlişki tipi\n  bidirectional: boolean;    // İki yönlü mü?\n  confidence: number;        // Güven değeri (0-1)\n}\n\n/**\n * Eğitim çifti arayüzü\n */\nexport interface TrainingPair {\n  id: string;                // Benzersiz eğitim kimliği\n  input: string;             // Girdi metni\n  output: string;            // Çıktı metni\n  timestamp: number;         // Tarih damgası\n  score?: number;            // Kalite puanı (0-100)\n  difficulty?: number;       // Zorluk derecesi (0-100)\n  category?: string;         // Kategori\n  tags?: string[];           // Etiketler\n  usageCount: number;        // Kullanım sayısı\n}\n\n/**\n * Aktivasyon yayılımı sonucu\n */\nexport interface ActivationResult {\n  activationPath: {\n    layer: number;\n    row: number;\n    col: number;\n    type: 'user' | 'system';\n    value: number;\n    word: string;\n  }[];\n  activatedNodes: NetworkNode[];\n  activatedRelations: Relation[];\n  primaryConcepts: string[];\n  responseScore: number;\n  confidence: number;\n  processingTime: number;\n}\n\n/**\n * Boş bir ızgara oluştur\n */\nexport const createEmptyGrid = (rows: number, cols: number): (NetworkNode | null)[][] => {\n  return Array(rows)\n    .fill(null)\n    .map(() => Array(cols).fill(null));\n};\n\n/**\n * Kelime için pozisyon bul\n */\nexport const findPositionForWord = (\n  grid: (NetworkNode | null)[][],\n  word: string,\n  rows?: number,\n  cols?: number\n): { row: number; col: number } => {\n  const gridRows = rows || grid.length;\n  const gridCols = cols || (grid[0]?.length || 0);\n  \n  if (gridRows === 0 || gridCols === 0) {\n    return { row: 0, col: 0 };\n  }\n  \n  // Önce bu kelimenin zaten ağda olup olmadığını kontrol et\n  for (let r = 0; r < gridRows; r++) {\n    for (let c = 0; c < gridCols; c++) {\n      if (grid[r] && grid[r][c] && grid[r][c]!.word === word.toLowerCase()) {\n        return { row: r, col: c };\n      }\n    }\n  }\n\n  // Kelime ağda yoksa, semantik yakınlığa göre pozisyon bul\n  // Bu ileride bir vektör benzerliğine dönüştürülebilir\n  const wordLength = word.length;\n  const preferredRow = Math.min(gridRows - 1, Math.floor((wordLength % gridRows) / 2));\n  \n  // Tercih edilen satırda boş pozisyon ara\n  for (let c = 0; c < gridCols; c++) {\n    if (!grid[preferredRow][c]) {\n      return { row: preferredRow, col: c };\n    }\n  }\n\n  // Boş bir konum bul\n  for (let r = 0; r < gridRows; r++) {\n    for (let c = 0; c < gridCols; c++) {\n      if (!grid[r][c]) {\n        return { row: r, col: c };\n      }\n    }\n  }\n\n  // Eğer boş yer kalmadıysa, en az önemli düğümü değiştir\n  let minImportance = Infinity;\n  let replacePosition = { row: 0, col: 0 };\n  \n  for (let r = 0; r < gridRows; r++) {\n    for (let c = 0; c < gridCols; c++) {\n      const node = grid[r][c];\n      if (node) {\n        const nodeImportance = node.importance || (node.frequency * node.activation);\n        if (nodeImportance < minImportance) {\n          minImportance = nodeImportance;\n          replacePosition = { row: r, col: c };\n        }\n      }\n    }\n  }\n  \n  return replacePosition;\n};\n\n/**\n * Benzersiz kimlik oluştur\n */\nexport const uuid = (): string => {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    const r = (Math.random() * 16) | 0;\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n};\n\n/**\n * Kelimeyi ağa ekle (geliştirilmiş)\n */\nexport const addWordToNetwork = (\n  network: (NetworkNode | null)[][][],\n  word: string,\n  layer: number,\n  row: number,\n  col: number,\n  previousNetwork?: (NetworkNode | null)[][][],\n  options?: {\n    importance?: number;\n    category?: string;\n    sentiment?: number;\n    semanticVector?: number[];\n    initialActivation?: number;\n  }\n): (NetworkNode | null)[][][] => {\n  if (!network[layer] || !network[layer][row]) {\n    // Eğer gerekli katman veya satır yoksa, oluştur\n    if (!network[layer]) {\n      network[layer] = createEmptyGrid(INITIAL_GRID_ROWS, INITIAL_GRID_COLS);\n    }\n    if (!network[layer][row]) {\n      network[layer][row] = Array(INITIAL_GRID_COLS).fill(null);\n    }\n  }\n\n  const result = JSON.parse(JSON.stringify(network)) as (NetworkNode | null)[][][];\n  const grid = result[layer];\n  const now = Date.now();\n  const normalizedWord = word.toLowerCase().trim();\n  \n  // Eğer bu konumda zaten bir düğüm varsa, onu güncelle\n  if (grid[row][col]) {\n    if (grid[row][col]!.word === normalizedWord) {\n      const node = grid[row][col]!;\n      // Düğüm özelliklerini güncelle\n      node.count += 1;\n      node.frequency += 1;\n      node.activation = Math.min(1.0, node.activation + 0.1);\n      node.modifiedAt = now;\n      \n      // Aktivasyon geçmişini güncelle\n      if (!node.activationHistory) {\n        node.activationHistory = [node.activation];\n      } else {\n        node.activationHistory.push(node.activation);\n        // Geçmişi sadece son 10 aktivasyonu tut\n        if (node.activationHistory.length > 10) {\n          node.activationHistory = node.activationHistory.slice(-10);\n        }\n      }\n      \n      // Önem değerini güncelle\n      if (node.importance !== undefined) {\n        node.importance = Math.min(100, node.importance + 2);\n      } else {\n        node.importance = 50;\n      }\n      \n      // Zaman değerlerini güncelle\n      node.lastActivation = now;\n      \n      return result;\n    } else {\n      // Farklı bir kelime varsa, yeni bir konum bul\n      const newPosition = findPositionForWord(grid, normalizedWord);\n      return addWordToNetwork(result, normalizedWord, layer, newPosition.row, newPosition.col, previousNetwork, options);\n    }\n  }\n  \n  // Ebeveyn kelimeleri bul (önceki katmanlar)\n  let parentWords: string[] = [];\n  if (previousNetwork && layer > 0) {\n    // Önceki katmanlardan en aktif düğümleri bul\n    for (let prevLayer = Math.max(0, layer - 2); prevLayer < layer; prevLayer++) {\n      if (previousNetwork[prevLayer]) {\n        const previousLayerNodes: NetworkNode[] = [];\n        \n        // Tüm aktif düğümleri topla\n        for (let r = 0; r < previousNetwork[prevLayer].length; r++) {\n          for (let c = 0; c < previousNetwork[prevLayer][r].length; c++) {\n            const node = previousNetwork[prevLayer][r][c];\n            if (node && node.activation > 0.3) {\n              previousLayerNodes.push(node);\n            }\n          }\n        }\n        \n        // Aktivasyona göre sırala ve en aktif olanları al\n        previousLayerNodes.sort((a, b) => b.activation - a.activation);\n        const topNodes = previousLayerNodes.slice(0, 3);\n        parentWords = [...parentWords, ...topNodes.map(n => n.word)];\n      }\n    }\n    \n    // En çok 5 ebeveyn kelime seç\n    parentWords = [...new Set(parentWords)].slice(0, 5);\n  }\n  \n  // Kelime kategorisini tespit et (isim, fiil, sıfat vb.)\n  const category = options?.category || categorizeWord(normalizedWord);\n\n  // Duygu değerini tespit et\n  const sentiment = options?.sentiment || calculateSentiment(normalizedWord);\n  \n  // Anlamsal vektör oluştur (mevcut değilse)\n  const semanticVector = options?.semanticVector || generateSimpleSemanticVector(normalizedWord);\n  \n  // Yeni düğüm benzersiz kimliği\n  const nodeId = uuid();\n  \n  // Yeni düğümü oluştur\n  const newNode: NetworkNode = {\n    id: nodeId,\n    word: normalizedWord,\n    activation: options?.initialActivation || 0.8,\n    count: 1,\n    connections: [],\n    dependency: 50,\n    association: 50,\n    frequency: 1,\n    order: layer,\n    feedback: 0,\n    depth: layer,\n    parentWords,\n    \n    // Gelişmiş özellikler\n    lastActivation: now,\n    activationHistory: [options?.initialActivation || 0.8],\n    semanticVector,\n    category,\n    sentiment,\n    importance: options?.importance || 50,\n    connectionStrengths: {},\n    createdAt: now,\n    modifiedAt: now\n  };\n  \n  grid[row][col] = newNode;\n  \n  // Bağlantıları oluştur (aynı katmandaki ve bir önceki katmandaki düğümlerle)\n  const connectionTargets: NetworkNode[] = [];\n  \n  // Aynı katmandaki düğümleri topla\n  for (let r = 0; r < grid.length; r++) {\n    for (let c = 0; c < grid[r].length; c++) {\n      if (grid[r][c] && (r !== row || c !== col)) {\n        connectionTargets.push(grid[r][c]!);\n      }\n    }\n  }\n  \n  // Önceki katmandaki düğümleri topla\n  if (result[layer - 1]) {\n    const prevLayer = result[layer - 1];\n    for (let r = 0; r < prevLayer.length; r++) {\n      for (let c = 0; c < prevLayer[r].length; c++) {\n        if (prevLayer[r][c]) {\n          connectionTargets.push(prevLayer[r][c]!);\n        }\n      }\n    }\n  }\n  \n  // Bağlantı oluştur (semantik benzerlik ve rastgelelik kullanarak)\n  const maxConnectionCount = Math.min(MAX_CONNECTIONS_PER_NODE, connectionTargets.length);\n  const potentialConnections = connectionTargets\n    .map(target => {\n      // Semantik benzerlik hesapla\n      let similarity = 0;\n      if (semanticVector && target.semanticVector) {\n        similarity = calculateCosineSimilarity(semanticVector, target.semanticVector);\n      }\n      \n      // Yakın kategorideki düğümlere ek puan\n      if (category && target.category && category === target.category) {\n        similarity += 0.2;\n      }\n      \n      // Ebeveyn kelimelere ek puan\n      if (parentWords.includes(target.word)) {\n        similarity += 0.3;\n      }\n      \n      // Rastgele faktör ekle (keşif için)\n      const randomFactor = Math.random() * 0.2;\n      \n      return {\n        node: target,\n        score: similarity + randomFactor\n      };\n    })\n    .filter(conn => conn.score > CONNECTION_THRESHOLD)\n    .sort((a, b) => b.score - a.score)\n    .slice(0, maxConnectionCount);\n  \n  // Bağlantıları ekle\n  potentialConnections.forEach(conn => {\n    const targetNode = conn.node;\n    \n    // Düğümler arası bağlantı kur\n    if (!newNode.connections.includes(targetNode.id)) {\n      newNode.connections.push(targetNode.id);\n      newNode.connectionStrengths![targetNode.id] = conn.score;\n    }\n    \n    // Karşılıklı bağlantı kur (düşük olasılıkla)\n    if (Math.random() < 0.7) {\n      if (!targetNode.connections.includes(nodeId)) {\n        const targetNodeInGrid = findNodeInNetwork(result, targetNode.id);\n        if (targetNodeInGrid) {\n          targetNodeInGrid.connections.push(nodeId);\n          if (!targetNodeInGrid.connectionStrengths) {\n            targetNodeInGrid.connectionStrengths = {};\n          }\n          targetNodeInGrid.connectionStrengths[nodeId] = conn.score * 0.8; // Biraz daha zayıf geri bağlantı\n        }\n      }\n    }\n  });\n  \n  return result;\n};\n\n/**\n * Ağda düğüm bul\n */\nfunction findNodeInNetwork(network: (NetworkNode | null)[][][], nodeId: string): NetworkNode | null {\n  for (let layer = 0; layer < network.length; layer++) {\n    for (let row = 0; row < network[layer].length; row++) {\n      for (let col = 0; col < network[layer][row].length; col++) {\n        const node = network[layer][row][col];\n        if (node && node.id === nodeId) {\n          return node;\n        }\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Kosinüs benzerliği hesapla\n */\nfunction calculateCosineSimilarity(vec1: number[], vec2: number[]): number {\n  if (vec1.length !== vec2.length) return 0;\n  \n  let dotProduct = 0;\n  let mag1 = 0;\n  let mag2 = 0;\n  \n  for (let i = 0; i < vec1.length; i++) {\n    dotProduct += vec1[i] * vec2[i];\n    mag1 += vec1[i] * vec1[i];\n    mag2 += vec2[i] * vec2[i];\n  }\n  \n  mag1 = Math.sqrt(mag1);\n  mag2 = Math.sqrt(mag2);\n  \n  if (mag1 === 0 || mag2 === 0) return 0;\n  \n  return dotProduct / (mag1 * mag2);\n}\n\n/**\n * Basit anlamsal vektör oluştur\n */\nfunction generateSimpleSemanticVector(word: string): number[] {\n  // Bu basit bir temsil - gerçek bir uygulamada word embeddings kullanılabilir\n  const vector = Array(16).fill(0);\n  \n  // Kelimenin her karakteri için hash değeri\n  for (let i = 0; i < word.length; i++) {\n    const charCode = word.charCodeAt(i);\n    const position = charCode % 16;\n    vector[position] += charCode / 50;\n  }\n  \n  // Kelimenin uzunluğu\n  const lengthIndex = word.length % 16;\n  vector[lengthIndex] += word.length / 3;\n  \n  // Sesli/sessiz harf oranı\n  const vowels = word.match(/[aeıioöuü]/gi)?.length || 0;\n  const vowelIndex = (vowels * 5) % 16;\n  vector[vowelIndex] += vowels;\n  \n  // Normalleştir\n  const magnitude = Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));\n  if (magnitude > 0) {\n    for (let i = 0; i < vector.length; i++) {\n      vector[i] /= magnitude;\n    }\n  }\n  \n  return vector;\n}\n\n/**\n * Kelimeyi kategorize et\n */\nfunction categorizeWord(word: string): string {\n  // Basit bir kategorilendirme (gerçekte NLP kullanılabilir)\n  const noun = ['ev', 'bilgisayar', 'kitap', 'masa', 'araba', 'insan', 'gün', 'su', 'zaman'];\n  const verb = ['git', 'gel', 'yap', 'ol', 'başla', 'bitir', 'düşün', 'söyle', 'anla'];\n  const adjective = ['güzel', 'büyük', 'hızlı', 'iyi', 'kötü', 'yavaş', 'yeni', 'eski', 'mutlu'];\n  const adverb = ['hızlıca', 'yavaşça', 'iyi', 'kötü', 'çok', 'az', 'şimdi', 'sonra', 'önce'];\n  \n  if (noun.some(n => word.includes(n))) return 'noun';\n  if (verb.some(v => word.includes(v))) return 'verb';\n  if (adjective.some(a => word.includes(a))) return 'adjective';\n  if (adverb.some(a => word.includes(a))) return 'adverb';\n  \n  // Türkçe fiil sonekleri\n  if (word.endsWith('mak') || word.endsWith('mek')) return 'verb';\n  \n  // Türkçe sıfat sonekleri\n  if (word.endsWith('lı') || word.endsWith('li') || \n      word.endsWith('lu') || word.endsWith('lü') ||\n      word.endsWith('sız') || word.endsWith('siz') ||\n      word.endsWith('suz') || word.endsWith('süz')) {\n    return 'adjective';\n  }\n  \n  // Varsayılan\n  return 'unknown';\n}\n\n/**\n * Duygu değeri hesapla (basit)\n */\nfunction calculateSentiment(word: string): number {\n  const positiveWords = ['iyi', 'güzel', 'harika', 'mükemmel', 'sevgi', 'mutlu', 'başarı', 'doğru'];\n  const negativeWords = ['kötü', 'çirkin', 'berbat', 'korkunç', 'nefret', 'üzgün', 'başarısız', 'yanlış'];\n  \n  let sentiment = 0;\n  \n  positiveWords.forEach(pw => {\n    if (word.includes(pw)) sentiment += 0.2;\n  });\n  \n  negativeWords.forEach(nw => {\n    if (word.includes(nw)) sentiment -= 0.2;\n  });\n  \n  return Math.max(-1, Math.min(1, sentiment));\n}\n\n/**\n * Yeni ilişki oluştur\n */\nexport const createRelation = (\n  userWord: string,\n  systemWord: string,\n  initialStrength: number = 50,\n  options?: {\n    dependency?: number;\n    association?: number;\n    order?: number;\n    context?: string[];\n    bidirectional?: boolean;\n    relationType?: 'semantic' | 'temporal' | 'causal' | 'hierarchical';\n  }\n): Relation => {\n  const now = Date.now();\n  \n  return {\n    id: uuid(),\n    userWord,\n    systemWord,\n    dependency: options?.dependency || initialStrength,\n    association: options?.association || initialStrength,\n    frequency: 1,\n    order: options?.order || 0,\n    feedback: 0,\n    isReversed: false,\n    ai_generated: false,\n    \n    // Gelişmiş özellikler\n    strength: initialStrength,\n    context: options?.context || [],\n    learningCount: 1,\n    lastUsed: now,\n    creationTime: now,\n    relationType: options?.relationType || 'semantic',\n    bidirectional: options?.bidirectional || false,\n    confidence: 0.7\n  };\n};\n\n/**\n * İlişki güçlendirme\n */\nexport const reinforceRelation = (relation: Relation, amount: number, feedback?: number): Relation => {\n  const now = Date.now();\n  const updatedRelation = { ...relation };\n  \n  // Temel değerleri güncelle\n  updatedRelation.strength = Math.min(100, updatedRelation.strength + amount);\n  updatedRelation.dependency = Math.min(100, updatedRelation.dependency + amount * 0.8);\n  updatedRelation.association = Math.min(100, updatedRelation.association + amount * 0.5);\n  updatedRelation.frequency += 1;\n  updatedRelation.lastUsed = now;\n  updatedRelation.learningCount += 1;\n  \n  // Geri bildirim varsa ekle\n  if (feedback !== undefined) {\n    updatedRelation.feedback = Math.max(-100, Math.min(100, updatedRelation.feedback + feedback));\n  }\n  \n  // Güven değerini güncelle\n  updatedRelation.confidence = Math.min(1, updatedRelation.confidence + 0.05);\n  \n  return updatedRelation;\n};\n\n/**\n * İlişkileri zayıflatma (unutma)\n */\nexport const weakenRelations = (relations: Relation[], factor: number = FORGET_RATE): Relation[] => {\n  const now = Date.now();\n  const oneDay = 24 * 60 * 60 * 1000;\n  \n  return relations.map(relation => {\n    // Son kullanım zamanına göre hesapla\n    const daysSinceLastUse = (now - relation.lastUsed) / oneDay;\n    if (daysSinceLastUse < 1) {\n      return relation; // Son 24 saat içinde kullanıldı\n    }\n    \n    // Unutma miktarını hesapla\n    const decayAmount = factor * Math.min(10, daysSinceLastUse);\n    \n    // Zayıflatılmış ilişki döndür\n    return {\n      ...relation,\n      strength: Math.max(1, relation.strength - decayAmount),\n      dependency: Math.max(1, relation.dependency - decayAmount * 0.8),\n      association: Math.max(1, relation.association - decayAmount * 0.5),\n      confidence: Math.max(0.1, relation.confidence - decayAmount * 0.01)\n    };\n  });\n};\n\n/**\n * Sinir ağı aktivasyonu\n */\nexport const propagateActivation = (\n  userNetworks: (NetworkNode | null)[][][],\n  systemNetworks: (NetworkNode | null)[][][],\n  relations: Relation[],\n  startWord: string,\n  maxDepth: number = 3\n): ActivationResult => {\n  const startTime = Date.now();\n  const activationPath: { layer: number; row: number; col: number; type: 'user' | 'system'; value: number; word: string }[] = [];\n  const activatedNodes: NetworkNode[] = [];\n  const activatedRelations: Relation[] = [];\n  const activationValues: { [nodeId: string]: number } = {};\n  \n  // İlk düğümü bul\n  let startNode: NetworkNode | null = null;\n  let startNodePosition = { layer: 0, row: 0, col: 0 };\n  \n  // Kullanıcı ağında başla\n  outerLoop: for (let layer = 0; layer < userNetworks.length; layer++) {\n    for (let row = 0; row < userNetworks[layer].length; row++) {\n      for (let col = 0; col < userNetworks[layer][row].length; col++) {\n        const node = userNetworks[layer][row][col];\n        if (node && node.word === startWord.toLowerCase()) {\n          startNode = node;\n          startNodePosition = { layer, row, col };\n          break outerLoop;\n        }\n      }\n    }\n  }\n  \n  // Başlangıç düğümü bulunamadıysa, en yakın düğümü bul\n  if (!startNode) {\n    let bestSimilarity = -1;\n    let bestNode: NetworkNode | null = null;\n    let bestPosition = { layer: 0, row: 0, col: 0 };\n    \n    // Tüm kullanıcı ağını tara\n    for (let layer = 0; layer < userNetworks.length; layer++) {\n      for (let row = 0; row < userNetworks[layer].length; row++) {\n        for (let col = 0; col < userNetworks[layer][row].length; col++) {\n          const node = userNetworks[layer][row][col];\n          if (node) {\n            // Kelime benzerliği hesapla\n            const similarity = calculateWordSimilarity(startWord, node.word);\n            if (similarity > bestSimilarity) {\n              bestSimilarity = similarity;\n              bestNode = node;\n              bestPosition = { layer, row, col };\n            }\n          }\n        }\n      }\n    }\n    \n    startNode = bestNode;\n    startNodePosition = bestPosition;\n  }\n  \n  // Hala başlangıç düğümü yoksa, boş sonuç döndür\n  if (!startNode) {\n    return {\n      activationPath: [],\n      activatedNodes: [],\n      activatedRelations: [],\n      primaryConcepts: [],\n      responseScore: 0,\n      confidence: 0,\n      processingTime: Date.now() - startTime\n    };\n  }\n  \n  // Başlangıç düğümünü ekle\n  activationPath.push({\n    ...startNodePosition,\n    type: 'user',\n    value: 1.0,\n    word: startNode.word\n  });\n  activatedNodes.push(startNode);\n  activationValues[startNode.id] = 1.0;\n  \n  // Aktivasyon yayılımı kuyruğu\n  type ActivationQueueItem = {\n    node: NetworkNode;\n    position: { layer: number; row: number; col: number; type: 'user' | 'system' };\n    activationValue: number;\n    depth: number;\n  };\n  \n  const queue: ActivationQueueItem[] = [{\n    node: startNode,\n    position: { ...startNodePosition, type: 'user' },\n    activationValue: 1.0,\n    depth: 0\n  }];\n  \n  // BFS aktivasyon yayılımı\n  while (queue.length > 0) {\n    const current = queue.shift()!;\n    \n    // Maksimum derinliği aştı mı?\n    if (current.depth >= maxDepth) continue;\n    \n    // İlişkiler aracılığıyla yayılım\n    relations.forEach(relation => {\n      // Kullanıcı düğümünden sistem düğümüne\n      if (current.position.type === 'user' && relation.userWord === current.node.word) {\n        // Sistem düğümünü bul\n        let targetNode: NetworkNode | null = null;\n        let targetPosition = { layer: 0, row: 0, col: 0 };\n        \n        // Sistem ağında ara\n        outerLoop: for (let layer = 0; layer < systemNetworks.length; layer++) {\n          for (let row = 0; row < systemNetworks[layer].length; row++) {\n            for (let col = 0; col < systemNetworks[layer][row].length; col++) {\n              const node = systemNetworks[layer][row][col];\n              if (node && node.word === relation.systemWord) {\n                targetNode = node;\n                targetPosition = { layer, row, col };\n                break outerLoop;\n              }\n            }\n          }\n        }\n        \n        if (targetNode) {\n          // İlişki gücü faktörü\n          const strengthFactor = (relation.strength / 100) * 0.8 + 0.2;\n          \n          // Aktivasyon değerini hesapla (azaltarak yayılım)\n          const newActivation = current.activationValue * strengthFactor;\n          \n          // Düğümün mevcut değerini al veya 0 varsay\n          const existingActivation = activationValues[targetNode.id] || 0;\n          \n          // En yüksek aktivasyon değerini tut\n          const finalActivation = Math.max(existingActivation, newActivation);\n          \n          // Eşiği geçerse ekle\n          if (finalActivation > 0.1 && (!activationValues[targetNode.id] || finalActivation > existingActivation)) {\n            activationValues[targetNode.id] = finalActivation;\n            \n            // Yolu ekle\n            activationPath.push({\n              ...targetPosition,\n              type: 'system',\n              value: finalActivation,\n              word: targetNode.word\n            });\n            \n            // Aktif düğümlere ekle\n            if (!activatedNodes.some(n => n.id === targetNode!.id)) {\n              activatedNodes.push(targetNode);\n            }\n            \n            // Aktif ilişkilere ekle\n            if (!activatedRelations.some(r => r.id === relation.id)) {\n              activatedRelations.push(relation);\n            }\n            \n            // Kuyruğa ekle\n            queue.push({\n              node: targetNode,\n              position: { ...targetPosition, type: 'system' },\n              activationValue: finalActivation,\n              depth: current.depth + 1\n            });\n          }\n        }\n      }\n      \n      // Sistem düğümünden kullanıcı düğümüne (ters)\n      if (current.position.type === 'system' && relation.systemWord === current.node.word) {\n        // Kullanıcı düğümünü bul\n        let targetNode: NetworkNode | null = null;\n        let targetPosition = { layer: 0, row: 0, col: 0 };\n        \n        // Kullanıcı ağında ara\n        outerLoop: for (let layer = 0; layer < userNetworks.length; layer++) {\n          for (let row = 0; row < userNetworks[layer].length; row++) {\n            for (let col = 0; col < userNetworks[layer][row].length; col++) {\n              const node = userNetworks[layer][row][col];\n              if (node && node.word === relation.userWord) {\n                targetNode = node;\n                targetPosition = { layer, row, col };\n                break outerLoop;\n              }\n            }\n          }\n        }\n        \n        if (targetNode) {\n          // İlişki gücü faktörü (ters ilişki biraz daha zayıf)\n          const strengthFactor = (relation.strength / 100) * 0.6 + 0.1;\n          \n          // Aktivasyon değerini hesapla\n          const newActivation = current.activationValue * strengthFactor;\n          \n          // Düğümün mevcut değerini al veya 0 varsay\n          const existingActivation = activationValues[targetNode.id] || 0;\n          \n          // En yüksek aktivasyon değerini tut\n          const finalActivation = Math.max(existingActivation, newActivation);\n          \n          // Eşiği geçerse ekle\n          if (finalActivation > 0.1 && (!activationValues[targetNode.id] || finalActivation > existingActivation)) {\n            activationValues[targetNode.id] = finalActivation;\n            \n            // Yolu ekle\n            activationPath.push({\n              ...targetPosition,\n              type: 'user',\n              value: finalActivation,\n              word: targetNode.word\n            });\n            \n            // Aktif düğümlere ekle\n            if (!activatedNodes.some(n => n.id === targetNode!.id)) {\n              activatedNodes.push(targetNode);\n            }\n            \n            // Aktif ilişkilere ekle\n            if (!activatedRelations.some(r => r.id === relation.id)) {\n              activatedRelations.push(relation);\n            }\n            \n            // Kuyruğa ekle\n            queue.push({\n              node: targetNode,\n              position: { ...targetPosition, type: 'user' },\n              activationValue: finalActivation,\n              depth: current.depth + 1\n            });\n          }\n        }\n      }\n    });\n  }\n  \n  // Ana kavramları belirle (en yüksek aktivasyona sahip sistem düğümleri)\n  const systemNodes = activatedNodes.filter(node => \n    activationPath.some(ap => ap.word === node.word && ap.type === 'system')\n  );\n  \n  const primaryConcepts = systemNodes\n    .map(node => ({\n      word: node.word,\n      activation: activationValues[node.id] || 0\n    }))\n    .sort((a, b) => b.activation - a.activation)\n    .slice(0, 5)\n    .map(item => item.word);\n  \n  // Yanıt puanı ve güven hesapla\n  const responseScore = activatedRelations.reduce((sum, rel) => sum + rel.strength, 0) / \n                       (activatedRelations.length || 1);\n  \n  const confidence = Math.min(1, activatedRelations.length / 8) * \n                    (responseScore / 100);\n  \n  return {\n    activationPath,\n    activatedNodes,\n    activatedRelations,\n    primaryConcepts,\n    responseScore,\n    confidence,\n    processingTime: Date.now() - startTime\n  };\n};\n\n/**\n * Kelime benzerliği hesapla (Levenshtein mesafesi)\n */\nfunction calculateWordSimilarity(word1: string, word2: string): number {\n  const a = word1.toLowerCase();\n  const b = word2.toLowerCase();\n  \n  // Tamamen aynı ise\n  if (a === b) return 1;\n  \n  // Biri diğerini içeriyorsa\n  if (a.includes(b) || b.includes(a)) {\n    const longerLength = Math.max(a.length, b.length);\n    const shorterLength = Math.min(a.length, b.length);\n    return shorterLength / longerLength * 0.8;\n  }\n  \n  // Levenshtein mesafesi\n  const matrix: number[][] = [];\n  \n  for (let i = 0; i <= b.length; i++) {\n    matrix[i] = [i];\n  }\n  \n  for (let j = 0; j <= a.length; j++) {\n    matrix[0][j] = j;\n  }\n  \n  for (let i = 1; i <= b.length; i++) {\n    for (let j = 1; j <= a.length; j++) {\n      if (b.charAt(i - 1) === a.charAt(j - 1)) {\n        matrix[i][j] = matrix[i - 1][j - 1];\n      } else {\n        matrix[i][j] = Math.min(\n          matrix[i - 1][j - 1] + 1, // değiştirme\n          Math.min(\n            matrix[i][j - 1] + 1,   // ekleme\n            matrix[i - 1][j] + 1    // silme\n          )\n        );\n      }\n    }\n  }\n  \n  const distance = matrix[b.length][a.length];\n  const maxLength = Math.max(a.length, b.length);\n  \n  // Normalize (0 = tamamen farklı, 1 = aynı)\n  return 1 - (distance / maxLength);\n}\n\n/**\n * Yanıt oluştur (geliştirilmiş)\n */\nexport const generateResponse = async (\n  prompt: string,\n  options?: {\n    useActivation?: boolean;\n    userNetworks?: (NetworkNode | null)[][][];\n    systemNetworks?: (NetworkNode | null)[][][];\n    relations?: Relation[];\n    activeMemories?: string[];\n    mood?: 'formal' | 'friendly' | 'professional' | 'casual';\n    maxLength?: number;\n    trainingHistory?: Array<{userInput: string, systemOutput: string, timestamp: number}>;\n  }\n): Promise<{\n  text: string;\n  confidence: number;\n  concepts: string[];\n  processingTime: number;\n}> => {\n  const startTime = Date.now();\n  \n  // Girdi işleme\n  const normalizedPrompt = prompt.toLowerCase().trim();\n  \n  // DOĞRUDAN EĞİTİM EŞLEŞMESİ - Tam eşleşme kontrolü (en yüksek öncelik)\n  // Eğer soru daha önce eğitilmişse, tam eşleşen cevabı döndür\n  if (options?.trainingHistory && options.trainingHistory.length > 0) {\n    // Tam eşleşme arama - kelime düzenine bile duyarlı\n    const exactMatch = options.trainingHistory.find(item => \n      item.userInput.toLowerCase().trim() === normalizedPrompt\n    );\n    \n    if (exactMatch) {\n      return {\n        text: exactMatch.systemOutput,\n        confidence: 0.95,\n        concepts: exactMatch.systemOutput.split(/\\s+/).slice(0, 3),\n        processingTime: Date.now() - startTime\n      };\n    }\n  }\n  \n  // EĞİTİM BENZERLİĞİ - Yüksek benzerlik kontrolü\n  if (options?.trainingHistory && options.trainingHistory.length > 0) {\n    // Girdi kelimelerini ayır\n    const promptWords = normalizedPrompt.split(/\\s+/);\n    \n    // En iyi benzerlik eşleşmesini arama\n    let bestMatch = null;\n    let bestScore = 0.6; // Eşik değer - bu değerin altındaki benzerlikler kabul edilmeyecek\n    \n    for (const item of options.trainingHistory) {\n      const trainedInput = item.userInput.toLowerCase().trim();\n      const trainedWords = trainedInput.split(/\\s+/);\n      \n      // Benzerlik puanı hesaplama\n      let wordMatches = 0;\n      for (const word of promptWords) {\n        if (trainedWords.includes(word)) {\n          wordMatches++;\n        }\n      }\n      \n      // Jaccard benzerlik katsayısı\n      const commonWords = wordMatches;\n      const totalUniqueWords = new Set([...promptWords, ...trainedWords]).size;\n      const similarityScore = commonWords / totalUniqueWords;\n      \n      // Eğer daha iyi bir eşleşme bulunduysa, güncelle\n      if (similarityScore > bestScore) {\n        bestMatch = item;\n        bestScore = similarityScore;\n      }\n    }\n    \n    // Yeterince iyi bir benzerlik varsa, eğitilmiş cevabı döndür\n    if (bestMatch) {\n      return {\n        text: bestMatch.systemOutput,\n        confidence: bestScore,\n        concepts: bestMatch.systemOutput.split(/\\s+/).slice(0, 3),\n        processingTime: Date.now() - startTime\n      };\n    }\n  }\n  \n  // İLİŞKİ TABANLI YANIT - Aktivasyon modeli için geliştirilmiş versiyon\n  if (options?.useActivation && options.userNetworks && options.systemNetworks && options.relations) {\n    // Durdurma kelimeleri (stopwords) ve kısa kelimeleri filtrele\n    const keywordExtractor = (text: string): string[] => {\n      // Türkçe durdurma kelimeleri\n      const stopwords = ['ve', 'veya', 'bir', 'bu', 'şu', 'o', 'da', 'de', 'için', 'ile', 'mi', 'ne', 'ama', 'fakat'];\n      return text.toLowerCase()\n        .split(/\\s+/)\n        .filter(word => word.length > 2 && !stopwords.includes(word));\n    };\n    \n    const keywords = keywordExtractor(normalizedPrompt);\n    \n    if (keywords.length > 0) {\n      // Aktivasyon sonuçlarını tüm anahtar kelimeler için topla\n      let combinedActivation: ActivationResult | null = null;\n      let activatedConcepts: Set<string> = new Set();\n      let totalConfidence = 0;\n      \n      // Her anahtar kelime için aktivasyon yap\n      for (const keyword of keywords) {\n        const activation = propagateActivation(\n          options.userNetworks,\n          options.systemNetworks,\n          options.relations,\n          keyword,\n          4 // Derinliği artırdık (3'ten 4'e)\n        );\n        \n        // Konseptleri birleştir\n        activation.primaryConcepts.forEach(concept => activatedConcepts.add(concept));\n        \n        // Güven değerini topla\n        totalConfidence += activation.confidence;\n        \n        // İlk aktivasyon veya daha iyi bir aktivasyon ise kaydet\n        if (!combinedActivation || activation.responseScore > combinedActivation.responseScore) {\n          combinedActivation = activation;\n        }\n      }\n      \n      // Ortalama güven değeri\n      const avgConfidence = totalConfidence / keywords.length;\n      \n      // Konsept dizisini oluştur\n      const concepts = Array.from(activatedConcepts);\n      \n      if (combinedActivation && concepts.length > 0 && avgConfidence > 0.2) {\n        // Hafıza bilgilerini dahil et\n        let contextInfo = '';\n        if (options.activeMemories && options.activeMemories.length > 0) {\n          const randomMemory = options.activeMemories[Math.floor(Math.random() * options.activeMemories.length)];\n          if (Math.random() > 0.7) { // %30 olasılıkla hafıza bilgisi ekle\n            contextInfo = `Hatırlıyorum ki ${randomMemory}. `;\n          }\n        }\n        \n        // Yanıt şablonları\n        const responseTemplates = [\n          // Bilgi verme şablonları\n          `${contextInfo}${concepts[0]} hakkında bilgi vermem gerekirse, ${\n            concepts.length > 1 ? `${concepts[1]} ile ilişkili olarak ` : ''\n          }şunları söyleyebilirim: Bu konu ${\n            combinedActivation.activatedRelations.length > 2 ? 'birçok farklı kavramla' : 'bazı önemli kavramlarla'\n          } bağlantılıdır.`,\n          \n          // Soru yanıtlama şablonları\n          `${contextInfo}${concepts[0]} sorunuza yanıt olarak: ${\n            concepts.length > 1 ? `${concepts[1]} ve ${concepts[0]} arasında önemli bir ilişki vardır.` : \n            `Bu konu hakkında bildiklerim sınırlı olsa da yardımcı olmaya çalışacağım.`\n          }`,\n          \n          // Doğrudan yanıt şablonları\n          `${concepts[0]} ${concepts.length > 1 ? `ve ${concepts[1]}` : ''} konusunda yardımcı olabilirim. ${\n            options.activeMemories && options.activeMemories.length > 0 ? \n            `Daha önce ${options.activeMemories[0].split(' ').slice(0, 3).join(' ')} hakkında konuşmuştuk.` : \n            `Bu konuda daha fazla bilgi ister misiniz?`\n          }`,\n          \n          // Detaylı yanıt\n          `${contextInfo}Sorduğunuz ${concepts[0]} konusu hakkında şunları söyleyebilirim: ${\n            concepts.length > 1 ? `${concepts.slice(1, 3).join(' ve ')} ile yakından ilişkilidir.` : \n            'Bu önemli bir konudur ve size detaylı bilgi verebilirim.'\n          } ${combinedActivation.activatedRelations.length > 3 ? \n            `Bu alanda ${combinedActivation.activatedRelations.length} farklı bağlantı tespit ettim.` : \n            ''\n          }`,\n          \n          // Kısa yanıt\n          `${concepts[0]} konusunda size yardımcı olabilirim. Ne öğrenmek istersiniz?`\n        ];\n        \n        // Daha karmaşık yanıtları seçme olasılığını artır\n        const extendedTemplates = [...responseTemplates];\n        // İlk iki (daha detaylı) şablonu 2 kez ekleyerek seçilme şansını artır\n        extendedTemplates.push(responseTemplates[0], responseTemplates[1]); \n        \n        const template = extendedTemplates[Math.floor(Math.random() * extendedTemplates.length)];\n        \n        return {\n          text: template,\n          confidence: Math.min(0.9, avgConfidence * 1.2), // Güven değerini biraz artır\n          concepts: concepts,\n          processingTime: Date.now() - startTime\n        };\n      }\n    }\n  }\n  \n  // ANAHTAR KELİME TABLI YANIT - Eğitilmemiş durum için yedek\n  const keywords = [\n    { word: \"merhaba\", responses: [\"Merhaba! Nasıl yardımcı olabilirim?\", \"Merhaba! Size nasıl yardımcı olabilirim?\"] },\n    { word: \"nasılsın\", responses: [\"İyiyim, teşekkür ederim! Siz nasılsınız?\", \"Harikayım, size nasıl yardımcı olabilirim?\"] },\n    { word: \"teşekkür\", responses: [\"Rica ederim!\", \"Ne demek, her zaman yardımcı olmaktan mutluluk duyarım.\"] },\n    { word: \"yapay zeka\", responses: [\"Yapay zeka alanı son yıllarda hızla gelişiyor.\", \"Yapay zeka sistemleri her geçen gün daha akıllı hale geliyor.\"] },\n    { word: \"sinir ağı\", responses: [\"Sinir ağları, yapay zekanın temel bileşenlerinden biridir.\", \"Sinir ağları, insan beynindeki nöronların çalışma prensibini taklit eder.\"] },\n    { word: \"hafıza\", responses: [\"Hafıza sistemleri, yapay zeka asistanlarının en önemli özelliklerinden biridir.\", \"Modern yapay zeka sistemleri, kısa ve uzun vadeli hafıza mekanizmaları kullanır.\"] },\n    { word: \"türkçe\", responses: [\"Türkçe doğal dil işleme alanında çalışmalar giderek artıyor.\", \"Türkçe, yapay zeka sistemleri için zengin ve ilginç bir dildir.\"] },\n    { word: \"eğitim\", responses: [\"Yapay zeka sistemlerini eğitmek için büyük miktarda veri gereklidir.\", \"Eğitim süreci, yapay zeka sistemlerinin kalitesini belirleyen en önemli faktördür.\"] },\n    { word: \"bilgi\", responses: [\"Bilgi işleme ve öğrenme, yapay zeka sistemlerinin temel özellikleridir.\", \"Bilgi, yapay zeka sistemlerinin daha iyi yanıtlar üretmesini sağlar.\"] },\n    { word: \"yardım\", responses: [\"Size nasıl yardımcı olabilirim?\", \"Sorularınızı yanıtlamak için buradayım.\"] },\n    { word: \"mobil\", responses: [\"Mobil uyumlu arayüzler günümüzde çok önemli hale geldi.\", \"Mobil deneyim, kullanıcıların uygulamaları daha çok tercih etmelerini sağlar.\"] },\n    { word: \"tasarım\", responses: [\"İyi bir tasarım, kullanıcı deneyimini önemli ölçüde geliştirir.\", \"Modern tasarım ilkeleri, kullanıcı dostu arayüzler oluşturmaya yardımcı olur.\"] }\n  ];\n  \n  // Anahtar kelimeleri kontrol et\n  for (const keyword of keywords) {\n    if (normalizedPrompt.includes(keyword.word)) {\n      const response = keyword.responses[Math.floor(Math.random() * keyword.responses.length)];\n      return {\n        text: response,\n        confidence: 0.7,\n        concepts: [keyword.word],\n        processingTime: Date.now() - startTime\n      };\n    }\n  }\n  \n  // VARSAYILAN YANIT - Hiçbir eşleşme bulunamazsa\n  const defaultResponses = [\n    \"Merhaba! Size nasıl yardımcı olabilirim?\",\n    \"Bu konu hakkında biraz daha bilgi verebilir misiniz?\",\n    \"Anladım, bu konuyu araştırmak için elimden geleni yapacağım.\",\n    \"Bu soruya net bir yanıt vermek zor, çünkü birçok faktöre bağlı.\",\n    \"İlginç bir bakış açısı! Farklı perspektiflerden düşünmek önemli.\",\n    \"Bu konuda birkaç kaynak önerebilirim size.\",\n    \"Türkçe doğal dil işleme konusundaki gelişmeler çok heyecan verici.\",\n    \"Yapay zeka sistemlerinin Türkçe dil desteği giderek gelişiyor.\",\n    \"Sinir ağları, insan beyninin çalışma prensiplerinden ilham alır.\",\n    \"Sizin için bu problemi çözmek için bir strateji düşünelim.\",\n    \"Bu konuda daha fazla bilgi edinmek isterseniz, size yardımcı olabilirim.\",\n    \"Bence bu yaklaşım doğru yönde bir adım olabilir.\"\n  ];\n  \n  return {\n    text: defaultResponses[Math.floor(Math.random() * defaultResponses.length)],\n    confidence: 0.5,\n    concepts: [],\n    processingTime: Date.now() - startTime\n  };\n};\n","size_bytes":42428},"attached_assets/NeuralNetworkVisualization.tsx":{"content":"import React, { useEffect, useState, useRef, useCallback } from 'react';\nimport { RefreshCw, ZoomIn, ZoomOut, Network, BrainCircuit, Nodes, Eye, EyeOff, RotateCw, ArrowLeftRight, Cpu, ArrowRightLeft, DownloadCloud, Save } from 'lucide-react';\nimport { NetworkNode, Relation, ACTIVATION_DECAY_RATE } from '@/lib/NeuralNetworkUtils';\nimport { useTheme } from '@/contexts/ThemeContext';\nimport { useIsMobile } from '@/hooks/use-mobile';\nimport { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';\nimport { Button } from '@/components/ui/button';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { ToggleGroup, ToggleGroupItem } from '@/components/ui/toggle-group';\nimport { Skeleton } from '@/components/ui/skeleton';\nimport { cn } from '@/lib/utils';\n\ninterface NeuralNetworkVisualizationProps {\n  userNetworks: (NetworkNode | null)[][][];\n  systemNetworks: (NetworkNode | null)[][][];\n  relations: Relation[];\n  activatedNodes: { layer: number; row: number; col: number; type: 'user' | 'system' }[];\n  isAnimating: boolean;\n  onReset: () => void;\n  onCellClick: (cell: NetworkNode & { layer: number; row: number; col: number; type: 'user' | 'system' }) => void;\n  visualMode: \"simple\" | \"detailed\" | \"3d\" | \"relations\" | \"normal\";\n  setVisualMode: (mode: \"simple\" | \"detailed\" | \"3d\" | \"relations\" | \"normal\") => void;\n  networkRows: number;\n  networkCols: number;\n  networkLayers: number;\n}\n\nconst NeuralNetworkVisualization: React.FC<NeuralNetworkVisualizationProps> = ({\n  userNetworks,\n  systemNetworks,\n  relations,\n  activatedNodes,\n  isAnimating,\n  onReset,\n  onCellClick,\n  visualMode,\n  setVisualMode,\n  networkRows,\n  networkCols,\n  networkLayers\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [scale, setScale] = useState(0.85);\n  const [maxWidth, setMaxWidth] = useState(900);\n  const [selectedNodeInfo, setSelectedNodeInfo] = useState<string | null>(null);\n  const [animationFrame, setAnimationFrame] = useState<number | null>(null);\n  const [viewMode, setViewMode] = useState('2d'); // '2d' veya '3d'\n  const [highlightMode, setHighlightMode] = useState<'none' | 'activation' | 'importance' | 'frequency'>('activation');\n  const { isDarkMode } = useTheme();\n  const isMobile = useIsMobile();\n  const gradientCache = useRef<Record<string, CanvasGradient>>({});\n\n  // Görselleştirme boyutunu ayarla ve pencere boyutu değiştiğinde güncelle\n  useEffect(() => {\n    const updateDimensions = () => {\n      if (containerRef.current) {\n        const containerWidth = containerRef.current.offsetWidth;\n        setMaxWidth(containerWidth > 600 ? containerWidth * 0.95 : containerWidth);\n      }\n    };\n\n    updateDimensions();\n    window.addEventListener('resize', updateDimensions);\n    \n    return () => {\n      window.removeEventListener('resize', updateDimensions);\n    };\n  }, []);\n\n  // Animasyon çerçevesini temizle (componentWillUnmount)\n  useEffect(() => {\n    return () => {\n      if (animationFrame !== null) {\n        cancelAnimationFrame(animationFrame);\n      }\n    };\n  }, [animationFrame]);\n  \n  // Renk teması\n  const getColors = useCallback(() => {\n    if (isDarkMode) {\n      return {\n        userNodeColor: 'rgba(79, 70, 229, 1)', // Indigo-600\n        systemNodeColor: 'rgba(139, 92, 246, 1)', // Violet-500\n        activatedNodeColor: 'rgba(234, 88, 12, 1)', // Orange-600\n        connectionColor: 'rgba(139, 92, 246, 0.6)', // Violet-500 with opacity\n        importanceColor: 'rgba(16, 185, 129, 1)', // Emerald-500\n        frequencyColor: 'rgba(245, 158, 11, 1)', // Amber-500\n        emptyNodeColor: 'rgba(55, 65, 81, 0.1)', // Gray-700 with low opacity\n        backgroundColor: 'rgba(17, 24, 39, 1)', // Gray-900\n        textColor: 'rgba(243, 244, 246, 1)' // Gray-100\n      };\n    } else {\n      return {\n        userNodeColor: 'rgba(79, 70, 229, 1)', // Indigo-600\n        systemNodeColor: 'rgba(124, 58, 237, 1)', // Purple-600\n        activatedNodeColor: 'rgba(239, 68, 68, 1)', // Red-500\n        connectionColor: 'rgba(99, 102, 241, 0.6)', // Indigo-500 with opacity\n        importanceColor: 'rgba(16, 185, 129, 1)', // Emerald-500\n        frequencyColor: 'rgba(245, 158, 11, 1)', // Amber-500\n        emptyNodeColor: 'rgba(229, 231, 235, 0.3)', // Gray-200 with opacity\n        backgroundColor: 'rgba(255, 255, 255, 1)', // White\n        textColor: 'rgba(17, 24, 39, 1)' // Gray-900\n      };\n    }\n  }, [isDarkMode]);\n\n  // Gradyan oluşturma fonksiyonu\n  const createGradient = useCallback((ctx: CanvasRenderingContext2D, startColor: string, endColor: string, x: number, y: number, size: number): CanvasGradient => {\n    const cacheKey = `${startColor}-${endColor}-${x}-${y}-${size}`;\n    \n    if (gradientCache.current[cacheKey]) {\n      return gradientCache.current[cacheKey];\n    }\n    \n    const gradient = ctx.createRadialGradient(\n      x + size/2, y + size/2, 0,\n      x + size/2, y + size/2, size\n    );\n    \n    gradient.addColorStop(0, startColor);\n    gradient.addColorStop(1, endColor);\n    \n    gradientCache.current[cacheKey] = gradient;\n    return gradient;\n  }, []);\n  \n  // Kanvas görselleştirmesi\n  const drawCanvas = useCallback(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    const colors = getColors();\n\n    // Boyutları ayarla\n    const gapX = 10 * scale;\n    const gapY = 10 * scale;\n    const nodeSize = 14 * scale;\n    const LAYER_GAP = 140 * scale;\n    const nodeRadius = nodeSize / 2;\n    \n    const layerHeight = Math.max(300, networkRows * (nodeSize + gapY));\n    \n    // Kanvas boyutunu ayarla\n    const totalWidth = (userNetworks.length + systemNetworks.length) * LAYER_GAP;\n    canvas.width = Math.max(600, totalWidth);\n    canvas.height = layerHeight;\n    \n    // Arka planı temizle ve arka plan dolgusu\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    \n    // Izgara çizgileri (opsiyonel)\n    if (viewMode === '2d') {\n      const gridColor = isDarkMode ? 'rgba(75, 85, 99, 0.2)' : 'rgba(229, 231, 235, 0.5)';\n      ctx.strokeStyle = gridColor;\n      ctx.lineWidth = 0.5;\n      \n      // Yatay çizgiler\n      for (let i = 0; i <= networkRows; i++) {\n        const y = i * (nodeSize + gapY);\n        ctx.beginPath();\n        ctx.moveTo(0, y);\n        ctx.lineTo(canvas.width, y);\n        ctx.stroke();\n      }\n      \n      // Dikey çizgiler\n      for (let i = 0; i <= (userNetworks.length + systemNetworks.length); i++) {\n        const x = i * LAYER_GAP;\n        ctx.beginPath();\n        ctx.moveTo(x, 0);\n        ctx.lineTo(x, canvas.height);\n        ctx.stroke();\n      }\n    }\n    \n    // Önce ilişkileri çiz (alt katman)\n    if (visualMode === 'relations' && relations.length > 0) {\n      // İlişkileri güçlerine göre sırala (zayıf ilişkiler önce çizilecek)\n      const sortedRelations = [...relations].sort((a, b) => {\n        const strengthA = (a.dependency + a.association) / 2;\n        const strengthB = (b.dependency + b.association) / 2;\n        return strengthA - strengthB;\n      });\n      \n      for (const relation of sortedRelations) {\n        // Kaynak kelimeyi bul\n        const sourceInfo = findNode(userNetworks, relation.userWord);\n        if (!sourceInfo) continue;\n        \n        // Hedef kelimeyi bul\n        const targetInfo = findNode(systemNetworks, relation.systemWord);\n        if (!targetInfo) continue;\n        \n        const {layer: sourceLayer, row: sourceRow, col: sourceCol} = sourceInfo;\n        const {layer: targetLayer, row: targetRow, col: targetCol} = targetInfo;\n        \n        const sourceX = sourceLayer * LAYER_GAP + sourceCol * (nodeSize + gapX) + nodeRadius;\n        const sourceY = sourceRow * (nodeSize + gapY) + nodeRadius;\n        \n        const targetX = targetLayer * LAYER_GAP + ((userNetworks.length) * LAYER_GAP) + targetCol * (nodeSize + gapX) + nodeRadius;\n        const targetY = targetRow * (nodeSize + gapY) + nodeRadius;\n        \n        // İlişkinin gücüne dayalı renklendirme\n        const strength = (relation.dependency + relation.association) / 2;\n        const normalizedStrength = Math.min(1, Math.max(0.1, strength / 100));\n        \n        // İlişki türüne göre renk\n        let relationColor = colors.connectionColor;\n        if (relation.relationType === 'semantic') {\n          relationColor = 'rgba(139, 92, 246, 0.6)'; // Mor\n        } else if (relation.relationType === 'causal') {\n          relationColor = 'rgba(239, 68, 68, 0.6)'; // Kırmızı\n        } else if (relation.relationType === 'temporal') {\n          relationColor = 'rgba(59, 130, 246, 0.6)'; // Mavi\n        } else if (relation.relationType === 'hierarchical') {\n          relationColor = 'rgba(16, 185, 129, 0.6)'; // Yeşil\n        }\n\n        // İlişki çizgisini çiz (eğri)\n        ctx.beginPath();\n        \n        // Control noktaları\n        const cpX1 = sourceX + (targetX - sourceX) * 0.4;\n        const cpY1 = sourceY;\n        const cpX2 = targetX - (targetX - sourceX) * 0.4;\n        const cpY2 = targetY;\n        \n        // Bezier eğrisi\n        ctx.moveTo(sourceX, sourceY);\n        ctx.bezierCurveTo(cpX1, cpY1, cpX2, cpY2, targetX, targetY);\n        \n        // İlişkinin gücüne göre renk ve kalınlık\n        ctx.strokeStyle = relationColor;\n        ctx.lineWidth = Math.max(0.5, normalizedStrength * 3 * scale);\n        ctx.globalAlpha = Math.max(0.2, normalizedStrength);\n        ctx.stroke();\n        ctx.globalAlpha = 1.0;\n        \n        // İlişki bidirectional ise ok ucu ekle\n        if (relation.bidirectional) {\n          // Ok ucu\n          const headLen = 5 * scale;\n          const dx = targetX - cpX2;\n          const dy = targetY - cpY2;\n          const angle = Math.atan2(dy, dx);\n          \n          // Ok ucunu çiz\n          ctx.beginPath();\n          ctx.moveTo(targetX, targetY);\n          ctx.lineTo(\n            targetX - headLen * Math.cos(angle - Math.PI / 6),\n            targetY - headLen * Math.sin(angle - Math.PI / 6)\n          );\n          ctx.lineTo(\n            targetX - headLen * Math.cos(angle + Math.PI / 6),\n            targetY - headLen * Math.sin(angle + Math.PI / 6)\n          );\n          ctx.closePath();\n          ctx.fillStyle = relationColor;\n          ctx.fill();\n          \n          // Ters yönde ok ucu\n          ctx.beginPath();\n          ctx.moveTo(sourceX, sourceY);\n          ctx.lineTo(\n            sourceX + headLen * Math.cos(angle - Math.PI / 6),\n            sourceY + headLen * Math.sin(angle - Math.PI / 6)\n          );\n          ctx.lineTo(\n            sourceX + headLen * Math.cos(angle + Math.PI / 6),\n            sourceY + headLen * Math.sin(angle + Math.PI / 6)\n          );\n          ctx.closePath();\n          ctx.fillStyle = relationColor;\n          ctx.fill();\n        }\n      }\n    }\n    \n    // Kullanıcı ve sistem ağlarını çiz\n    for (let layerIdx = 0; layerIdx < userNetworks.length; layerIdx++) {\n      const userStartX = layerIdx * LAYER_GAP;\n      const systemStartX = layerIdx * LAYER_GAP + ((userNetworks.length) * LAYER_GAP);\n      \n      // Kullanıcı katman etiketini çiz\n      ctx.fillStyle = isDarkMode ? 'rgba(255, 255, 255, 0.8)' : 'rgba(0, 0, 0, 0.8)';\n      ctx.font = `${Math.max(10, 12 * scale)}px Arial`;\n      ctx.textAlign = 'center';\n      ctx.fillText(`Kullanıcı Katmanı ${layerIdx + 1}`, userStartX + (networkCols * (nodeSize + gapX)) / 2, 14);\n      \n      // Sistem katman etiketini çiz\n      ctx.fillText(`Sistem Katmanı ${layerIdx + 1}`, systemStartX + (networkCols * (nodeSize + gapX)) / 2, 14);\n      \n      // Kullanıcı ve sistem ağlarını çiz\n      drawNetwork(\n        ctx, userNetworks[layerIdx], userStartX, 20, nodeSize, gapX, gapY, 'user', layerIdx, colors\n      );\n      \n      drawNetwork(\n        ctx, systemNetworks[layerIdx], systemStartX, 20, nodeSize, gapX, gapY, 'system', layerIdx, colors\n      );\n    }\n    \n    // Aktivasyonları göster\n    if (isAnimating) {\n      activatedNodes.forEach(node => {\n        const nodeType = node.type;\n        let startX;\n        \n        if (nodeType === 'user') {\n          startX = node.layer * LAYER_GAP;\n        } else {\n          startX = node.layer * LAYER_GAP + ((userNetworks.length) * LAYER_GAP);\n        }\n        \n        const x = startX + node.col * (nodeSize + gapX) + nodeRadius;\n        const y = 20 + node.row * (nodeSize + gapY) + nodeRadius;\n        \n        // Pulse efekti\n        const now = Date.now();\n        const pulseSize = 1.5 + Math.sin(now / 200) * 0.3;\n        \n        // Dış halka\n        ctx.beginPath();\n        ctx.arc(x, y, nodeRadius * pulseSize, 0, Math.PI * 2);\n        ctx.strokeStyle = colors.activatedNodeColor;\n        ctx.lineWidth = 2 * scale;\n        ctx.globalAlpha = 0.7;\n        ctx.stroke();\n        ctx.globalAlpha = 1.0;\n      });\n    }\n    \n    // Tıklama olayları için canvas etkileşimini ayarla\n    setupCanvasInteraction(scale, nodeSize, gapX, gapY, LAYER_GAP);\n    \n    // Animation devam ediyorsa, bir sonraki frame'i çiz\n    if (isAnimating) {\n      setAnimationFrame(requestAnimationFrame(drawCanvas));\n    }\n  }, [\n    userNetworks, systemNetworks, relations, activatedNodes, isAnimating, \n    scale, visualMode, networkRows, networkCols, isDarkMode, viewMode, \n    networkLayers, highlightMode, createGradient, getColors\n  ]);\n  \n  // Canvas çizimini tetikle\n  useEffect(() => {\n    drawCanvas();\n  }, [drawCanvas]);\n\n  // Kelimeyi tüm ağlar içinde bul\n  const findNode = (networks: (NetworkNode | null)[][][], word: string) => {\n    for (let layer = 0; layer < networks.length; layer++) {\n      for (let row = 0; row < networks[layer].length; row++) {\n        for (let col = 0; col < networks[layer][row].length; col++) {\n          const node = networks[layer][row][col];\n          if (node && node.word === word) {\n            return { layer, row, col };\n          }\n        }\n      }\n    }\n    return null;\n  };\n  \n  // Bir katman ağını çiz\n  const drawNetwork = (\n    ctx: CanvasRenderingContext2D,\n    network: (NetworkNode | null)[][],\n    startX: number,\n    startY: number,\n    nodeSize: number,\n    gapX: number,\n    gapY: number,\n    type: 'user' | 'system',\n    layerIdx: number,\n    colors: ReturnType<typeof getColors>\n  ) => {\n    for (let row = 0; row < network.length; row++) {\n      for (let col = 0; col < network[row].length; col++) {\n        const node = network[row][col];\n        const x = startX + col * (nodeSize + gapX);\n        const y = startY + row * (nodeSize + gapY);\n        \n        // Boş hücreleri çiz\n        if (!node) {\n          ctx.beginPath();\n          if (viewMode === '2d') {\n            ctx.rect(x, y, nodeSize, nodeSize);\n          } else {\n            ctx.arc(x + nodeSize/2, y + nodeSize/2, nodeSize/2, 0, Math.PI * 2);\n          }\n          ctx.fillStyle = colors.emptyNodeColor;\n          ctx.fill();\n          continue;\n        }\n        \n        // Farklı vurgu modlarına göre renk belirle\n        let baseColor;\n        let intensity = 0;\n        \n        if (type === 'user') {\n          baseColor = colors.userNodeColor;\n        } else {\n          baseColor = colors.systemNodeColor;\n        }\n        \n        // Vurgu moduna göre değer belirle\n        if (highlightMode === 'activation') {\n          intensity = Math.max(0.2, node.activation);\n        } else if (highlightMode === 'importance') {\n          intensity = Math.max(0.2, (node.importance || 50) / 100);\n        } else if (highlightMode === 'frequency') {\n          intensity = Math.max(0.2, Math.min(1, node.frequency / 20));\n        }\n        \n        // Gradyan oluştur\n        let color;\n        if (viewMode === '3d') {\n          // Gradyan renkleri\n          const startColorRGB = baseColor.replace('rgba(', '').replace(')', '').split(',');\n          const startColorStr = `rgba(${startColorRGB[0]}, ${startColorRGB[1]}, ${startColorRGB[2]}, ${intensity})`;\n          const endColorStr = `rgba(${startColorRGB[0]}, ${startColorRGB[1]}, ${startColorRGB[2]}, ${intensity * 0.5})`;\n          \n          color = createGradient(ctx, startColorStr, endColorStr, x, y, nodeSize);\n        } else {\n          // Düz renk\n          const rgbValues = baseColor.replace('rgba(', '').replace(')', '').split(',');\n          color = `rgba(${rgbValues[0]}, ${rgbValues[1]}, ${rgbValues[2]}, ${intensity})`;\n        }\n\n        // Vurgulanan nodları farklı bir renkte göster\n        const isActivated = activatedNodes.some(\n          n => n.layer === layerIdx && n.row === row && n.col === col && n.type === type\n        );\n        \n        if (isActivated) {\n          color = colors.activatedNodeColor;\n        }\n        \n        // 2D veya 3D gösterim moduna göre çizim\n        ctx.beginPath();\n        if (viewMode === '2d') {\n          // Kare çiz\n          ctx.rect(x, y, nodeSize, nodeSize);\n        } else {\n          // Daire çiz\n          ctx.arc(x + nodeSize/2, y + nodeSize/2, nodeSize/2, 0, Math.PI * 2);\n        }\n        ctx.fillStyle = color;\n        ctx.fill();\n        \n        // 3D mod için gölgelendirme ekle\n        if (viewMode === '3d') {\n          ctx.beginPath();\n          ctx.arc(x + nodeSize/2, y + nodeSize/2, nodeSize/2, 0, Math.PI * 2);\n          ctx.lineWidth = 0.5;\n          ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';\n          ctx.stroke();\n        }\n      }\n    }\n  };\n  \n  // Canvas etkileşimini ayarla\n  const setupCanvasInteraction = (\n    scale: number,\n    nodeSize: number,\n    gapX: number,\n    gapY: number,\n    layerGap: number\n  ) => {\n    const currentCanvas = canvasRef.current;\n    if (!currentCanvas) return;\n    \n    // Mouse hover olayı\n    currentCanvas.onmousemove = (e: MouseEvent) => {\n      const rect = currentCanvas.getBoundingClientRect();\n      const mouseX = e.clientX - rect.left;\n      const mouseY = e.clientY - rect.top;\n      \n      // Tüm düğümleri kontrol et\n      let foundNode = false;\n      \n      for (let l = 0; l < userNetworks.length; l++) {\n        // Kullanıcı ağı nodları için kontrol\n        const userStartX = l * layerGap;\n        \n        for (let row = 0; row < userNetworks[l].length; row++) {\n          for (let col = 0; col < userNetworks[l][row].length; col++) {\n            const node = userNetworks[l][row][col];\n            if (!node) continue;\n            \n            const x = userStartX + col * (nodeSize + gapX);\n            const y = 20 + row * (nodeSize + gapY);\n            \n            const isHover = viewMode === '2d'\n              ? (mouseX >= x && mouseX <= x + nodeSize && mouseY >= y && mouseY <= y + nodeSize)\n              : Math.sqrt(Math.pow(mouseX - (x + nodeSize/2), 2) + Math.pow(mouseY - (y + nodeSize/2), 2)) <= nodeSize/2;\n            \n            if (isHover) {\n              setSelectedNodeInfo(`Kullanıcı: ${node.word} (L${l+1}R${row+1}C${col+1})\\nAktivasyon: ${(node.activation * 100).toFixed(0)}%\\nKullanım: ${node.frequency}x\\nÖnem: ${node.importance || 0}`);\n              foundNode = true;\n              document.body.style.cursor = 'pointer';\n              break;\n            }\n          }\n        }\n        \n        // Sistem ağı nodları için kontrol\n        const systemStartX = l * layerGap + ((userNetworks.length) * layerGap);\n        \n        for (let row = 0; row < systemNetworks[l].length; row++) {\n          for (let col = 0; col < systemNetworks[l][row].length; col++) {\n            const node = systemNetworks[l][row][col];\n            if (!node) continue;\n            \n            const x = systemStartX + col * (nodeSize + gapX);\n            const y = 20 + row * (nodeSize + gapY);\n            \n            const isHover = viewMode === '2d'\n              ? (mouseX >= x && mouseX <= x + nodeSize && mouseY >= y && mouseY <= y + nodeSize)\n              : Math.sqrt(Math.pow(mouseX - (x + nodeSize/2), 2) + Math.pow(mouseY - (y + nodeSize/2), 2)) <= nodeSize/2;\n            \n            if (isHover) {\n              setSelectedNodeInfo(`Sistem: ${node.word} (L${l+1}R${row+1}C${col+1})\\nAktivasyon: ${(node.activation * 100).toFixed(0)}%\\nKullanım: ${node.frequency}x\\nÖnem: ${node.importance || 0}`);\n              foundNode = true;\n              document.body.style.cursor = 'pointer';\n              break;\n            }\n          }\n        }\n      }\n      \n      if (!foundNode) {\n        setSelectedNodeInfo(null);\n        document.body.style.cursor = 'default';\n      }\n    };\n    \n    // Mouse tıklama olayı\n    currentCanvas.onclick = (e: MouseEvent) => {\n      const rect = currentCanvas.getBoundingClientRect();\n      const mouseX = e.clientX - rect.left;\n      const mouseY = e.clientY - rect.top;\n      \n      for (let l = 0; l < userNetworks.length; l++) {\n        // Kullanıcı ağı nodları için kontrol\n        const userStartX = l * layerGap;\n        checkNodeClick(\n          mouseX, mouseY, \n          userNetworks[l], \n          userStartX, 20, \n          nodeSize, gapX, gapY, \n          'user', l, onCellClick,\n          viewMode\n        );\n        \n        // Sistem ağı nodları için kontrol\n        const systemStartX = l * layerGap + ((userNetworks.length) * layerGap);\n        checkNodeClick(\n          mouseX, mouseY, \n          systemNetworks[l], \n          systemStartX, 20, \n          nodeSize, gapX, gapY, \n          'system', l, onCellClick,\n          viewMode\n        );\n      }\n    };\n    \n    // Mouse leave olayı\n    currentCanvas.onmouseleave = () => {\n      setSelectedNodeInfo(null);\n      document.body.style.cursor = 'default';\n    };\n  };\n  \n  // Tıklama olayını işle\n  const checkNodeClick = (\n    mouseX: number, mouseY: number,\n    network: (NetworkNode | null)[][],\n    startX: number, startY: number,\n    nodeSize: number, gapX: number, gapY: number,\n    type: 'user' | 'system', layerIdx: number,\n    callback: Function,\n    viewMode: string\n  ) => {\n    for (let row = 0; row < network.length; row++) {\n      for (let col = 0; col < network[row].length; col++) {\n        const node = network[row][col];\n        if (!node) continue;\n        \n        const x = startX + col * (nodeSize + gapX);\n        const y = startY + row * (nodeSize + gapY);\n        \n        let isClick = false;\n        \n        if (viewMode === '2d') {\n          isClick = mouseX >= x && mouseX <= x + nodeSize && mouseY >= y && mouseY <= y + nodeSize;\n        } else {\n          const centerX = x + nodeSize/2;\n          const centerY = y + nodeSize/2;\n          const distance = Math.sqrt(Math.pow(mouseX - centerX, 2) + Math.pow(mouseY - centerY, 2));\n          isClick = distance <= nodeSize/2;\n        }\n        \n        if (isClick) {\n          callback({\n            ...node,\n            layer: layerIdx,\n            row,\n            col,\n            type\n          });\n        }\n      }\n    }\n  };\n  \n  // Görselleştirmeyi PNG olarak kaydet\n  const saveCanvasAsImage = () => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    \n    // Canvas'ı PNG olarak al\n    const image = canvas.toDataURL('image/png');\n    \n    // İndirme bağlantısı oluştur\n    const link = document.createElement('a');\n    link.href = image;\n    link.download = `sinir-agi-${new Date().toISOString().slice(0,10)}.png`;\n    link.click();\n  };\n  \n  return (\n    <div className=\"neural-network-container rounded-lg shadow-sm bg-white dark:bg-gray-800\" ref={containerRef}>\n      <Tabs defaultValue=\"visualization\" className=\"w-full\">\n        <div className=\"flex flex-col sm:flex-row items-start sm:items-center justify-between p-4 border-b dark:border-gray-700\">\n          <div className=\"flex flex-col mb-3 sm:mb-0\">\n            <h3 className=\"text-base md:text-lg font-semibold text-gray-800 dark:text-gray-200 flex items-center gap-2\">\n              <BrainCircuit className=\"hidden sm:inline\" size={20} />\n              Sinir Ağı Görselleştirmesi\n            </h3>\n            <p className=\"text-xs text-gray-500 dark:text-gray-400 mt-1\">\n              Yapay zeka sisteminin hafıza ve kavram ağı yapısını görselleştirir\n            </p>\n          </div>\n          \n          <TabsList className=\"bg-gray-100 dark:bg-gray-700\">\n            <TabsTrigger value=\"visualization\" className=\"data-[state=active]:bg-white dark:data-[state=active]:bg-gray-800 text-xs\">\n              <Nodes className=\"w-4 h-4 mr-1\" />\n              <span className=\"hidden sm:inline\">Görselleştirme</span>\n            </TabsTrigger>\n            <TabsTrigger value=\"stats\" className=\"data-[state=active]:bg-white dark:data-[state=active]:bg-gray-800 text-xs\">\n              <Cpu className=\"w-4 h-4 mr-1\" />\n              <span className=\"hidden sm:inline\">İstatistikler</span>\n            </TabsTrigger>\n          </TabsList>\n        </div>\n      \n        <TabsContent value=\"visualization\" className=\"pt-0 w-full\">\n          <div className=\"p-2 sm:p-4\">\n            <div className=\"flex flex-wrap gap-2 items-center mb-3 justify-between\">\n              <div className=\"flex flex-wrap gap-2\">\n                <TooltipProvider>\n                  <Tooltip>\n                    <TooltipTrigger asChild>\n                      <Button \n                        variant=\"outline\" \n                        size=\"sm\" \n                        onClick={() => setVisualMode(visualMode === 'relations' ? 'normal' : 'relations' as any)}\n                        className={cn(\n                          \"h-8 text-xs border-gray-200 dark:border-gray-700 shadow-sm glass-morphism\", \n                          visualMode === 'relations' && \"bg-purple-100 dark:bg-purple-900/30 text-purple-700 dark:text-purple-300 border-purple-200 dark:border-purple-800\"\n                        )}\n                      >\n                        {visualMode === 'relations' ? <EyeOff className=\"w-3.5 h-3.5 mr-1\" /> : <Eye className=\"w-3.5 h-3.5 mr-1\" />}\n                        <span className=\"hidden sm:inline\">İlişkiler</span>\n                      </Button>\n                    </TooltipTrigger>\n                    <TooltipContent>İlişkileri {visualMode === 'relations' ? 'Gizle' : 'Göster'}</TooltipContent>\n                  </Tooltip>\n                \n                  <Tooltip>\n                    <TooltipTrigger asChild>\n                      <Button \n                        variant=\"outline\" \n                        size=\"sm\" \n                        onClick={() => setViewMode(viewMode === '2d' ? '3d' : '2d')}\n                        className=\"h-8 text-xs border-gray-200 dark:border-gray-700\"\n                      >\n                        {viewMode === '3d' ? <ArrowLeftRight className=\"w-3.5 h-3.5\" /> : <ArrowRightLeft className=\"w-3.5 h-3.5\" />}\n                      </Button>\n                    </TooltipTrigger>\n                    <TooltipContent>{viewMode === '2d' ? '3D Görünüm' : '2D Görünüm'}</TooltipContent>\n                  </Tooltip>\n                </TooltipProvider>\n                \n                <ToggleGroup type=\"single\" value={highlightMode} onValueChange={(v) => v && setHighlightMode(v as any)}>\n                  <ToggleGroupItem value=\"activation\" size=\"sm\" className=\"h-8 text-xs\">Aktivasyon</ToggleGroupItem>\n                  <ToggleGroupItem value=\"importance\" size=\"sm\" className=\"h-8 text-xs\">Önem</ToggleGroupItem>\n                  <ToggleGroupItem value=\"frequency\" size=\"sm\" className=\"h-8 text-xs\">Kullanım</ToggleGroupItem>\n                </ToggleGroup>\n              </div>\n              \n              <div className=\"flex items-center gap-1\">\n                <TooltipProvider>\n                  <Tooltip>\n                    <TooltipTrigger asChild>\n                      <Button \n                        variant=\"outline\" \n                        size=\"sm\" \n                        onClick={() => setScale(s => Math.min(1.5, s + 0.15))} \n                        className=\"h-8 w-8 p-0\"\n                      >\n                        <ZoomIn className=\"h-3.5 w-3.5\" />\n                      </Button>\n                    </TooltipTrigger>\n                    <TooltipContent>Yakınlaştır</TooltipContent>\n                  </Tooltip>\n                  \n                  <Tooltip>\n                    <TooltipTrigger asChild>\n                      <Button \n                        variant=\"outline\" \n                        size=\"sm\" \n                        onClick={() => setScale(s => Math.max(0.5, s - 0.15))} \n                        className=\"h-8 w-8 p-0\"\n                      >\n                        <ZoomOut className=\"h-3.5 w-3.5\" />\n                      </Button>\n                    </TooltipTrigger>\n                    <TooltipContent>Uzaklaştır</TooltipContent>\n                  </Tooltip>\n                  \n                  <Tooltip>\n                    <TooltipTrigger asChild>\n                      <Button \n                        variant=\"outline\" \n                        size=\"sm\" \n                        onClick={onReset} \n                        className=\"h-8 w-8 p-0\"\n                      >\n                        <RefreshCw className=\"h-3.5 w-3.5\" />\n                      </Button>\n                    </TooltipTrigger>\n                    <TooltipContent>Sıfırla</TooltipContent>\n                  </Tooltip>\n                  \n                  <Tooltip>\n                    <TooltipTrigger asChild>\n                      <Button \n                        variant=\"outline\" \n                        size=\"sm\" \n                        onClick={saveCanvasAsImage} \n                        className=\"h-8 w-8 p-0\"\n                      >\n                        <Save className=\"h-3.5 w-3.5\" />\n                      </Button>\n                    </TooltipTrigger>\n                    <TooltipContent>PNG Olarak Kaydet</TooltipContent>\n                  </Tooltip>\n                </TooltipProvider>\n              </div>\n            </div>\n            \n            <div className=\"flex flex-wrap justify-center gap-2 mb-3 text-xs text-gray-600 dark:text-gray-400\">\n              <div className=\"flex items-center gap-1\">\n                <div className=\"w-3 h-3 rounded-full\" style={{ backgroundColor: getColors().userNodeColor }}></div>\n                <span>Kullanıcı Ağı</span>\n              </div>\n              <div className=\"flex items-center gap-1\">\n                <div className=\"w-3 h-3 rounded-full\" style={{ backgroundColor: getColors().systemNodeColor }}></div>\n                <span>Sistem Ağı</span>\n              </div>\n              <div className=\"flex items-center gap-1\">\n                <div className=\"w-3 h-3 rounded-full\" style={{ backgroundColor: getColors().activatedNodeColor }}></div>\n                <span>Aktif Düğüm</span>\n              </div>\n              {visualMode === 'relations' && (\n                <div className=\"flex items-center gap-1\">\n                  <div className=\"w-3 h-3 rounded-full\" style={{ backgroundColor: getColors().connectionColor }}></div>\n                  <span>İlişki Bağlantısı</span>\n                </div>\n              )}\n            </div>\n          \n            <div className=\"w-full overflow-x-auto\">\n              {selectedNodeInfo && (\n                <div className=\"absolute z-10 bg-white dark:bg-gray-800 text-xs p-2 rounded shadow-md border border-gray-200 dark:border-gray-700 pointer-events-none\">\n                  {selectedNodeInfo.split('\\n').map((line, i) => (\n                    <div key={i}>{line}</div>\n                  ))}\n                </div>\n              )}\n              \n              <div className=\"min-w-[600px]\">\n                <canvas \n                  ref={canvasRef} \n                  style={{ maxWidth: '100%', height: 'auto' }}\n                  className=\"border border-gray-200 dark:border-gray-700 rounded-lg\"\n                ></canvas>\n              </div>\n            </div>\n          </div>\n        </TabsContent>\n      \n        <TabsContent value=\"stats\" className=\"pt-0 w-full\">\n          <div className=\"p-4\">\n            <div className=\"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 mb-4\">\n              <div className=\"bg-gray-50 dark:bg-gray-900 rounded p-3 border border-gray-200 dark:border-gray-700\">\n                <h4 className=\"text-xs font-medium text-gray-500 dark:text-gray-400 mb-1\">TOPLAM DÜĞÜM SAYISI</h4>\n                <div className=\"flex justify-between items-center\">\n                  <span className=\"text-2xl font-bold text-gray-800 dark:text-gray-200\">\n                    {userNetworks.flat().flat().filter(Boolean).length + systemNetworks.flat().flat().filter(Boolean).length}\n                  </span>\n                  <Nodes className=\"w-8 h-8 text-indigo-500 dark:text-indigo-400 opacity-70\" />\n                </div>\n              </div>\n              \n              <div className=\"bg-gray-50 dark:bg-gray-900 rounded p-3 border border-gray-200 dark:border-gray-700\">\n                <h4 className=\"text-xs font-medium text-gray-500 dark:text-gray-400 mb-1\">İLİŞKİ SAYISI</h4>\n                <div className=\"flex justify-between items-center\">\n                  <span className=\"text-2xl font-bold text-gray-800 dark:text-gray-200\">\n                    {relations.length}\n                  </span>\n                  <ArrowRightLeft className=\"w-8 h-8 text-purple-500 dark:text-purple-400 opacity-70\" />\n                </div>\n              </div>\n              \n              <div className=\"bg-gray-50 dark:bg-gray-900 rounded p-3 border border-gray-200 dark:border-gray-700\">\n                <h4 className=\"text-xs font-medium text-gray-500 dark:text-gray-400 mb-1\">KATMAN SAYISI</h4>\n                <div className=\"flex justify-between items-center\">\n                  <span className=\"text-2xl font-bold text-gray-800 dark:text-gray-200\">\n                    {networkLayers}\n                  </span>\n                  <Cpu className=\"w-8 h-8 text-green-500 dark:text-green-400 opacity-70\" />\n                </div>\n              </div>\n              \n              <div className=\"bg-gray-50 dark:bg-gray-900 rounded p-3 border border-gray-200 dark:border-gray-700\">\n                <h4 className=\"text-xs font-medium text-gray-500 dark:text-gray-400 mb-1\">ÇİFT YÖNLÜ İLİŞKİLER</h4>\n                <div className=\"flex justify-between items-center\">\n                  <span className=\"text-2xl font-bold text-gray-800 dark:text-gray-200\">\n                    {relations.filter(r => r.bidirectional).length}\n                  </span>\n                  <RotateCw className=\"w-8 h-8 text-amber-500 dark:text-amber-400 opacity-70\" />\n                </div>\n              </div>\n            </div>\n            \n            <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n              <div className=\"bg-gray-50 dark:bg-gray-900 rounded p-3 border border-gray-200 dark:border-gray-700\">\n                <h4 className=\"text-xs font-medium text-gray-500 dark:text-gray-400 mb-3\">EN ÇOK KULLANILAN DÜĞÜMLER</h4>\n                <div className=\"space-y-2\">\n                  {[...userNetworks.flat().flat(), ...systemNetworks.flat().flat()]\n                    .filter(Boolean)\n                    .sort((a, b) => (b?.frequency || 0) - (a?.frequency || 0))\n                    .slice(0, 5)\n                    .map((node, i) => node && (\n                      <div key={i} className=\"flex items-center\">\n                        <div className=\"w-2 h-2 rounded-full bg-indigo-500 mr-2\"></div>\n                        <div className=\"flex-1\">\n                          <div className=\"flex justify-between text-xs mb-1\">\n                            <span className=\"font-medium text-gray-700 dark:text-gray-300\">{node.word}</span>\n                            <span className=\"text-gray-500 dark:text-gray-400\">{node.frequency}x</span>\n                          </div>\n                          <div className=\"w-full bg-gray-200 dark:bg-gray-700 rounded-full h-1.5\">\n                            <div className=\"bg-indigo-500 h-1.5 rounded-full\" style={{ width: `${Math.min(100, node.frequency * 5)}%` }}></div>\n                          </div>\n                        </div>\n                      </div>\n                    )) || Array(5).fill(0).map((_, i) => (\n                      <div key={i}>\n                        <Skeleton className=\"h-6 w-full\" />\n                      </div>\n                    ))}\n                </div>\n              </div>\n              \n              <div className=\"bg-gray-50 dark:bg-gray-900 rounded p-3 border border-gray-200 dark:border-gray-700\">\n                <h4 className=\"text-xs font-medium text-gray-500 dark:text-gray-400 mb-3\">EN GÜÇLÜ İLİŞKİLER</h4>\n                <div className=\"space-y-2\">\n                  {relations\n                    .sort((a, b) => (b.strength) - (a.strength))\n                    .slice(0, 5)\n                    .map((relation, i) => (\n                      <div key={i} className=\"flex items-center\">\n                        <div className=\"w-2 h-2 rounded-full bg-purple-500 mr-2\"></div>\n                        <div className=\"flex-1\">\n                          <div className=\"flex justify-between text-xs mb-1\">\n                            <span className=\"font-medium text-gray-700 dark:text-gray-300\">\n                              {relation.userWord} → {relation.systemWord}\n                            </span>\n                            <span className=\"text-gray-500 dark:text-gray-400\">{relation.strength.toFixed(0)}%</span>\n                          </div>\n                          <div className=\"w-full bg-gray-200 dark:bg-gray-700 rounded-full h-1.5\">\n                            <div className=\"bg-purple-500 h-1.5 rounded-full\" style={{ width: `${relation.strength}%` }}></div>\n                          </div>\n                        </div>\n                      </div>\n                    ))}\n                </div>\n              </div>\n            </div>\n          </div>\n        </TabsContent>\n      </Tabs>\n    </div>\n  );\n};\n\nexport default NeuralNetworkVisualization;\n","size_bytes":37977},"attached_assets/ThemeContext.tsx":{"content":"import React, { createContext, useState, useContext, useEffect } from 'react';\n\ninterface ThemeContextType {\n  isDarkMode: boolean;\n  toggleTheme: () => void;\n}\n\nconst ThemeContext = createContext<ThemeContextType>({\n  isDarkMode: false,\n  toggleTheme: () => {},\n});\n\nexport const useTheme = () => useContext(ThemeContext);\n\nexport const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  // Kullanıcının sistem teması tercihini kontrol et\n  const prefersDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;\n  \n  // Başlangıç temasını localStorage'dan al veya sistem tercihini kullan\n  const [isDarkMode, setIsDarkMode] = useState<boolean>(() => {\n    const savedTheme = localStorage.getItem('theme');\n    return savedTheme ? savedTheme === 'dark' : prefersDarkMode;\n  });\n\n  // Tema değiştiğinde localStorage'a kaydet ve DOM'u güncelle\n  useEffect(() => {\n    localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');\n    \n    if (isDarkMode) {\n      document.documentElement.classList.add('dark');\n      document.documentElement.style.colorScheme = 'dark';\n    } else {\n      document.documentElement.classList.remove('dark');\n      document.documentElement.style.colorScheme = 'light';\n    }\n  }, [isDarkMode]);\n\n  // Sistem teması değişirse onu takip et\n  useEffect(() => {\n    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');\n    \n    const handleChange = (e: MediaQueryListEvent) => {\n      const savedTheme = localStorage.getItem('theme');\n      if (!savedTheme) {\n        setIsDarkMode(e.matches);\n      }\n    };\n    \n    mediaQuery.addEventListener('change', handleChange);\n    \n    return () => mediaQuery.removeEventListener('change', handleChange);\n  }, []);\n\n  // Tema değiştirme fonksiyonu\n  const toggleTheme = () => {\n    setIsDarkMode(prev => !prev);\n  };\n\n  return (\n    <ThemeContext.Provider value={{ isDarkMode, toggleTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n};\n","size_bytes":2012},"attached_assets/use-mobile.tsx":{"content":"import { useState, useEffect } from 'react';\n\n// Mobil cihazlar için ekran boyutu kontrolü yapan hook\nexport function useIsMobile(): boolean {\n  const [isMobile, setIsMobile] = useState(false);\n\n  useEffect(() => {\n    function handleResize() {\n      setIsMobile(window.innerWidth < 768); // 768px altı mobil olarak kabul edilir (Tailwind md breakpoint)\n    }\n\n    // İlk yükleme kontrolü\n    handleResize();\n    \n    // Ekran boyutu değiştiğinde kontrol\n    window.addEventListener('resize', handleResize);\n    \n    // Temizleme fonksiyonu\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  return isMobile;\n}\n","size_bytes":651},"server/db.ts":{"content":"import { Pool, neonConfig } from '@neondatabase/serverless';\nimport { drizzle } from 'drizzle-orm/neon-serverless';\nimport ws from \"ws\";\nimport * as schema from \"@shared/schema\";\n\nneonConfig.webSocketConstructor = ws;\n\nif (!process.env.DATABASE_URL) {\n  throw new Error(\n    \"DATABASE_URL must be set. Did you forget to provision a database?\",\n  );\n}\n\nexport const pool = new Pool({ connectionString: process.env.DATABASE_URL });\nexport const db = drizzle({ client: pool, schema });\n","size_bytes":483},"server/index.ts":{"content":"import express, { type Request, Response, NextFunction } from \"express\";\nimport { registerRoutes } from \"./routes\";\nimport { setupVite, serveStatic, log } from \"./vite\";\n\nconst app = express();\napp.use(express.json());\napp.use(express.urlencoded({ extended: false }));\n\napp.use((req, res, next) => {\n  const start = Date.now();\n  const path = req.path;\n  let capturedJsonResponse: Record<string, any> | undefined = undefined;\n\n  const originalResJson = res.json;\n  res.json = function (bodyJson, ...args) {\n    capturedJsonResponse = bodyJson;\n    return originalResJson.apply(res, [bodyJson, ...args]);\n  };\n\n  res.on(\"finish\", () => {\n    const duration = Date.now() - start;\n    if (path.startsWith(\"/api\")) {\n      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;\n      if (capturedJsonResponse) {\n        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;\n      }\n\n      if (logLine.length > 80) {\n        logLine = logLine.slice(0, 79) + \"…\";\n      }\n\n      log(logLine);\n    }\n  });\n\n  next();\n});\n\n(async () => {\n  const server = await registerRoutes(app);\n\n  app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {\n    const status = err.status || err.statusCode || 500;\n    const message = err.message || \"Internal Server Error\";\n\n    res.status(status).json({ message });\n    throw err;\n  });\n\n  // importantly only setup vite in development and after\n  // setting up all the other routes so the catch-all route\n  // doesn't interfere with the other routes\n  if (app.get(\"env\") === \"development\") {\n    await setupVite(app, server);\n  } else {\n    serveStatic(app);\n  }\n\n  // ALWAYS serve the app on port 5000\n  // this serves both the API and the client.\n  // It is the only port that is not firewalled.\n  const port = 5000;\n  server.listen({\n    port,\n    host: \"0.0.0.0\",\n    reusePort: true,\n  }, () => {\n    log(`serving on port ${port}`);\n  });\n})();\n","size_bytes":1921},"server/routes.ts":{"content":"import type { Express } from \"express\";\nimport { createServer, type Server } from \"http\";\nimport { WebSocketServer } from \"ws\";\nimport { storage } from \"./storage\";\nimport { EnhancedMemorySystem } from \"../client/src/lib/EnhancedMemorySystem\";\n\ninterface MessageRequest {\n  message: string;\n}\n\ninterface TrainingRequest {\n  input: string;\n  output: string;\n}\n\nexport async function registerRoutes(app: Express): Promise<Server> {\n  // Initialize memory system for server-side processing (optional)\n  const memorySystem = new EnhancedMemorySystem();\n\n  // API endpoint to process a message\n  app.post('/api/chat', async (req, res) => {\n    try {\n      const { message } = req.body as MessageRequest;\n      \n      if (!message || typeof message !== 'string') {\n        return res.status(400).json({ \n          success: false, \n          error: 'Geçerli bir mesaj göndermelisiniz' \n        });\n      }\n\n      // Add to memory system\n      memorySystem.addMemory(message, 'short-term');\n      \n      // Generate questions and answers from the message\n      memorySystem.extractAndLearnFromText(message);\n      \n      // Get relevant memories\n      const contextualMemories = memorySystem.getContextualMemories(message);\n\n      return res.json({\n        success: true,\n        contextualMemories,\n        memoryStats: {\n          shortTermCount: memorySystem.shortTerm.length,\n          longTermCount: memorySystem.longTerm.length,\n          clustersCount: memorySystem.memoryClusters.length\n        }\n      });\n    } catch (error) {\n      console.error('Error processing message:', error);\n      return res.status(500).json({ \n        success: false, \n        error: 'Mesaj işlenirken bir hata oluştu' \n      });\n    }\n  });\n\n  // API endpoint to train the memory system\n  app.post('/api/train', async (req, res) => {\n    try {\n      const { input, output } = req.body as TrainingRequest;\n      \n      if (!input || !output || typeof input !== 'string' || typeof output !== 'string') {\n        return res.status(400).json({ \n          success: false, \n          error: 'Geçerli eğitim verileri göndermelisiniz' \n        });\n      }\n\n      // Add to memory system\n      memorySystem.addMemory(input, 'short-term');\n      memorySystem.addMemory(output, 'long-term', [], input);\n      \n      // Generate questions and answers\n      memorySystem.extractAndLearnFromText(input);\n      memorySystem.extractAndLearnFromText(output);\n\n      return res.json({\n        success: true,\n        memoryStats: {\n          shortTermCount: memorySystem.shortTerm.length,\n          longTermCount: memorySystem.longTerm.length,\n          clustersCount: memorySystem.memoryClusters.length\n        }\n      });\n    } catch (error) {\n      console.error('Error training system:', error);\n      return res.status(500).json({ \n        success: false, \n        error: 'Eğitim sırasında bir hata oluştu' \n      });\n    }\n  });\n\n  // API endpoint to get memory system statistics\n  app.get('/api/memory-stats', (req, res) => {\n    try {\n      return res.json({\n        success: true,\n        stats: {\n          shortTermCount: memorySystem.shortTerm.length,\n          longTermCount: memorySystem.longTerm.length,\n          clustersCount: memorySystem.memoryClusters.length\n        }\n      });\n    } catch (error) {\n      console.error('Error getting memory stats:', error);\n      return res.status(500).json({ \n        success: false, \n        error: 'Bellek istatistikleri alınırken bir hata oluştu' \n      });\n    }\n  });\n\n  // Create HTTP server\n  const httpServer = createServer(app);\n\n  // Setup WebSocket on same HTTP server to avoid port conflicts\n  // WebSocket path is different from Vite's HMR WebSocket to avoid conflicts\n  const wss = new WebSocketServer({ server: httpServer, path: '/ws' });\n  console.log('WebSocket server attached to HTTP server on path /ws');\n\n  wss.on('connection', (ws) => {\n    console.log('WebSocket client connected');\n    \n    ws.on('message', (message) => {\n      try {\n        const data = JSON.parse(message.toString());\n        \n        // Handle different message types\n        if (data.type === 'chat') {\n          // Process chat message\n          memorySystem.extractAndLearnFromText(data.message);\n          \n          // Send back success message\n          ws.send(JSON.stringify({\n            type: 'message_processed',\n            success: true\n          }));\n        }\n        else if (data.type === 'train') {\n          // Train system with provided data\n          memorySystem.addMemory(data.input, 'short-term');\n          memorySystem.addMemory(data.output, 'long-term', [], data.input);\n          \n          // Notify client of successful training\n          ws.send(JSON.stringify({\n            type: 'training_complete',\n            success: true\n          }));\n        }\n      } catch (error) {\n        console.error('WebSocket message error:', error);\n        ws.send(JSON.stringify({\n          type: 'error',\n          message: 'İşlem sırasında bir hata oluştu'\n        }));\n      }\n    });\n    \n    ws.on('close', () => {\n      console.log('WebSocket client disconnected');\n    });\n  });\n\n  return httpServer;\n}\n","size_bytes":5160},"server/storage.ts":{"content":"import { users, type User, type InsertUser } from \"@shared/schema\";\nimport { EnhancedMemorySystem, Memory, MemoryCluster } from \"../client/src/lib/EnhancedMemorySystem\";\nimport { \n  NetworkNode, \n  Relation, \n  TrainingPair \n} from \"../client/src/lib/NeuralNetworkUtils\";\n\n// Modify the interface with CRUD methods for our neural network application\nexport interface IStorage {\n  // User CRUD operations\n  getUser(id: number): Promise<User | undefined>;\n  getUserByUsername(username: string): Promise<User | undefined>;\n  createUser(user: InsertUser): Promise<User>;\n  \n  // Neural network operations\n  saveUserNetworks(networks: (NetworkNode | null)[][][]): Promise<void>;\n  getUserNetworks(): Promise<(NetworkNode | null)[][][] | null>;\n  saveSystemNetworks(networks: (NetworkNode | null)[][][]): Promise<void>;\n  getSystemNetworks(): Promise<(NetworkNode | null)[][][] | null>;\n  \n  // Relations operations\n  saveRelations(relations: Relation[]): Promise<void>;\n  getRelations(): Promise<Relation[] | null>;\n  saveBidirectionalRelations(relations: Relation[]): Promise<void>;\n  getBidirectionalRelations(): Promise<Relation[] | null>;\n  \n  // Memory system operations\n  saveMemories(shortTerm: Memory[], longTerm: Memory[], clusters: MemoryCluster[]): Promise<void>;\n  getMemories(): Promise<{ shortTerm: Memory[]; longTerm: Memory[]; clusters: MemoryCluster[] } | null>;\n  \n  // Training history operations\n  saveTrainingHistory(history: TrainingPair[]): Promise<void>;\n  getTrainingHistory(): Promise<TrainingPair[] | null>;\n}\n\nexport class MemStorage implements IStorage {\n  private users: Map<number, User>;\n  private userNetworks: (NetworkNode | null)[][][] | null = null;\n  private systemNetworks: (NetworkNode | null)[][][] | null = null;\n  private relations: Relation[] | null = null;\n  private bidirectionalRelations: Relation[] | null = null;\n  private shortTermMemories: Memory[] = [];\n  private longTermMemories: Memory[] = [];\n  private memoryClusters: MemoryCluster[] = [];\n  private trainingHistory: TrainingPair[] = [];\n  currentId: number;\n\n  constructor() {\n    this.users = new Map();\n    this.currentId = 1;\n  }\n\n  // User CRUD operations\n  async getUser(id: number): Promise<User | undefined> {\n    return this.users.get(id);\n  }\n\n  async getUserByUsername(username: string): Promise<User | undefined> {\n    return Array.from(this.users.values()).find(\n      (user) => user.username === username,\n    );\n  }\n\n  async createUser(insertUser: InsertUser): Promise<User> {\n    const id = this.currentId++;\n    const user: User = { ...insertUser, id };\n    this.users.set(id, user);\n    return user;\n  }\n\n  // Neural network operations\n  async saveUserNetworks(networks: (NetworkNode | null)[][][]): Promise<void> {\n    this.userNetworks = JSON.parse(JSON.stringify(networks));\n  }\n\n  async getUserNetworks(): Promise<(NetworkNode | null)[][][] | null> {\n    return this.userNetworks ? JSON.parse(JSON.stringify(this.userNetworks)) : null;\n  }\n\n  async saveSystemNetworks(networks: (NetworkNode | null)[][][]): Promise<void> {\n    this.systemNetworks = JSON.parse(JSON.stringify(networks));\n  }\n\n  async getSystemNetworks(): Promise<(NetworkNode | null)[][][] | null> {\n    return this.systemNetworks ? JSON.parse(JSON.stringify(this.systemNetworks)) : null;\n  }\n\n  // Relations operations\n  async saveRelations(relations: Relation[]): Promise<void> {\n    this.relations = JSON.parse(JSON.stringify(relations));\n  }\n\n  async getRelations(): Promise<Relation[] | null> {\n    return this.relations ? JSON.parse(JSON.stringify(this.relations)) : null;\n  }\n\n  async saveBidirectionalRelations(relations: Relation[]): Promise<void> {\n    this.bidirectionalRelations = JSON.parse(JSON.stringify(relations));\n  }\n\n  async getBidirectionalRelations(): Promise<Relation[] | null> {\n    return this.bidirectionalRelations ? JSON.parse(JSON.stringify(this.bidirectionalRelations)) : null;\n  }\n\n  // Memory system operations\n  async saveMemories(shortTerm: Memory[], longTerm: Memory[], clusters: MemoryCluster[]): Promise<void> {\n    this.shortTermMemories = JSON.parse(JSON.stringify(shortTerm));\n    this.longTermMemories = JSON.parse(JSON.stringify(longTerm));\n    this.memoryClusters = JSON.parse(JSON.stringify(clusters));\n  }\n\n  async getMemories(): Promise<{ shortTerm: Memory[]; longTerm: Memory[]; clusters: MemoryCluster[] } | null> {\n    return {\n      shortTerm: JSON.parse(JSON.stringify(this.shortTermMemories)),\n      longTerm: JSON.parse(JSON.stringify(this.longTermMemories)),\n      clusters: JSON.parse(JSON.stringify(this.memoryClusters))\n    };\n  }\n\n  // Training history operations\n  async saveTrainingHistory(history: TrainingPair[]): Promise<void> {\n    this.trainingHistory = JSON.parse(JSON.stringify(history));\n  }\n\n  async getTrainingHistory(): Promise<TrainingPair[] | null> {\n    return this.trainingHistory.length > 0 ? JSON.parse(JSON.stringify(this.trainingHistory)) : null;\n  }\n}\n\n// Create and export a singleton instance\nexport const storage = new MemStorage();\n","size_bytes":5005},"server/vite.ts":{"content":"import express, { type Express } from \"express\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport { createServer as createViteServer, createLogger } from \"vite\";\nimport { type Server } from \"http\";\nimport viteConfig from \"../vite.config\";\nimport { nanoid } from \"nanoid\";\n\nconst viteLogger = createLogger();\n\nexport function log(message: string, source = \"express\") {\n  const formattedTime = new Date().toLocaleTimeString(\"en-US\", {\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    second: \"2-digit\",\n    hour12: true,\n  });\n\n  console.log(`${formattedTime} [${source}] ${message}`);\n}\n\nexport async function setupVite(app: Express, server: Server) {\n  const serverOptions = {\n    middlewareMode: true,\n    hmr: { server },\n    allowedHosts: true,\n  };\n\n  const vite = await createViteServer({\n    ...viteConfig,\n    configFile: false,\n    customLogger: {\n      ...viteLogger,\n      error: (msg, options) => {\n        viteLogger.error(msg, options);\n        process.exit(1);\n      },\n    },\n    server: serverOptions,\n    appType: \"custom\",\n  });\n\n  app.use(vite.middlewares);\n  app.use(\"*\", async (req, res, next) => {\n    const url = req.originalUrl;\n\n    try {\n      const clientTemplate = path.resolve(\n        import.meta.dirname,\n        \"..\",\n        \"client\",\n        \"index.html\",\n      );\n\n      // always reload the index.html file from disk incase it changes\n      let template = await fs.promises.readFile(clientTemplate, \"utf-8\");\n      template = template.replace(\n        `src=\"/src/main.tsx\"`,\n        `src=\"/src/main.tsx?v=${nanoid()}\"`,\n      );\n      const page = await vite.transformIndexHtml(url, template);\n      res.status(200).set({ \"Content-Type\": \"text/html\" }).end(page);\n    } catch (e) {\n      vite.ssrFixStacktrace(e as Error);\n      next(e);\n    }\n  });\n}\n\nexport function serveStatic(app: Express) {\n  const distPath = path.resolve(import.meta.dirname, \"public\");\n\n  if (!fs.existsSync(distPath)) {\n    throw new Error(\n      `Could not find the build directory: ${distPath}, make sure to build the client first`,\n    );\n  }\n\n  app.use(express.static(distPath));\n\n  // fall through to index.html if the file doesn't exist\n  app.use(\"*\", (_req, res) => {\n    res.sendFile(path.resolve(distPath, \"index.html\"));\n  });\n}\n","size_bytes":2254},"shared/schema.ts":{"content":"import { pgTable, text, serial, integer, boolean } from \"drizzle-orm/pg-core\";\nimport { createInsertSchema } from \"drizzle-zod\";\nimport { z } from \"zod\";\n\nexport const users = pgTable(\"users\", {\n  id: serial(\"id\").primaryKey(),\n  username: text(\"username\").notNull().unique(),\n  password: text(\"password\").notNull(),\n});\n\nexport const insertUserSchema = createInsertSchema(users).pick({\n  username: true,\n  password: true,\n});\n\nexport type InsertUser = z.infer<typeof insertUserSchema>;\nexport type User = typeof users.$inferSelect;\n\n// Message types\nexport interface Message {\n  id: string;\n  content: string;\n  isUser: boolean;\n  timestamp: number;\n  feedback?: number; // -1: negatif, 0: nötr, 1: pozitif\n  module?: 'info' | 'humor' | 'advice' | 'feedback' | 'learning_request'; // Modül tipi\n  isSpoken?: boolean; // Sesli yanıt verildi mi\n  analysis?: any;\n  confidence?: number;\n  reasoning?: string[];\n}\n\n// Training types\nexport interface TrainingPair {\n  input: string;\n  output: string;\n  timestamp?: number;\n}\n","size_bytes":1024},"client/src/App.tsx":{"content":"import { useState, useEffect, useRef, useCallback } from \"react\";\n\n// Web Speech API polyfill\ndeclare global {\n  interface Window {\n    SpeechRecognition: any;\n    webkitSpeechRecognition: any;\n    mozSpeechRecognition: any;\n    msSpeechRecognition: any;\n    oSpeechRecognition: any;\n  }\n}\n\n// Web Speech API types\ninterface SpeechRecognition extends EventTarget {\n  continuous: boolean;\n  interimResults: boolean;\n  lang: string;\n  start: () => void;\n  stop: () => void;\n  abort: () => void;\n  onresult: (event: SpeechRecognitionEvent) => void;\n  onerror: (event: SpeechRecognitionErrorEvent) => void;\n  onend: () => void;\n}\n\ninterface SpeechRecognitionEvent {\n  results: SpeechRecognitionResultList;\n  resultIndex: number;\n}\n\ninterface SpeechRecognitionResultList {\n  readonly length: number;\n  item(index: number): SpeechRecognitionResult;\n  [index: number]: SpeechRecognitionResult;\n}\n\ninterface SpeechRecognitionResult {\n  readonly length: number;\n  item(index: number): SpeechRecognitionAlternative;\n  [index: number]: SpeechRecognitionAlternative;\n  isFinal: boolean;\n}\n\ninterface SpeechRecognitionAlternative {\n  transcript: string;\n  confidence: number;\n}\n\ninterface SpeechRecognitionErrorEvent extends Event {\n  error: string;\n  message: string;\n}\n\nimport { useTheme } from './contexts/ThemeContext';\nimport { useIsMobile } from './hooks/use-mobile';\nimport { useToast } from './contexts/ToastContext';\nimport { useNeuralNetwork } from './hooks/use-neural-network';\nimport { EnhancedMemorySystem } from './lib/EnhancedMemorySystem';\nimport { AdvancedAI } from './lib/AdvancedAI';\nimport { SemanticAnalyzer } from './lib/SemanticAnalyzer';\nimport { TrainingDataAnalyzer } from './lib/TrainingDataAnalyzer';\nimport { NetworkNode, addCellsToNetwork, removeCellsFromNetwork } from './lib/NeuralNetworkUtils';\nimport { v4 as uuidv4 } from 'uuid';\nimport { Message, TrainingPair } from '@shared/schema';\n\n// Components\nimport Header from './components/Header';\nimport ChatPanel from './components/ChatPanel';\nimport NeuralNetworkPanel from './components/NeuralNetworkPanel';\nimport MemoryPanel from './components/MemoryPanel';\nimport CorrectAnswerModal from './components/CorrectAnswerModal';\nimport BatchTrainingModal from './components/BatchTrainingModal';\nimport CellDetailsModal from './components/CellDetailsModal';\nimport { TurkishDictionaryPanel } from './components/TurkishDictionaryPanel';\nimport { AIStatusPanel } from './components/AIStatusPanel';\n\n// Types for local use\ninterface LocalTrainingData {\n  userInput: string;\n  systemOutput: string;\n  confidence?: number;\n  category?: string;\n  contextualInfo?: {\n    entities?: string[];\n    keywords?: string[];\n  };\n  timestamp?: number;\n}\n\nexport default function App(): JSX.Element {\n  // Theme hooks\n  const isMobile = useIsMobile();\n  \n  // Theme context\n  let isDarkMode = false;\n  try {\n    const themeContext = useTheme();\n    isDarkMode = themeContext.isDarkMode;\n  } catch (error) {\n    console.error('Tema context hatası:', error);\n    if (typeof window !== 'undefined' && window.localStorage) {\n      const saved = localStorage.getItem('theme');\n      isDarkMode = saved === 'dark';\n    }\n  }\n  \n  const { addToast } = useToast();\n\n  // Neural Network Hook\n  const {\n    userNetworks,\n    systemNetworks,\n    relations,\n    bidirectionalRelations,\n    trainNetwork,\n    batchTrainNetworkItems,\n    processUserInput,\n    refreshNetwork,\n    getNetworkStats,\n    activatedNodes\n  } = useNeuralNetwork();\n\n  // State for messages\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [originalQuestion, setOriginalQuestion] = useState<string>(\"\");\n  const [trainHistory, setTrainHistory] = useState<LocalTrainingData[]>([]);\n\n  // AI and Memory Systems\n  const [advancedAI] = useState(() => new AdvancedAI());\n  const [memorySystem] = useState(() => new EnhancedMemorySystem());\n  const memorySystemRef = useRef(memorySystem);\n  const [semanticAnalyzer] = useState(() => new SemanticAnalyzer(null, memorySystem));\n  const [trainingAnalyzer] = useState(() => new TrainingDataAnalyzer(null, memorySystem));\n  \n  // UI State\n  const [activeTab, setActiveTab] = useState<'chat' | 'neural' | 'sozluk'>('chat');\n  const [showMemory, setShowMemory] = useState(false);\n  const [showCorrectAnswer, setShowCorrectAnswer] = useState(false);\n  const [showBatchTraining, setShowBatchTraining] = useState(false);\n  const [showCellDetails, setShowCellDetails] = useState(false);\n  const [showAIStatus, setShowAIStatus] = useState(false);\n  const [currentQuestion, setCurrentQuestion] = useState<string>(\"\");\n  const [selectedCell, setSelectedCell] = useState<NetworkNode | null>(null);\n  const [trainingProgress, setTrainingProgress] = useState(0);\n  const [isVoiceEnabled, setIsVoiceEnabled] = useState(false);\n\n  // Get network stats\n  const stats = getNetworkStats();\n\n  // Initialize memory system\n  useEffect(() => {\n    memorySystemRef.current = memorySystem;\n  }, [memorySystem]);\n\n  // Load training history from localStorage\n  useEffect(() => {\n    try {\n      const saved = localStorage.getItem('neural_training_history');\n      if (saved) {\n        const parsed = JSON.parse(saved);\n        setTrainHistory(Array.isArray(parsed) ? parsed : []);\n      }\n    } catch (error) {\n      console.error('Training history yüklenirken hata:', error);\n    }\n  }, []);\n\n  // Voice recognition setup\n  const toggleVoice = useCallback(() => {\n    setIsVoiceEnabled(prev => !prev);\n    addToast(\n      isVoiceEnabled ? 'Ses tanıma devre dışı' : 'Ses tanıma aktif',\n      isVoiceEnabled ? 'warning' : 'success'\n    );\n  }, [isVoiceEnabled, addToast]);\n\n  // Handle sending messages\n  const handleSendMessage = async (messageText: string) => {\n    if (!messageText.trim() || isProcessing) return;\n\n    setIsProcessing(true);\n\n    // Add user message\n    const userMessage: Message = {\n      id: uuidv4(),\n      content: messageText,\n      isUser: true,\n      timestamp: Date.now()\n    };\n\n    setMessages(prev => [...prev, userMessage]);\n\n    try {\n      // Process with neural network\n      const result = await processUserInput(messageText);\n      \n      // Check if response is a modal trigger\n      if (result.response === 'MODAL_TRIGGER_UNKNOWN') {\n        setCurrentQuestion(messageText);\n        setShowCorrectAnswer(true);\n        return; // Don't show the modal trigger as a message\n      }\n\n      // Generate AI response\n      const aiResponse: Message = {\n        id: uuidv4(),\n        content: result.response || \"Üzgünüm, bu konuda size yardımcı olamam. Beni eğitebilir misiniz?\",\n        isUser: false,\n        timestamp: Date.now() + 1,\n        confidence: result.confidence,\n        module: result.confidence > 0.7 ? 'info' : 'learning_request'\n      };\n\n      setMessages(prev => [...prev, aiResponse]);\n\n      // If confidence is very low, show learning modal\n      if (result.confidence < 0.3) {\n        setCurrentQuestion(messageText);\n        setShowCorrectAnswer(true);\n      }\n\n    } catch (error) {\n      console.error('Mesaj işleme hatası:', error);\n      \n      const errorMessage: Message = {\n        id: uuidv4(),\n        content: \"Bir hata oluştu. Lütfen tekrar deneyin.\",\n        isUser: false,\n        timestamp: Date.now() + 1,\n        module: 'feedback'\n      };\n\n      setMessages(prev => [...prev, errorMessage]);\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n\n  // Handle learning from user\n  const handleSendMessageWithLearning = async (messageText: string): Promise<boolean> => {\n    if (!messageText.startsWith('[CEVAP]')) {\n      return false;\n    }\n\n    try {\n      const answer = messageText.replace('[CEVAP]', '').trim();\n      const pendingQuestion = localStorage.getItem('pending_question');\n      \n      if (pendingQuestion && answer) {\n        // Train the network\n        await trainNetwork(pendingQuestion, answer);\n        \n        // Save to training history\n        const newTraining: LocalTrainingData = {\n          userInput: pendingQuestion,\n          systemOutput: answer,\n          confidence: 1.0,\n          timestamp: Date.now()\n        };\n        \n        setTrainHistory(prev => {\n          const updated = [...prev, newTraining];\n          localStorage.setItem('neural_training_history', JSON.stringify(updated));\n          return updated;\n        });\n\n        // Add success message\n        const thankYouMessage: Message = {\n          id: uuidv4(),\n          content: `✅ Öğrendim! Teşekkür ederim!\\n\\n❓ **Soru:** \"${pendingQuestion}\"\\n💡 **Cevap:** \"${answer}\"\\n\\n🧠 Bu bilgiyi belleğime kaydettim!`,\n          isUser: false,\n          timestamp: Date.now(),\n          module: 'info'\n        };\n\n        setMessages(prev => [...prev, thankYouMessage]);\n        localStorage.removeItem('pending_question');\n        \n        return true;\n      }\n    } catch (error) {\n      console.error('Öğrenme hatası:', error);\n    }\n    \n    return false;\n  };\n\n  // Handle correct answer submission\n  const submitCorrectAnswer = async (answer: string) => {\n    if (!currentQuestion || !answer.trim()) return;\n\n    try {\n      await trainNetwork(currentQuestion, answer.trim());\n      \n      const newTraining: LocalTrainingData = {\n        userInput: currentQuestion,\n        systemOutput: answer.trim(),\n        confidence: 1.0,\n        timestamp: Date.now()\n      };\n      \n      setTrainHistory(prev => {\n        const updated = [...prev, newTraining];\n        localStorage.setItem('neural_training_history', JSON.stringify(updated));\n        return updated;\n      });\n\n      addToast('Eğitim başarıyla tamamlandı!', 'success');\n      setShowCorrectAnswer(false);\n      setCurrentQuestion('');\n      \n      setTimeout(() => {\n        refreshNetwork();\n      }, 500);\n      \n    } catch (error) {\n      console.error('Eğitim hatası:', error);\n      addToast('Eğitim sırasında hata oluştu', 'error');\n    }\n  };\n\n  // Handle batch training\n  const batchTrainNetwork = async (pairs: TrainingPair[]) => {\n    setTrainingProgress(0);\n    \n    try {\n      await batchTrainNetworkItems(pairs, (progress) => {\n        setTrainingProgress(progress);\n      });\n      \n      addToast(`${pairs.length} adet eğitim verisi başarıyla işlendi!`, 'success');\n      setShowBatchTraining(false);\n      setTrainingProgress(0);\n      \n      setTimeout(() => {\n        refreshNetwork();\n      }, 500);\n      \n    } catch (error) {\n      console.error('Toplu eğitim hatası:', error);\n      addToast('Toplu eğitim sırasında hata oluştu', 'error');\n      setTrainingProgress(0);\n    }\n  };\n\n  // Handle feedback\n  const handleFeedback = (messageId: string, isPositive: boolean) => {\n    const feedback = isPositive ? 1 : -1;\n    setMessages(prev => prev.map(msg => \n      msg.id === messageId \n        ? { ...msg, feedback }\n        : msg\n    ));\n    addToast('Geri bildiriminiz alındı', 'success');\n  };\n\n  // Handle correct answer callback\n  const handleCorrectAnswer = (messageId: string) => {\n    // Find the message to get the question content\n    const message = messages.find(msg => msg.id === messageId);\n    if (message && message.isUser) {\n      setCurrentQuestion(message.content);\n      setOriginalQuestion(message.content);\n      localStorage.setItem('pending_question', message.content);\n      setShowCorrectAnswer(true);\n    }\n  };\n\n  // Clear chat\n  const clearChat = () => {\n    setMessages([]);\n    addToast('Sohbet temizlendi', 'info');\n  };\n\n  // Clear training\n  const clearTraining = () => {\n    setTrainHistory([]);\n    localStorage.removeItem('neural_training_history');\n    addToast('Eğitim verileri temizlendi', 'warning');\n  };\n\n  // Handle cell details\n  const handleCellDetails = (node: NetworkNode) => {\n    setSelectedCell(node);\n    setShowCellDetails(true);\n  };\n\n  // Handle adding cells\n  const handleAddCells = () => {\n    const count = 5; // Default count\n    try {\n      addCellsToNetwork(userNetworks, count);\n      addToast(`${count} hücre eklendi`, 'success');\n      refreshNetwork();\n    } catch (error) {\n      console.error('Hücre ekleme hatası:', error);\n      addToast('Hücre eklenirken hata oluştu', 'error');\n    }\n  };\n\n  // Handle removing cells\n  const handleRemoveCells = () => {\n    const count = 5; // Default count\n    try {\n      removeCellsFromNetwork(userNetworks, count);\n      addToast(`${count} hücre kaldırıldı`, 'warning');\n      refreshNetwork();\n    } catch (error) {\n      console.error('Hücre kaldırma hatası:', error);\n      addToast('Hücre kaldırılırken hata oluştu', 'error');\n    }\n  };\n\n  return (\n    <div className=\"flex flex-col h-screen min-h-screen w-full overflow-hidden\">\n      {/* AI Neural Background */}\n      <div className=\"ai-neural-bg\"></div>\n      \n      {/* Header */}\n      <div className=\"relative z-20\">\n        <Header />\n      </div>\n\n      {/* Tab Navigation */}\n      <div className=\"glass-card border-0 border-b border-border/50 mb-4 sm:mb-6 relative z-10\">\n        <div className=\"max-w-4xl mx-auto px-4 sm:px-6\">\n          <nav className=\"flex space-x-2 sm:space-x-4 py-4 overflow-x-auto scrollbar-thin\" role=\"tablist\">\n            <button\n              onClick={() => setActiveTab('chat')}\n              className={`tab-button whitespace-nowrap ${activeTab === 'chat' ? 'active' : ''}`}\n              role=\"tab\"\n              aria-selected={activeTab === 'chat'}\n            >\n              <span className=\"flex items-center space-x-2\">\n                <span className=\"text-lg\">💬</span>\n                <span className=\"mobile-hidden font-bold text-white\">Sohbet</span>\n              </span>\n            </button>\n            <button\n              onClick={() => setActiveTab('neural')}\n              className={`tab-button whitespace-nowrap ${activeTab === 'neural' ? 'active' : ''}`}\n              role=\"tab\"\n              aria-selected={activeTab === 'neural'}\n            >\n              <span className=\"flex items-center space-x-2\">\n                <span className=\"text-lg\">🌐</span>\n                <span className=\"mobile-hidden font-bold text-white\">Sinir Ağı</span>\n              </span>\n            </button>\n            <button\n              onClick={() => setActiveTab('sozluk')}\n              className={`tab-button whitespace-nowrap ${activeTab === 'sozluk' ? 'active' : ''}`}\n              role=\"tab\"\n              aria-selected={activeTab === 'sozluk'}\n            >\n              <span className=\"flex items-center space-x-2\">\n                <span className=\"text-lg\">📚</span>\n                <span className=\"mobile-hidden font-bold text-white\">Türkçe Sözlük</span>\n              </span>\n            </button>\n          </nav>\n        </div>\n\n        {/* Tab indicator line */}\n        <div className=\"h-px bg-gradient-to-r from-transparent via-primary/30 to-transparent\"></div>\n      </div>\n\n      {/* Main Content Area */}\n      <div className=\"flex-1 overflow-hidden px-4 sm:px-6 relative z-10\">\n        <div className=\"h-full max-w-7xl mx-auto animate-fade-in\">\n          {activeTab === 'chat' && (\n            <ChatPanel\n              onSendMessage={handleSendMessage}\n              onCorrectAnswer={handleCorrectAnswer}\n              onShowMemory={() => setShowMemory(prev => !prev)}\n              onClearChat={clearChat}\n              onClearTraining={clearTraining}\n              onFeedback={handleFeedback}\n              messages={messages}\n              isProcessing={isProcessing}\n              memorySystem={memorySystemRef.current}\n              relationCount={stats.relationCount}\n              onToggleVoice={toggleVoice}\n              isVoiceEnabled={isVoiceEnabled}\n              onUserMessageLearned={handleSendMessageWithLearning}\n            />\n          )}\n          {activeTab === 'neural' && (\n            <NeuralNetworkPanel\n              userNetworks={userNetworks}\n              systemNetworks={systemNetworks}\n              activatedNodes={activatedNodes as any}\n              relations={relations}\n              bidirectionalRelations={bidirectionalRelations}\n              onRefresh={refreshNetwork}\n              onShowCellDetails={handleCellDetails}\n              onZoomIn={() => addToast(\"Yakınlaştırma özelliği 3D modunda kullanılabilir.\", \"info\")}\n              onZoomOut={() => addToast(\"Uzaklaştırma özelliği 3D modunda kullanılabilir.\", \"info\")}\n              onNewTraining={() => setShowCorrectAnswer(true)}\n              onBatchTraining={() => setShowBatchTraining(true)}\n              onAddCell={handleAddCells}\n              onRemoveCell={handleRemoveCells}\n              onToggleVoice={toggleVoice}\n              isVoiceEnabled={isVoiceEnabled}\n              totalNodeCount={stats.nodeCount}\n              activeRelationCount={stats.relationCount}\n            />\n          )}\n          {activeTab === 'sozluk' && <TurkishDictionaryPanel />}\n        </div>\n      </div>\n\n      {/* Modals */}\n      <MemoryPanel\n        memorySystem={memorySystemRef.current}\n        isVisible={showMemory}\n        onClose={() => setShowMemory(false)}\n      />\n\n      <CorrectAnswerModal\n        isOpen={showCorrectAnswer}\n        originalQuestion={currentQuestion}\n        onSubmit={(answer, editedQuestion) => {\n          if (editedQuestion && editedQuestion !== currentQuestion) {\n            setCurrentQuestion(editedQuestion);\n          }\n          submitCorrectAnswer(answer);\n        }}\n        onClose={() => {\n          setShowCorrectAnswer(false);\n          setCurrentQuestion('');\n        }}\n      />\n\n      <BatchTrainingModal\n        isOpen={showBatchTraining}\n        onSubmit={batchTrainNetwork}\n        onClose={() => setShowBatchTraining(false)}\n        isProcessing={trainingProgress > 0 && trainingProgress < 100}\n        progress={trainingProgress}\n      />\n\n      <CellDetailsModal\n        isOpen={showCellDetails}\n        node={selectedCell}\n        relations={relations}\n        bidirectionalRelations={bidirectionalRelations}\n        onClose={() => setShowCellDetails(false)}\n      />\n\n      <AIStatusPanel\n        advancedAI={advancedAI}\n        isVisible={showAIStatus}\n        onClose={() => setShowAIStatus(false)}\n      />\n    </div>\n  );\n}","size_bytes":18177},"client/src/index.css":{"content":"@import url('https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap');\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n/* Futuristic AI Neural Background with Matrix Effects */\n.ai-neural-bg {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: \n    linear-gradient(135deg, #0f0f23 0%, #1a1a2e 25%, #16213e 50%, #0f3460 75%, #533483 100%),\n    radial-gradient(circle at 20% 20%, rgba(139, 92, 246, 0.3) 0%, transparent 50%),\n    radial-gradient(circle at 80% 80%, rgba(236, 72, 153, 0.25) 0%, transparent 50%),\n    radial-gradient(circle at 40% 60%, rgba(6, 182, 212, 0.2) 0%, transparent 50%);\n  animation: neural-pulse 6s ease-in-out infinite alternate;\n  pointer-events: none;\n  z-index: -1;\n  overflow: hidden;\n}\n\n.ai-neural-bg::before {\n  content: '';\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background-image: \n    linear-gradient(90deg, transparent 98%, rgba(139, 92, 246, 0.1) 100%),\n    linear-gradient(0deg, transparent 98%, rgba(236, 72, 153, 0.1) 100%);\n  background-size: 50px 50px, 50px 50px;\n  animation: matrix-grid 20s linear infinite;\n  opacity: 0.6;\n}\n\n.ai-neural-bg::after {\n  content: '';\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: radial-gradient(circle, transparent 1px, rgba(139, 92, 246, 0.05) 1px);\n  background-size: 30px 30px;\n  animation: neural-dots 8s ease-in-out infinite;\n  opacity: 0.4;\n}\n\n@keyframes neural-pulse {\n  0% { \n    opacity: 0.8;\n    transform: scale(1);\n  }\n  100% { \n    opacity: 1;\n    transform: scale(1.02);\n  }\n}\n\n@keyframes matrix-grid {\n  0% { transform: translate(0, 0); }\n  100% { transform: translate(50px, 50px); }\n}\n\n@keyframes neural-dots {\n  0%, 100% { opacity: 0.3; }\n  50% { opacity: 0.7; }\n}\n\n/* Ultra-Modern Glassmorphism Effects */\n.glass-card {\n  background: linear-gradient(135deg, \n    rgba(255, 255, 255, 0.1) 0%, \n    rgba(255, 255, 255, 0.05) 50%, \n    rgba(255, 255, 255, 0.02) 100%);\n  backdrop-filter: blur(20px) saturate(180%);\n  border: 1px solid rgba(255, 255, 255, 0.18);\n  border-radius: 20px;\n  box-shadow: \n    0 8px 32px rgba(0, 0, 0, 0.4),\n    inset 0 1px 0 rgba(255, 255, 255, 0.2),\n    0 0 60px rgba(139, 92, 246, 0.1);\n  position: relative;\n  overflow: hidden;\n}\n\n.glass-card::before {\n  content: '';\n  position: absolute;\n  top: 0;\n  left: -100%;\n  width: 100%;\n  height: 100%;\n  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);\n  animation: shimmer 3s infinite;\n}\n\n@keyframes shimmer {\n  0% { left: -100%; }\n  100% { left: 100%; }\n}\n\n.glass-input {\n  background: linear-gradient(135deg, \n    rgba(255, 255, 255, 0.1) 0%,\n    rgba(139, 92, 246, 0.05) 50%,\n    rgba(6, 182, 212, 0.05) 100%);\n  backdrop-filter: blur(15px) saturate(180%);\n  border: 1px solid rgba(255, 255, 255, 0.2);\n  border-radius: 16px;\n  color: white;\n  padding: 14px 18px;\n  font-size: 0.95rem;\n  font-weight: 500;\n  letter-spacing: 0.2px;\n  position: relative;\n  transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);\n  box-shadow: \n    0 2px 15px rgba(0, 0, 0, 0.1),\n    inset 0 1px 0 rgba(255, 255, 255, 0.1);\n}\n\n.glass-input::placeholder {\n  color: rgba(255, 255, 255, 0.6);\n  font-weight: 400;\n}\n\n.glass-input:focus {\n  background: linear-gradient(135deg, \n    rgba(255, 255, 255, 0.15) 0%,\n    rgba(139, 92, 246, 0.1) 50%,\n    rgba(6, 182, 212, 0.08) 100%);\n  border-color: rgba(139, 92, 246, 0.6);\n  outline: none;\n  transform: translateY(-1px);\n  box-shadow: \n    0 4px 25px rgba(139, 92, 246, 0.3),\n    0 0 40px rgba(139, 92, 246, 0.15),\n    inset 0 1px 0 rgba(255, 255, 255, 0.2);\n}\n\n/* Futuristic AI Buttons */\n.ai-button-primary {\n  background: linear-gradient(135deg, \n    #8b5cf6 0%, \n    #ec4899 50%, \n    #06b6d4 100%);\n  background-size: 200% 200%;\n  border: none;\n  border-radius: 16px;\n  padding: 14px 28px;\n  color: white;\n  font-weight: 700;\n  font-size: 0.95rem;\n  letter-spacing: 0.5px;\n  text-transform: uppercase;\n  position: relative;\n  overflow: hidden;\n  transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);\n  box-shadow: \n    0 4px 20px rgba(139, 92, 246, 0.4),\n    0 0 40px rgba(139, 92, 246, 0.2),\n    inset 0 1px 0 rgba(255, 255, 255, 0.2);\n  animation: gradient-shift 3s ease infinite;\n}\n\n.ai-button-primary::before {\n  content: '';\n  position: absolute;\n  top: 0;\n  left: -100%;\n  width: 100%;\n  height: 100%;\n  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);\n  transition: left 0.5s;\n}\n\n.ai-button-primary:hover {\n  transform: translateY(-3px) scale(1.02);\n  box-shadow: \n    0 8px 30px rgba(139, 92, 246, 0.5),\n    0 0 60px rgba(236, 72, 153, 0.3),\n    inset 0 1px 0 rgba(255, 255, 255, 0.3);\n}\n\n.ai-button-primary:hover::before {\n  left: 100%;\n}\n\n@keyframes gradient-shift {\n  0%, 100% { background-position: 0% 50%; }\n  50% { background-position: 100% 50%; }\n}\n\n.ai-button-secondary {\n  background: rgba(255, 255, 255, 0.1);\n  backdrop-filter: blur(10px);\n  border: 1px solid rgba(255, 255, 255, 0.2);\n  border-radius: 12px;\n  padding: 10px 20px;\n  color: white;\n  font-weight: 500;\n  transition: all 0.3s ease;\n}\n\n.ai-button-secondary:hover {\n  background: rgba(255, 255, 255, 0.15);\n  transform: translateY(-1px);\n}\n\n/* Ultra-Modern Chat Messages */\n.ai-message-user {\n  background: linear-gradient(135deg, \n    rgba(139, 92, 246, 0.25) 0%,\n    rgba(236, 72, 153, 0.2) 50%,\n    rgba(6, 182, 212, 0.15) 100%);\n  backdrop-filter: blur(15px) saturate(200%);\n  border: 1px solid rgba(139, 92, 246, 0.4);\n  border-radius: 20px 20px 8px 20px;\n  padding: 16px 20px;\n  margin-left: auto;\n  max-width: 80%;\n  position: relative;\n  box-shadow: \n    0 4px 20px rgba(139, 92, 246, 0.2),\n    inset 0 1px 0 rgba(255, 255, 255, 0.2);\n  animation: slide-in-right 0.5s cubic-bezier(0.4, 0, 0.2, 1);\n}\n\n.ai-message-user::before {\n  content: '';\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);\n  border-radius: inherit;\n  opacity: 0;\n  transition: opacity 0.3s ease;\n}\n\n.ai-message-user:hover::before {\n  opacity: 1;\n}\n\n.ai-message-bot {\n  background: linear-gradient(135deg, \n    rgba(255, 255, 255, 0.08) 0%,\n    rgba(139, 92, 246, 0.06) 50%,\n    rgba(6, 182, 212, 0.04) 100%);\n  backdrop-filter: blur(15px) saturate(150%);\n  border: 1px solid rgba(255, 255, 255, 0.15);\n  border-radius: 20px 20px 20px 8px;\n  padding: 16px 20px;\n  margin-right: auto;\n  max-width: 80%;\n  position: relative;\n  box-shadow: \n    0 4px 20px rgba(0, 0, 0, 0.2),\n    0 0 40px rgba(139, 92, 246, 0.05),\n    inset 0 1px 0 rgba(255, 255, 255, 0.1);\n  animation: slide-in-left 0.5s cubic-bezier(0.4, 0, 0.2, 1);\n}\n\n.ai-message-bot::after {\n  content: '🤖';\n  position: absolute;\n  top: -8px;\n  left: -8px;\n  width: 24px;\n  height: 24px;\n  background: linear-gradient(135deg, #8b5cf6, #ec4899);\n  border-radius: 50%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 12px;\n  box-shadow: 0 2px 10px rgba(139, 92, 246, 0.3);\n}\n\n@keyframes slide-in-right {\n  from { \n    opacity: 0; \n    transform: translateX(20px); \n  }\n  to { \n    opacity: 1; \n    transform: translateX(0); \n  }\n}\n\n@keyframes slide-in-left {\n  from { \n    opacity: 0; \n    transform: translateX(-20px); \n  }\n  to { \n    opacity: 1; \n    transform: translateX(0); \n  }\n}\n\n/* Futuristic Tab Navigation */\n.tab-button {\n  padding: 14px 24px;\n  border-radius: 16px;\n  background: linear-gradient(135deg, \n    rgba(255, 255, 255, 0.12) 0%,\n    rgba(139, 92, 246, 0.08) 50%,\n    rgba(255, 255, 255, 0.06) 100%);\n  backdrop-filter: blur(15px) saturate(150%);\n  border: 1px solid rgba(255, 255, 255, 0.2);\n  color: rgba(255, 255, 255, 0.95);\n  font-weight: 700;\n  font-size: 0.95rem;\n  letter-spacing: 0.5px;\n  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\n  position: relative;\n  overflow: hidden;\n  transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);\n  box-shadow: \n    0 4px 15px rgba(0, 0, 0, 0.2),\n    inset 0 1px 0 rgba(255, 255, 255, 0.1);\n}\n\n.tab-button::before {\n  content: '';\n  position: absolute;\n  top: 0;\n  left: -100%;\n  width: 100%;\n  height: 100%;\n  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);\n  transition: left 0.6s ease;\n}\n\n.tab-button.active {\n  background: linear-gradient(135deg, \n    rgba(139, 92, 246, 0.6) 0%,\n    rgba(236, 72, 153, 0.5) 50%,\n    rgba(6, 182, 212, 0.4) 100%);\n  background-size: 200% 200%;\n  border: 1px solid rgba(139, 92, 246, 0.8);\n  color: white;\n  text-shadow: \n    0 2px 4px rgba(0, 0, 0, 0.5),\n    0 0 10px rgba(139, 92, 246, 0.8);\n  font-weight: 800;\n  box-shadow: \n    0 6px 25px rgba(139, 92, 246, 0.4),\n    0 0 50px rgba(139, 92, 246, 0.3),\n    inset 0 1px 0 rgba(255, 255, 255, 0.3);\n  animation: active-tab-glow 2s ease-in-out infinite alternate;\n}\n\n.tab-button:hover:not(.active) {\n  background: linear-gradient(135deg, \n    rgba(255, 255, 255, 0.18) 0%,\n    rgba(139, 92, 246, 0.12) 50%,\n    rgba(255, 255, 255, 0.1) 100%);\n  color: white;\n  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);\n  transform: translateY(-2px);\n  box-shadow: \n    0 6px 20px rgba(139, 92, 246, 0.2),\n    inset 0 1px 0 rgba(255, 255, 255, 0.15);\n}\n\n.tab-button:hover::before {\n  left: 100%;\n}\n\n@keyframes active-tab-glow {\n  0% { \n    box-shadow: \n      0 4px 20px rgba(139, 92, 246, 0.3),\n      0 0 40px rgba(139, 92, 246, 0.2); \n  }\n  100% { \n    box-shadow: \n      0 6px 25px rgba(139, 92, 246, 0.4),\n      0 0 60px rgba(236, 72, 153, 0.3); \n  }\n}\n\n/* Animations */\n.animate-fade-in {\n  animation: fade-in 0.5s ease-in-out;\n}\n\n@keyframes fade-in {\n  from { opacity: 0; transform: translateY(10px); }\n  to { opacity: 1; transform: translateY(0); }\n}\n\n/* Loading Animations */\n.ai-loading {\n  display: inline-block;\n  width: 20px;\n  height: 20px;\n  border: 2px solid rgba(255, 255, 255, 0.3);\n  border-radius: 50%;\n  border-top-color: #8b5cf6;\n  animation: spin 1s ease-in-out infinite;\n}\n\n@keyframes spin {\n  to { transform: rotate(360deg); }\n}\n\n/* Scrollbar Styling */\n.scrollbar-thin::-webkit-scrollbar {\n  width: 4px;\n  height: 4px;\n}\n\n.scrollbar-thin::-webkit-scrollbar-track {\n  background: rgba(255, 255, 255, 0.1);\n  border-radius: 2px;\n}\n\n.scrollbar-thin::-webkit-scrollbar-thumb {\n  background: rgba(139, 92, 246, 0.5);\n  border-radius: 2px;\n}\n\n.scrollbar-thin::-webkit-scrollbar-thumb:hover {\n  background: rgba(139, 92, 246, 0.7);\n}\n\n/* Mobile Responsive */\n@media (max-width: 640px) {\n  .mobile-hidden {\n    display: none;\n  }\n  \n  .ai-message-user,\n  .ai-message-bot {\n    max-width: 90%;\n  }\n}\n\n/* Enhanced Text Visibility */\n.tab-button span {\n  position: relative;\n  z-index: 2;\n  color: white !important;\n  font-weight: 800 !important;\n  text-shadow: \n    0 2px 4px rgba(0, 0, 0, 0.8),\n    0 0 8px rgba(0, 0, 0, 0.6),\n    0 1px 0 rgba(255, 255, 255, 0.2) !important;\n  filter: contrast(1.2) brightness(1.1);\n}\n\n.tab-button.active span {\n  color: white !important;\n  text-shadow: \n    0 2px 6px rgba(0, 0, 0, 0.9),\n    0 0 12px rgba(139, 92, 246, 0.8),\n    0 0 24px rgba(236, 72, 153, 0.6),\n    0 1px 0 rgba(255, 255, 255, 0.3) !important;\n  filter: contrast(1.3) brightness(1.2);\n}\n\n/* Futuristic Neural Network Visualizations */\n.neural-node {\n  transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);\n  filter: drop-shadow(0 2px 8px rgba(139, 92, 246, 0.3));\n}\n\n.neural-node:hover {\n  transform: scale(1.15) translateZ(10px);\n  filter: \n    drop-shadow(0 0 20px rgba(139, 92, 246, 0.8))\n    drop-shadow(0 0 40px rgba(236, 72, 153, 0.6))\n    brightness(1.3);\n  animation: node-pulse 0.6s ease-in-out;\n}\n\n@keyframes node-pulse {\n  0%, 100% { transform: scale(1.15); }\n  50% { transform: scale(1.25); }\n}\n\n/* Modern Scrollbars */\n* {\n  scrollbar-width: thin;\n  scrollbar-color: rgba(139, 92, 246, 0.5) rgba(255, 255, 255, 0.1);\n}\n\n/* Futuristic Loading Animation */\n.ai-loading-advanced {\n  width: 40px;\n  height: 40px;\n  position: relative;\n  display: inline-block;\n}\n\n.ai-loading-advanced::before,\n.ai-loading-advanced::after {\n  content: '';\n  position: absolute;\n  border-radius: 50%;\n  animation: pulse-ring 2s linear infinite;\n}\n\n.ai-loading-advanced::before {\n  width: 100%;\n  height: 100%;\n  border: 2px solid rgba(139, 92, 246, 0.3);\n  animation-delay: 0s;\n}\n\n.ai-loading-advanced::after {\n  width: 70%;\n  height: 70%;\n  top: 15%;\n  left: 15%;\n  border: 2px solid rgba(236, 72, 153, 0.5);\n  animation-delay: -1s;\n}\n\n@keyframes pulse-ring {\n  0% {\n    transform: scale(0.8);\n    opacity: 1;\n  }\n  100% {\n    transform: scale(1.4);\n    opacity: 0;\n  }\n}\n\n/* Holographic Text Effect */\n.holographic-text {\n  background: linear-gradient(45deg, \n    #8b5cf6, #ec4899, #06b6d4, #10b981);\n  background-size: 300% 300%;\n  -webkit-background-clip: text;\n  background-clip: text;\n  -webkit-text-fill-color: transparent;\n  animation: holographic 3s ease-in-out infinite;\n  font-weight: 700;\n  text-shadow: 0 0 30px rgba(139, 92, 246, 0.5);\n}\n\n@keyframes holographic {\n  0%, 100% { background-position: 0% 50%; }\n  50% { background-position: 100% 50%; }\n}\n\n/* Enhanced Modal Styles */\n.ai-modal {\n  background: linear-gradient(135deg, \n    rgba(15, 15, 35, 0.95) 0%,\n    rgba(26, 26, 46, 0.97) 50%,\n    rgba(83, 52, 131, 0.95) 100%);\n  backdrop-filter: blur(25px) saturate(200%);\n  border: 1px solid rgba(139, 92, 246, 0.3);\n  border-radius: 24px;\n  box-shadow: \n    0 25px 50px rgba(0, 0, 0, 0.5),\n    0 0 100px rgba(139, 92, 246, 0.2),\n    inset 0 1px 0 rgba(255, 255, 255, 0.1);\n}\n\n/* Particle Animation Background */\n.particle-bg {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  z-index: 0;\n}\n\n.particle {\n  position: absolute;\n  width: 2px;\n  height: 2px;\n  background: rgba(139, 92, 246, 0.6);\n  border-radius: 50%;\n  animation: float-particle 10s infinite linear;\n}\n\n.particle:nth-child(2n) {\n  background: rgba(236, 72, 153, 0.5);\n  animation-duration: 12s;\n  animation-delay: -2s;\n}\n\n.particle:nth-child(3n) {\n  background: rgba(6, 182, 212, 0.4);\n  animation-duration: 8s;\n  animation-delay: -4s;\n}\n\n@keyframes float-particle {\n  0% {\n    transform: translateY(100vh) translateX(0) rotate(0deg);\n    opacity: 0;\n  }\n  10% {\n    opacity: 1;\n  }\n  90% {\n    opacity: 1;\n  }\n  100% {\n    transform: translateY(-100vh) translateX(100px) rotate(360deg);\n    opacity: 0;\n  }\n}\n\n:root {\n  --ai-primary: #4f46e5;\n  --ai-secondary: #7c3aed;\n  --ai-accent: #06b6d4;\n  --ai-bg-dark: #0f0f23;\n  --ai-bg-secondary: #1e1b4b;\n  --ai-text-light: #e2e8f0;\n  --ai-text-dim: #94a3b8;\n  --ai-border: rgba(255, 255, 255, 0.1);\n  --ai-glow: rgba(79, 70, 229, 0.3);\n}\n\n/* Modern CSS Tema Değişkenleri - Enhanced Light Theme */\n:root {\n    --background: 0 0% 99%;\n    --foreground: 220 13% 9%;\n    --card: 0 0% 100%;\n    --card-foreground: 220 13% 9%;\n    --popover: 0 0% 100%;\n    --popover-foreground: 220 13% 9%;\n    --primary: 262 83% 58%;\n    --primary-foreground: 0 0% 98%;\n    --secondary: 220 13% 95%;\n    --secondary-foreground: 220 13% 9%;\n    --muted: 220 13% 95%;\n    --muted-foreground: 220 9% 46%;\n    --accent: 262 83% 95%;\n    --accent-foreground: 262 83% 11%;\n    --destructive: 0 84% 60%;\n    --destructive-foreground: 0 0% 98%;\n    --border: 220 13% 91%;\n    --input: 220 13% 91%;\n    --ring: 262 83% 58%;\n    --chart-1: 262 83% 58%;\n    --chart-2: 262 100% 75%;\n    --chart-3: 262 50% 45%;\n    --chart-4: 285 100% 70%;\n    --chart-5: 240 100% 80%;\n    --radius: 0.75rem;\n    \n    /* New Modern Variables */\n    --gradient-primary: linear-gradient(135deg, hsl(262, 83%, 58%) 0%, hsl(285, 100%, 70%) 100%);\n    --gradient-secondary: linear-gradient(135deg, hsl(220, 13%, 95%) 0%, hsl(220, 13%, 91%) 100%);\n    --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);\n    --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);\n    --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);\n    --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);\n  }\n\n  /* Force dark theme - always */\n  :root, .light {\n    --background: 224 71% 4%;\n    --foreground: 213 31% 91%;\n    --card: 224 71% 4%;\n    --card-foreground: 213 31% 91%;\n    --popover: 224 71% 4%;\n    --popover-foreground: 213 31% 91%;\n    --primary: 263 70% 50%;\n    --primary-foreground: 213 31% 91%;\n    --secondary: 215 28% 17%;\n    --secondary-foreground: 213 31% 91%;\n    --muted: 215 28% 17%;\n    --muted-foreground: 217 11% 65%;\n    --accent: 215 28% 17%;\n    --accent-foreground: 213 31% 91%;\n    --destructive: 0 63% 31%;\n    --destructive-foreground: 213 31% 91%;\n    --border: 215 28% 17%;\n    --input: 215 28% 17%;\n    --ring: 263 70% 50%;\n    --chart-1: 263 70% 50%;\n    --chart-2: 285 85% 60%;\n    --chart-3: 262 50% 65%;\n    --chart-4: 240 75% 70%;\n    --chart-5: 300 80% 75%;\n    \n    /* Dark Mode Gradients */\n    --gradient-primary: linear-gradient(135deg, hsl(263, 70%, 50%) 0%, hsl(285, 85%, 60%) 100%);\n    --gradient-secondary: linear-gradient(135deg, hsl(215, 28%, 17%) 0%, hsl(215, 28%, 14%) 100%);\n    --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.3);\n    --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);\n    --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.2);\n    --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.4), 0 10px 10px -5px rgba(0, 0, 0, 0.3);\n  }\n\n  .dark {\n    --background: 224 71% 4%;\n    --foreground: 213 31% 91%;\n    --card: 224 71% 4%;\n    --card-foreground: 213 31% 91%;\n    --popover: 224 71% 4%;\n    --popover-foreground: 213 31% 91%;\n    --primary: 263 70% 50%;\n    --primary-foreground: 213 31% 91%;\n    --secondary: 215 28% 17%;\n    --secondary-foreground: 213 31% 91%;\n    --muted: 215 28% 17%;\n    --muted-foreground: 217 11% 65%;\n    --accent: 215 28% 17%;\n    --accent-foreground: 213 31% 91%;\n    --destructive: 0 63% 31%;\n    --destructive-foreground: 213 31% 91%;\n    --border: 215 28% 17%;\n    --input: 215 28% 17%;\n    --ring: 263 70% 50%;\n    --chart-1: 263 70% 50%;\n    --chart-2: 285 85% 60%;\n    --chart-3: 262 50% 65%;\n    --chart-4: 240 75% 70%;\n    --chart-5: 300 80% 75%;\n    \n    /* Dark Mode Gradients */\n    --gradient-primary: linear-gradient(135deg, hsl(263, 70%, 50%) 0%, hsl(285, 85%, 60%) 100%);\n    --gradient-secondary: linear-gradient(135deg, hsl(215, 28%, 17%) 0%, hsl(215, 28%, 14%) 100%);\n    --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.3);\n    --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);\n    --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.2);\n    --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.4), 0 10px 10px -5px rgba(0, 0, 0, 0.3);\n  }\n\n  /* Modern Responsive Styles */\n  @media (max-width: 640px) {\n    .responsive-input {\n      @apply min-w-0 flex-1;\n    }\n\n    .chat-input-container {\n      @apply flex-col gap-3 p-4;\n      background: hsl(var(--card));\n      border-top: 1px solid hsl(var(--border));\n      box-shadow: var(--shadow-lg);\n    }\n\n    .chat-input-container .flex {\n      @apply w-full;\n    }\n\n    /* Chat input görünürlüğü için - sabit alt boşluk */\n    .chat-panel-container {\n      @apply pb-0;\n    }\n\n    .chat-input-container {\n      position: sticky !important;\n      bottom: 0 !important;\n      z-index: 10 !important;\n      background: hsl(var(--card)) !important;\n    }\n\n    /* Ana içerik alanları için alt padding */\n    .main-content-area {\n      @apply pb-24;\n    }\n\n    /* Dialog ve popover içeriklerinin responsive yapılması */\n    .dialog-content {\n      @apply w-[95vw] max-w-md rounded-2xl;\n      box-shadow: var(--shadow-xl);\n    }\n\n    /* Scroll area'lar için mobile yükseklik ayarı */\n    .scroll-area-mobile {\n      @apply h-[250px] sm:h-[400px];\n    }\n\n    /* Mobile'da input container'ları ekranın altına sabitle */\n    .mobile-input-fixed {\n      @apply fixed bottom-0 left-0 right-0 z-50 border-t;\n      background: hsl(var(--card));\n      box-shadow: var(--shadow-lg);\n    }\n    \n    /* Mobile tab buttons */\n    .tab-button {\n      @apply px-3 py-2 rounded-xl text-sm font-medium transition-all duration-300;\n    }\n    \n    .tab-button.active {\n      background: var(--gradient-primary);\n      color: hsl(var(--primary-foreground));\n      box-shadow: var(--shadow-md);\n    }\n  }\n\n  /* Input container z-index ve positioning */\n  .input-container-fixed {\n    @apply sticky bottom-0 z-20 bg-background border-t;\n  }\n\n  /* Panel container height fixes */\n  .tab-panel-container {\n    @apply max-h-screen overflow-hidden flex flex-col;\n  }\n\n  .chat-panel-container {\n    @apply max-h-[80vh] min-h-[500px];\n  }\n\n  /* Form bottom fixed positioning */\n  .form-bottom-fixed {\n    @apply mt-auto sticky bottom-0 bg-background border-t pt-2;\n  }\n\n  /* Mobile viewport ayarları */\n  @media screen and (max-height: 600px) {\n    .mobile-compact {\n      @apply h-[200px];\n    }\n\n    /* Küçük ekranlarda daha az padding */\n    .chat-panel-container {\n      @apply pb-20;\n    }\n\n    .main-content-area {\n      @apply pb-20;\n    }\n  }\n\n  /* iOS Safari viewport fix */\n  @supports (-webkit-touch-callout: none) {\n    .mobile-viewport-fix {\n      @apply pb-8;\n    }\n  }\n\n/* Açık Tema - Explicit */\n.light {\n  --background: 0 0% 100%;\n  --foreground: 240 10% 3.9%;\n  --card: 0 0% 100%;\n  --card-foreground: 240 10% 3.9%;\n  --popover: 0 0% 100%;\n  --popover-foreground: 240 10% 3.9%;\n  --primary: 240 5.9% 10%;\n  --primary-foreground: 0 0% 98%;\n  --secondary: 240 4.8% 95.9%;\n  --secondary-foreground: 240 5.9% 10%;\n  --muted: 240 4.8% 95.9%;\n  --muted-foreground: 240 3.8% 46.1%;\n  --accent: 240 4.8% 95.9%;\n  --accent-foreground: 240 5.9% 10%;\n  --destructive: 0 84.2% 60.2%;\n  --destructive-foreground: 0 0% 98%;\n  --border: 240 5.9% 90%;\n  --input: 240 5.9% 90%;\n  --ring: 240 5.9% 10%;\n}\n\n/* Modern Global Transitions */\n*,\n*::before,\n*::after {\n  transition: \n    background-color 0.3s cubic-bezier(0.4, 0, 0.2, 1),\n    color 0.3s cubic-bezier(0.4, 0, 0.2, 1),\n    border-color 0.3s cubic-bezier(0.4, 0, 0.2, 1),\n    box-shadow 0.3s cubic-bezier(0.4, 0, 0.2, 1),\n    transform 0.2s cubic-bezier(0.4, 0, 0.2, 1),\n    opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n}\n\n/* Modern AI Interface Styles */\nbody {\n  font-family: 'Inter', system-ui, -apple-system, sans-serif;\n  background: var(--ai-bg-dark);\n  color: var(--ai-text-light);\n}\n\n.ai-chat-container {\n  background: linear-gradient(135deg, var(--ai-bg-dark) 0%, var(--ai-bg-secondary) 100%);\n  min-height: 100vh;\n  position: relative;\n  overflow: hidden;\n}\n\n.ai-chat-container::before {\n  content: '';\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background: radial-gradient(ellipse at top, var(--ai-glow) 0%, transparent 50%);\n  pointer-events: none;\n}\n\n.ai-message-bot {\n  background: linear-gradient(135deg, rgba(79, 70, 229, 0.1) 0%, rgba(124, 58, 237, 0.1) 100%);\n  border: 1px solid var(--ai-border);\n  border-radius: 16px;\n  padding: 16px;\n  backdrop-filter: blur(10px);\n  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);\n}\n\n.ai-message-user {\n  background: linear-gradient(135deg, rgba(6, 182, 212, 0.1) 0%, rgba(79, 70, 229, 0.1) 100%);\n  border: 1px solid var(--ai-border);\n  border-radius: 16px;\n  padding: 16px;\n  backdrop-filter: blur(10px);\n  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);\n}\n\n.ai-input {\n  background: rgba(255, 255, 255, 0.05);\n  border: 1px solid var(--ai-border);\n  border-radius: 12px;\n  backdrop-filter: blur(10px);\n  color: var(--ai-text-light);\n  transition: all 0.3s ease;\n}\n\n.ai-input:focus {\n  border-color: var(--ai-primary);\n  box-shadow: 0 0 20px var(--ai-glow);\n  outline: none;\n}\n\n.ai-button {\n  background: linear-gradient(135deg, var(--ai-primary) 0%, var(--ai-secondary) 100%);\n  border: none;\n  border-radius: 10px;\n  color: white;\n  font-weight: 500;\n  transition: all 0.3s ease;\n  box-shadow: 0 4px 15px rgba(79, 70, 229, 0.3);\n}\n\n.ai-button:hover {\n  transform: translateY(-2px);\n  box-shadow: 0 8px 25px rgba(79, 70, 229, 0.4);\n}\n\n.ai-typing-indicator {\n  display: inline-flex;\n  gap: 4px;\n  padding: 8px 16px;\n  background: rgba(255, 255, 255, 0.05);\n  border-radius: 20px;\n  backdrop-filter: blur(10px);\n}\n\n.ai-typing-dot {\n  width: 6px;\n  height: 6px;\n  background: var(--ai-accent);\n  border-radius: 50%;\n  animation: typing 1.5s infinite;\n}\n\n.ai-typing-dot:nth-child(2) { animation-delay: 0.2s; }\n.ai-typing-dot:nth-child(3) { animation-delay: 0.4s; }\n\n@keyframes typing {\n  0%, 60%, 100% { transform: translateY(0); opacity: 0.4; }\n  30% { transform: translateY(-10px); opacity: 1; }\n}\n\n.ai-neural-bg {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  opacity: 0.1;\n  z-index: -1;\n  background-image: \n    radial-gradient(circle at 20% 30%, var(--ai-primary) 0%, transparent 50%),\n    radial-gradient(circle at 80% 70%, var(--ai-secondary) 0%, transparent 50%),\n    radial-gradient(circle at 50% 50%, var(--ai-accent) 0%, transparent 30%);\n}\n\n@layer base {\n  * {\n    @apply border-border;\n  }\n\n  html {\n    @apply h-full scroll-smooth;\n    font-family: 'Inter var', 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;\n    font-feature-settings: 'cv02', 'cv03', 'cv04', 'cv11';\n  }\n\n  body {\n    @apply font-sans antialiased h-full;\n    background: hsl(var(--background));\n    color: hsl(var(--foreground));\n    font-size: 15px;\n    line-height: 1.6;\n    margin: 0;\n    padding: 0;\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n    text-rendering: optimizeLegibility;\n  }\n\n  #root {\n    @apply h-full w-full;\n    min-height: 100vh;\n    background: hsl(var(--background));\n    color: hsl(var(--foreground));\n  }\n\n  h1, h2, h3, h4, h5, h6 {\n    @apply font-semibold tracking-tight;\n    color: hsl(var(--foreground));\n  }\n\n  h1 { \n    font-size: clamp(1.875rem, 4vw, 2.5rem); \n    line-height: 1.1; \n    font-weight: 700;\n    margin-bottom: 1.5rem;\n  }\n  h2 { \n    font-size: clamp(1.5rem, 3vw, 2rem); \n    line-height: 1.2; \n    font-weight: 600;\n    margin-bottom: 1.25rem;\n  }\n  h3 { \n    font-size: clamp(1.25rem, 2.5vw, 1.75rem); \n    line-height: 1.3; \n    font-weight: 600;\n    margin-bottom: 1rem;\n  }\n  h4 { \n    font-size: clamp(1.125rem, 2vw, 1.5rem); \n    line-height: 1.4; \n    font-weight: 500;\n    margin-bottom: 0.75rem;\n  }\n  h5 { \n    font-size: 1.125rem; \n    line-height: 1.5; \n    font-weight: 500;\n    margin-bottom: 0.5rem;\n  }\n  h6 { \n    font-size: 1rem; \n    line-height: 1.5; \n    font-weight: 500;\n    margin-bottom: 0.5rem;\n  }\n\n  p {\n    color: hsl(var(--foreground));\n    margin-bottom: 1rem;\n    line-height: 1.7;\n  }\n\n  button {\n    color: hsl(var(--foreground));\n    cursor: pointer;\n  }\n\n  input, textarea, select {\n    background: hsl(var(--background));\n    color: hsl(var(--foreground));\n    border: 1px solid hsl(var(--border));\n    border-radius: calc(var(--radius) - 2px);\n    font-size: 14px;\n  }\n\n  input:focus, textarea:focus, select:focus {\n    outline: 2px solid hsl(var(--ring));\n    outline-offset: 2px;\n  }\n}\n\n@layer components {\n  /* Modern Button Styles */\n  .btn-gradient {\n    background: var(--gradient-primary);\n    color: hsl(var(--primary-foreground));\n    border: none;\n    border-radius: calc(var(--radius));\n    box-shadow: var(--shadow-md);\n    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n  }\n\n  .btn-gradient:hover {\n    transform: translateY(-1px);\n    box-shadow: var(--shadow-lg);\n  }\n\n  .btn-gradient:active {\n    transform: translateY(0);\n    box-shadow: var(--shadow-sm);\n  }\n\n  /* Modern Card Styles */\n  .glass-card {\n    background: hsl(var(--card) / 0.8);\n    border: 1px solid hsl(var(--border) / 0.5);\n    border-radius: calc(var(--radius) + 4px);\n    box-shadow: var(--shadow-lg);\n    backdrop-filter: blur(12px);\n    -webkit-backdrop-filter: blur(12px);\n  }\n\n  .modern-card {\n    background: hsl(var(--card));\n    border: 1px solid hsl(var(--border));\n    border-radius: calc(var(--radius) + 2px);\n    box-shadow: var(--shadow-md);\n    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n  }\n\n  .modern-card:hover {\n    box-shadow: var(--shadow-lg);\n    transform: translateY(-2px);\n    border-color: hsl(var(--primary) / 0.5);\n  }\n\n  /* Enhanced Input Styles */\n  .modern-input {\n    background: hsl(var(--background));\n    border: 2px solid hsl(var(--border));\n    border-radius: calc(var(--radius));\n    padding: 0.75rem 1rem;\n    font-size: 14px;\n    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n  }\n\n  .modern-input:focus {\n    outline: none;\n    border-color: hsl(var(--primary));\n    box-shadow: 0 0 0 3px hsl(var(--primary) / 0.1);\n  }\n\n  .modern-input::placeholder {\n    color: hsl(var(--muted-foreground));\n  }\n\n  /* Tab Button Styles */\n  .tab-button {\n    @apply relative px-4 py-2.5 rounded-xl text-sm font-medium transition-all duration-300;\n    color: hsl(var(--muted-foreground));\n    background: hsl(var(--secondary) / 0.5);\n    border: 1px solid hsl(var(--border));\n  }\n\n  .tab-button:hover {\n    color: hsl(var(--foreground));\n    background: hsl(var(--secondary));\n    transform: translateY(-1px);\n    box-shadow: var(--shadow-sm);\n  }\n\n  .tab-button.active {\n    color: hsl(var(--primary-foreground));\n    background: var(--gradient-primary);\n    border-color: hsl(var(--primary));\n    box-shadow: var(--shadow-md);\n  }\n\n  .tab-button.active::after {\n    content: '';\n    position: absolute;\n    bottom: -1px;\n    left: 50%;\n    transform: translateX(-50%);\n    width: 6px;\n    height: 6px;\n    background: hsl(var(--primary-foreground));\n    border-radius: 50%;\n  }\n\n  /* Chat Message Styles */\n  .chat-message-user {\n    @apply ml-auto max-w-[80%] rounded-2xl rounded-br-md p-4;\n    background: var(--gradient-primary);\n    color: hsl(var(--primary-foreground));\n    box-shadow: var(--shadow-md);\n  }\n\n  .chat-message-bot {\n    @apply mr-auto max-w-[80%] rounded-2xl rounded-bl-md p-4;\n    background: hsl(var(--card));\n    border: 1px solid hsl(var(--border));\n    box-shadow: var(--shadow-sm);\n  }\n\n  /* Animated Elements */\n  .animate-fade-in {\n    animation: fadeIn 0.5s ease-out;\n  }\n\n  .animate-slide-up {\n    animation: slideUp 0.3s ease-out;\n  }\n\n  .animate-pulse-slow {\n    animation: pulse 3s infinite;\n  }\n\n  .animate-bounce-subtle {\n    animation: bounceSubtle 2s infinite;\n  }\n\n  /* Loading Spinner */\n  .spinner {\n    width: 20px;\n    height: 20px;\n    border: 2px solid hsl(var(--muted));\n    border-top: 2px solid hsl(var(--primary));\n    border-radius: 50%;\n    animation: spin 1s linear infinite;\n  }\n\n  /* Mobile Optimizations */\n  .responsive-padding {\n    @apply px-4 sm:px-6 lg:px-8;\n  }\n\n  .responsive-button {\n    @apply px-3 py-2 sm:px-4 sm:py-2.5 text-sm;\n  }\n\n  .mobile-hidden {\n    @apply hidden sm:inline;\n  }\n\n  .mobile-only {\n    @apply sm:hidden;\n  }\n}\n\n@layer utilities {\n  /* Custom Keyframes */\n  @keyframes fadeIn {\n    from {\n      opacity: 0;\n      transform: translateY(10px);\n    }\n    to {\n      opacity: 1;\n      transform: translateY(0);\n    }\n  }\n\n  @keyframes slideUp {\n    from {\n      transform: translateY(20px);\n      opacity: 0;\n    }\n    to {\n      transform: translateY(0);\n      opacity: 1;\n    }\n  }\n\n  @keyframes bounceSubtle {\n    0%, 100% {\n      transform: translateY(0);\n    }\n    50% {\n      transform: translateY(-4px);\n    }\n  }\n\n  @keyframes spin {\n    from {\n      transform: rotate(0deg);\n    }\n    to {\n      transform: rotate(360deg);\n    }\n  }\n\n  /* Utility Classes */\n  .text-gradient {\n    background: var(--gradient-primary);\n    -webkit-background-clip: text;\n    background-clip: text;\n    -webkit-text-fill-color: transparent;\n  }\n\n  .border-gradient {\n    position: relative;\n    background: hsl(var(--card));\n    border-radius: calc(var(--radius));\n  }\n\n  .border-gradient::before {\n    content: '';\n    position: absolute;\n    inset: 0;\n    padding: 1px;\n    background: var(--gradient-primary);\n    border-radius: inherit;\n    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);\n    mask-composite: exclude;\n  }\n\n  .scrollbar-thin {\n    scrollbar-width: thin;\n    scrollbar-color: hsl(var(--muted)) hsl(var(--background));\n  }\n\n  .scrollbar-thin::-webkit-scrollbar {\n    width: 6px;\n  }\n\n  .scrollbar-thin::-webkit-scrollbar-track {\n    background: hsl(var(--background));\n  }\n\n  .scrollbar-thin::-webkit-scrollbar-thumb {\n    background: hsl(var(--muted));\n    border-radius: 3px;\n  }\n\n  .scrollbar-thin::-webkit-scrollbar-thumb:hover {\n    background: hsl(var(--muted-foreground));\n  }\n}\n\n@layer components {\n  /* Tab Button Styles */\n  .tab-button {\n    @apply px-3 py-2 text-sm font-medium rounded-lg transition-all duration-200 border;\n    @apply border-transparent text-muted-foreground hover:text-foreground;\n    @apply hover:bg-accent hover:border-border;\n    min-width: 80px;\n    text-align: center;\n  }\n\n  .tab-button.active {\n    @apply bg-primary text-primary-foreground border-primary;\n    @apply shadow-sm;\n  }\n\n  .tab-button:hover:not(.active) {\n    @apply bg-accent text-accent-foreground;\n  }\n\n  /* Responsive Button Styles */\n  .responsive-button {\n    @apply flex items-center justify-center gap-2;\n  }\n\n  /* Mobile Hidden/Visible */\n  @media (max-width: 640px) {\n    .mobile-hidden {\n      @apply hidden;\n    }\n    .mobile-only {\n      @apply inline;\n    }\n    .responsive-button {\n      @apply px-2 py-2 min-w-[60px];\n    }\n  }\n\n  @media (min-width: 641px) {\n    .mobile-only {\n      @apply hidden;\n    }\n    .mobile-hidden {\n      @apply inline;\n    }\n  }\n\n  /* Responsive Padding */\n  .responsive-padding {\n    @apply px-2 sm:px-4 md:px-6;\n  }\n\n  /* Card Styles */\n  .card {\n    @apply bg-card text-card-foreground border border-border rounded-lg shadow-sm;\n  }\n\n  /* Input Styles */\n  .input {\n    @apply bg-background text-foreground border-border;\n  }\n\n  /* Button Styles */\n  .btn-primary {\n    @apply bg-primary text-primary-foreground hover:bg-primary/90;\n  }\n\n  .btn-secondary {\n    @apply bg-secondary text-secondary-foreground hover:bg-secondary/80;\n  }\n\n  .btn-accent {\n    @apply bg-accent text-accent-foreground hover:bg-accent/80;\n  }\n}\n\n/* Scrollbar Styles */\n::-webkit-scrollbar {\n  width: 8px;\n  height: 8px;\n}\n\n::-webkit-scrollbar-track {\n  @apply bg-muted;\n}\n\n::-webkit-scrollbar-thumb {\n  @apply bg-muted-foreground/30 rounded-full;\n}\n\n::-webkit-scrollbar-thumb:hover {\n  @apply bg-muted-foreground/50;\n}\n\n/* Focus Styles */\n:focus-visible {\n  @apply outline-none ring-2 ring-ring ring-offset-2 ring-offset-background;\n}\n\n/* Selection Styles */\n::selection {\n  @apply bg-primary/20;\n}\n\n/* Print Styles */\n@media print {\n  * {\n    print-color-adjust: exact;\n    -webkit-print-color-adjust: exact;\n  }\n}\n\n/* Custom animations */\n@keyframes pulse-slow {\n  0%, 100% { opacity: 1; }\n  50% { opacity: 0.5; }\n}\n\n@keyframes fade-in {\n  from { opacity: 0; transform: translateY(10px); }\n  to { opacity: 1; transform: translateY(0); }\n}\n\n@keyframes gradient-shift {\n  0% { background-position: 0% 50%; }\n  50% { background-position: 100% 50%; }\n  100% { background-position: 0% 50%; }\n}\n\n.animate-fade-in {\n  animation: fade-in 0.6s ease-out;\n}\n\n.animate-pulse-slow {\n  animation: pulse-slow 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;\n}\n\n.animate-gradient {\n  background-size: 200% 200%;\n  animation: gradient-shift 3s ease infinite;\n}","size_bytes":35196},"client/src/main.tsx":{"content":"\nimport { StrictMode } from 'react'\nimport { createRoot } from 'react-dom/client'\nimport './index.css'\nimport App from './App.tsx'\nimport { ThemeProvider } from './contexts/ThemeContext'\nimport { ToastProvider } from './contexts/ToastContext'\nimport { Toaster } from './components/ui/toaster'\n\n// Global hata yakalama\nwindow.addEventListener('unhandledrejection', (event) => {\n  console.error('Yakalanmamış Promise hatası:', event.reason);\n  // Event'i engellemeyerek React'ın kendi hata sınırlarının çalışmasına izin ver\n});\n\nwindow.addEventListener('error', (event) => {\n  console.error('Genel JavaScript hatası:', event.error);\n});\n\n// Root elemanının var olduğundan emin ol\nconst rootElement = document.getElementById('root');\nif (!rootElement) {\n  throw new Error('Root element not found');\n}\n\n// DOM hazır kontrolü\nconst startApp = () => {\n  console.log('Uygulama başlatılıyor...');\n  \n  const root = createRoot(rootElement);\n  \n  root.render(\n    <StrictMode>\n      <ThemeProvider>\n        <ToastProvider>\n          <App />\n          <Toaster />\n        </ToastProvider>\n      </ThemeProvider>\n    </StrictMode>\n  );\n};\n\n// DOM hazır olduğunda başlat\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', startApp);\n} else {\n  startApp();\n}\n","size_bytes":1307},"client/src/components/AIStatusPanel.tsx":{"content":"import React, { useState, useEffect } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle } from './ui/card';\nimport { Badge } from './ui/badge';\nimport { Progress } from './ui/progress';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from './ui/tabs';\nimport { AdvancedAI } from '../lib/AdvancedAI';\nimport { Brain, Zap, TrendingUp, Cpu, Eye, Sparkles } from 'lucide-react';\n\ninterface AIStatusPanelProps {\n  advancedAI: AdvancedAI;\n  isVisible: boolean;\n  onClose: () => void;\n}\n\nexport const AIStatusPanel: React.FC<AIStatusPanelProps> = ({ \n  advancedAI, \n  isVisible, \n  onClose \n}) => {\n  const [aiStatus, setAiStatus] = useState<any>(null);\n  const [refreshInterval, setRefreshInterval] = useState<NodeJS.Timeout | null>(null);\n\n  useEffect(() => {\n    if (isVisible) {\n      // İlk yükleme\n      updateAIStatus();\n\n      // Her 3 saniyede bir güncelle\n      const interval = setInterval(updateAIStatus, 3000);\n      setRefreshInterval(interval);\n\n      return () => {\n        if (interval) clearInterval(interval);\n      };\n    } else {\n      if (refreshInterval) {\n        clearInterval(refreshInterval);\n        setRefreshInterval(null);\n      }\n    }\n  }, [isVisible, advancedAI]);\n\n  const updateAIStatus = () => {\n    try {\n      const status = advancedAI.getAIStatus();\n      setAiStatus(status);\n    } catch (error) {\n      console.error('AI durumu alınırken hata:', error);\n    }\n  };\n\n  if (!isVisible || !aiStatus) return null;\n\n  const getCapabilityColor = (level: number) => {\n    if (level >= 90) return 'bg-green-500';\n    if (level >= 70) return 'bg-blue-500';\n    if (level >= 50) return 'bg-yellow-500';\n    return 'bg-red-500';\n  };\n\n  const getCapabilityBadge = (level: number) => {\n    if (level >= 95) return { text: 'Usta', color: 'bg-gradient-to-r from-purple-500 to-pink-500' };\n    if (level >= 90) return { text: 'Uzman', color: 'bg-green-500' };\n    if (level >= 80) return { text: 'İleri', color: 'bg-blue-500' };\n    if (level >= 70) return { text: 'Orta', color: 'bg-yellow-500' };\n    return { text: 'Başlangıç', color: 'bg-gray-500' };\n  };\n\n  return (\n    <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4\">\n      <div className=\"bg-white dark:bg-gray-800 rounded-2xl max-w-6xl w-full max-h-[90vh] overflow-auto shadow-2xl\">\n        <div className=\"flex justify-between items-center p-6 border-b border-gray-200 dark:border-gray-700\">\n          <div className=\"flex items-center gap-3\">\n            <div className=\"p-2 bg-gradient-to-r from-blue-500 to-purple-500 rounded-lg\">\n              <Brain className=\"w-6 h-6 text-white\" />\n            </div>\n            <div>\n              <h2 className=\"text-2xl font-bold text-gray-900 dark:text-white\">\n                Gelişmiş AI Durumu\n              </h2>\n              <p className=\"text-gray-600 dark:text-gray-400\">\n                Yapay zeka yetenekleri ve öğrenme metrikleri\n              </p>\n            </div>\n          </div>\n          <button\n            onClick={onClose}\n            className=\"text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 \n                     p-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors\"\n          >\n            <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M6 18L18 6M6 6l12 12\"></path>\n            </svg>\n          </button>\n        </div>\n\n        <div className=\"p-6\">\n          <Tabs defaultValue=\"overview\" className=\"w-full\">\n            <TabsList className=\"grid w-full grid-cols-4\">\n              <TabsTrigger value=\"overview\" className=\"flex items-center gap-2\">\n                <Eye className=\"w-4 h-4\" />\n                Genel Bakış\n              </TabsTrigger>\n              <TabsTrigger value=\"capabilities\" className=\"flex items-center gap-2\">\n                <Zap className=\"w-4 h-4\" />\n                Yetenekler\n              </TabsTrigger>\n              <TabsTrigger value=\"metrics\" className=\"flex items-center gap-2\">\n                <TrendingUp className=\"w-4 h-4\" />\n                Metrikler\n              </TabsTrigger>\n              <TabsTrigger value=\"neural\" className=\"flex items-center gap-2\">\n                <Cpu className=\"w-4 h-4\" />\n                Sinir Ağları\n              </TabsTrigger>\n            </TabsList>\n\n            <TabsContent value=\"overview\" className=\"mt-6\">\n              <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6\">\n                <Card className=\"bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-blue-900/20 dark:to-indigo-900/20\">\n                  <CardHeader className=\"pb-3\">\n                    <CardTitle className=\"text-lg flex items-center gap-2\">\n                      <Brain className=\"w-5 h-5 text-blue-600\" />\n                      Genel Zeka\n                    </CardTitle>\n                  </CardHeader>\n                  <CardContent>\n                    <div className=\"text-3xl font-bold text-blue-600\">\n                      {aiStatus.overallIntelligence.toFixed(1)}\n                    </div>\n                    <p className=\"text-sm text-gray-600 dark:text-gray-400\">\n                      Gelişmiş AI Seviyesi\n                    </p>\n                  </CardContent>\n                </Card>\n\n                <Card className=\"bg-gradient-to-br from-green-50 to-emerald-100 dark:from-green-900/20 dark:to-emerald-900/20\">\n                  <CardHeader className=\"pb-3\">\n                    <CardTitle className=\"text-lg flex items-center gap-2\">\n                      <TrendingUp className=\"w-5 h-5 text-green-600\" />\n                      Evrim İlerlemesi\n                    </CardTitle>\n                  </CardHeader>\n                  <CardContent>\n                    <div className=\"text-3xl font-bold text-green-600\">\n                      {aiStatus.evolutionProgress.toFixed(1)}%\n                    </div>\n                    <Progress value={aiStatus.evolutionProgress} className=\"mt-2\" />\n                  </CardContent>\n                </Card>\n\n                <Card className=\"bg-gradient-to-br from-purple-50 to-violet-100 dark:from-purple-900/20 dark:to-violet-900/20\">\n                  <CardHeader className=\"pb-3\">\n                    <CardTitle className=\"text-lg flex items-center gap-2\">\n                      <Cpu className=\"w-5 h-5 text-purple-600\" />\n                      Sinir Ağı Gücü\n                    </CardTitle>\n                  </CardHeader>\n                  <CardContent>\n                    <div className=\"text-3xl font-bold text-purple-600\">\n                      {(aiStatus.neuralPathwayStrength * 100).toFixed(1)}%\n                    </div>\n                    <p className=\"text-sm text-gray-600 dark:text-gray-400\">\n                      Bağlantı Kuvveti\n                    </p>\n                  </CardContent>\n                </Card>\n\n                <Card className=\"bg-gradient-to-br from-orange-50 to-red-100 dark:from-orange-900/20 dark:to-red-900/20\">\n                  <CardHeader className=\"pb-3\">\n                    <CardTitle className=\"text-lg flex items-center gap-2\">\n                      <Sparkles className=\"w-5 h-5 text-orange-600\" />\n                      Toplam Etkileşim\n                    </CardTitle>\n                  </CardHeader>\n                  <CardContent>\n                    <div className=\"text-3xl font-bold text-orange-600\">\n                      {aiStatus.metrics.totalInteractions.toLocaleString('tr')}\n                    </div>\n                    <p className=\"text-sm text-gray-600 dark:text-gray-400\">\n                      Öğrenme Fırsatı\n                    </p>\n                  </CardContent>\n                </Card>\n              </div>\n            </TabsContent>\n\n            <TabsContent value=\"capabilities\" className=\"mt-6\">\n              <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n                {aiStatus.capabilities.map((capability: any) => {\n                  const badge = getCapabilityBadge(capability.level);\n                  return (\n                    <Card key={capability.name} className=\"hover:shadow-lg transition-shadow\">\n                      <CardHeader className=\"pb-3\">\n                        <div className=\"flex justify-between items-start\">\n                          <CardTitle className=\"text-base\">{capability.name}</CardTitle>\n                          <Badge className={`${badge.color} text-white`}>\n                            {badge.text}\n                          </Badge>\n                        </div>\n                      </CardHeader>\n                      <CardContent>\n                        <p className=\"text-sm text-gray-600 dark:text-gray-400 mb-3\">\n                          {capability.description}\n                        </p>\n                        <div className=\"flex items-center justify-between mb-2\">\n                          <span className=\"text-sm font-medium\">Seviye</span>\n                          <span className=\"text-sm font-bold\">{capability.level.toFixed(1)}%</span>\n                        </div>\n                        <Progress \n                          value={capability.level} \n                          className=\"h-2\"\n                        />\n                      </CardContent>\n                    </Card>\n                  );\n                })}\n              </div>\n            </TabsContent>\n\n            <TabsContent value=\"metrics\" className=\"mt-6\">\n              <div className=\"grid grid-cols-1 md:grid-cols-2 gap-6\">\n                <Card>\n                  <CardHeader>\n                    <CardTitle>Öğrenme Performansı</CardTitle>\n                  </CardHeader>\n                  <CardContent className=\"space-y-4\">\n                    <div className=\"flex justify-between\">\n                      <span>Öğrenme Hızı</span>\n                      <span className=\"font-bold\">{aiStatus.metrics.learningRate.toFixed(2)}x</span>\n                    </div>\n                    <div className=\"flex justify-between\">\n                      <span>Uyum Hızı</span>\n                      <span className=\"font-bold\">{aiStatus.metrics.adaptationSpeed.toFixed(2)}x</span>\n                    </div>\n                    <div className=\"flex justify-between\">\n                      <span>Bilgi Saklama</span>\n                      <span className=\"font-bold\">{(aiStatus.metrics.knowledgeRetention * 100).toFixed(1)}%</span>\n                    </div>\n                  </CardContent>\n                </Card>\n\n                <Card>\n                  <CardHeader>\n                    <CardTitle>Bilişsel Yetenekler</CardTitle>\n                  </CardHeader>\n                  <CardContent className=\"space-y-4\">\n                    <div className=\"flex justify-between\">\n                      <span>Desen Tanıma</span>\n                      <span className=\"font-bold\">{aiStatus.metrics.patternRecognition.toFixed(2)}x</span>\n                    </div>\n                    <div className=\"flex justify-between\">\n                      <span>Yaratıcılık İndeksi</span>\n                      <span className=\"font-bold\">{aiStatus.metrics.creativityIndex.toFixed(2)}x</span>\n                    </div>\n                    <div className=\"flex justify-between\">\n                      <span>Problem Çözme</span>\n                      <span className=\"font-bold\">{aiStatus.metrics.problemSolvingAbility.toFixed(2)}x</span>\n                    </div>\n                  </CardContent>\n                </Card>\n              </div>\n            </TabsContent>\n\n            <TabsContent value=\"neural\" className=\"mt-6\">\n              <Card>\n                <CardHeader>\n                  <CardTitle>Sinir Ağı Aktivitesi</CardTitle>\n                  <p className=\"text-sm text-gray-600 dark:text-gray-400\">\n                    AI'ın sinir yolları ve bağlantı gücü\n                  </p>\n                </CardHeader>\n                <CardContent>\n                  <div className=\"text-center py-12\">\n                    <Cpu className=\"w-16 h-16 mx-auto text-blue-500 mb-4\" />\n                    <h3 className=\"text-lg font-semibold mb-2\">Sinir Ağları Aktif</h3>\n                    <p className=\"text-gray-600 dark:text-gray-400\">\n                      Ortalama bağlantı gücü: {(aiStatus.neuralPathwayStrength * 100).toFixed(1)}%\n                    </p>\n                    <div className=\"mt-4\">\n                      <Progress value={aiStatus.neuralPathwayStrength * 100} className=\"w-64 mx-auto\" />\n                    </div>\n                  </div>\n                </CardContent>\n              </Card>\n            </TabsContent>\n          </Tabs>\n        </div>\n      </div>\n    </div>\n  );\n};","size_bytes":12817},"client/src/components/BatchTrainingModal.tsx":{"content":"import React, { useState } from 'react';\nimport { X, AlertCircle, Upload, FileText, PlusCircle, Trash2 } from 'lucide-react';\nimport { useTheme } from '../contexts/ThemeContext';\n\nexport interface TrainingPair {\n  input: string;\n  output: string;\n}\n\ninterface BatchTrainingModalProps {\n  isOpen: boolean;\n  onSubmit: (pairs: TrainingPair[]) => void;\n  onClose: () => void;\n  isProcessing?: boolean;\n  progress?: number;\n}\n\nenum TrainingMode {\n  PAIR = 'pair',\n  BULK = 'bulk',\n  PARAGRAPH = 'paragraph'\n}\n\nconst BatchTrainingModal: React.FC<BatchTrainingModalProps> = ({\n  isOpen,\n  onSubmit,\n  onClose,\n  isProcessing = false,\n  progress = 0\n}) => {\n  const [trainingPairs, setTrainingPairs] = useState<TrainingPair[]>([\n    { input: '', output: '' }\n  ]);\n  const [bulkText, setBulkText] = useState('');\n  const [paragraphText, setParagraphText] = useState('');\n  const [mode, setMode] = useState<TrainingMode>(TrainingMode.PAIR);\n  const [error, setError] = useState('');\n  const { isDarkMode } = useTheme();\n\n  const handleAddPair = () => {\n    setTrainingPairs([...trainingPairs, { input: '', output: '' }]);\n  };\n\n  const handleRemovePair = (index: number) => {\n    const newPairs = [...trainingPairs];\n    newPairs.splice(index, 1);\n    setTrainingPairs(newPairs);\n  };\n\n  const handlePairChange = (index: number, field: 'input' | 'output', value: string) => {\n    const newPairs = [...trainingPairs];\n    newPairs[index][field] = value;\n    setTrainingPairs(newPairs);\n  };\n\n  const handleSubmit = () => {\n    setError('');\n\n    if (mode === TrainingMode.PAIR) {\n      // En az bir çiftin her iki alanı da dolu olmalı\n      const validPairs = trainingPairs.filter(pair => pair.input.trim() && pair.output.trim());\n\n      if (validPairs.length === 0) {\n        setError('En az bir soru-cevap çifti girmelisiniz.');\n        return;\n      }\n\n      onSubmit(validPairs);\n    } \n    else if (mode === TrainingMode.BULK) {\n      // Toplu metin formatı: soru=>cevap\n      const pairs: TrainingPair[] = [];\n\n      // Satır sonlarını standardize et (Windows ve Unix satır sonları için)\n      const normalizedText = bulkText.replace(/\\r\\n/g, '\\n');\n      const lines = normalizedText.split('\\n');\n\n      for (let i = 0; i < lines.length; i++) {\n        const line = lines[i];\n        const trimmedLine = line.trim();\n\n        // Boş satırları atla\n        if (!trimmedLine) continue;\n\n        if (trimmedLine.includes('=>')) {\n          // => işareti ile ayrılmış bir satır\n          try {\n            const parts = trimmedLine.split('=>');\n            if (parts.length >= 2) {\n              const input = parts[0].trim();\n              // Birden fazla => işareti varsa, ilkinden sonraki tüm parçaları birleştir\n              const output = parts.slice(1).join('=>').trim();\n\n              if (input && output) {\n                pairs.push({ input, output });\n              }\n            }\n          } catch (error) {\n            console.error('Satır işleme hatası:', error);\n          }\n        } \n        else if (trimmedLine.startsWith('Giriş:') || trimmedLine.startsWith('Girdi:') || trimmedLine.startsWith('Soru:')) {\n          // Eski format için destek devam ediyor (Giriş/Çıkış formatı)\n          const inputPart = trimmedLine.replace(/^(Giriş:|Girdi:|Soru:)\\s*/, '').trim();\n\n          // Bir sonraki satırı kontrol et\n          if (i + 1 < lines.length) {\n            const nextLine = lines[i + 1].trim();\n\n            if (nextLine.startsWith('Çıkış:') || nextLine.startsWith('Çıktı:') || nextLine.startsWith('Cevap:')) {\n              const outputPart = nextLine.replace(/^(Çıkış:|Çıktı:|Cevap:)\\s*/, '').trim();\n\n              if (inputPart && outputPart) {\n                pairs.push({\n                  input: inputPart,\n                  output: outputPart\n                });\n              }\n\n              // Çıkış satırını atladık, sonraki satırdan devam et\n              i++;\n            }\n          }\n        }\n      }\n\n      if (pairs.length === 0) {\n        setError('Geçerli bir veri bulunamadı. Her satır için \"soru=>cevap\" formatında veriler girmelisiniz.');\n        return;\n      }\n\n      console.log(`✅ ${pairs.length} adet veri çifti hazırlandı - sınır yok!`);\n\n      onSubmit(pairs);\n    }\n    else if (mode === TrainingMode.PARAGRAPH) {\n      // Paragraftan soru-cevap çiftleri çıkar\n      if (!paragraphText.trim()) {\n        setError('Lütfen bir metin girin.');\n        return;\n      }\n\n      // Metni cümlelere ayır\n      const sentences = paragraphText\n        .replace(/([.!?])\\s+/g, '$1|')\n        .split('|')\n        .filter(s => s.trim().length > 0);\n\n      if (sentences.length < 2) {\n        setError('Metin en az iki cümle içermelidir.');\n        return;\n      }\n\n      // Basit soru üretme kuralları\n      const pairs: TrainingPair[] = [];\n\n      // Her cümle için birkaç soru oluştur\n      for (const sentence of sentences) {\n        const trimmed = sentence.trim();\n\n        // Konu-yüklem ayır\n        const parts = trimmed.split(/\\s+/);\n        if (parts.length >= 3) {\n          // Konuyu bul (ilk 1-2 kelime)\n          const subject = parts.slice(0, Math.min(2, Math.floor(parts.length / 3))).join(' ');\n\n          // \"ne\" sorusu üret\n          if (subject) {\n            pairs.push({\n              input: `${subject} ne?`,\n              output: trimmed\n            });\n          }\n\n          // \"ne yapıyor\" sorusu üret\n          if (parts.length > 3) {\n            pairs.push({\n              input: `${subject} ne yapıyor?`,\n              output: trimmed\n            });\n          }\n\n          // Kim sorusu (eğer büyük harfle başlayan bir kelime varsa)\n          const properNouns = parts.filter(p => p.length > 1 && /^[A-ZĞÜŞİÖÇ]/.test(p));\n          if (properNouns.length > 0) {\n            pairs.push({\n              input: `Kim ${parts.slice(Math.min(3, parts.length - 1)).join(' ')}?`,\n              output: properNouns[0]\n            });\n          }\n        }\n      }\n\n      // En azından paragrafı ve başlık sorusunu ekle\n      pairs.push({\n        input: \"Bu paragrafta ne anlatılıyor?\",\n        output: paragraphText\n      });\n\n      if (pairs.length === 0) {\n        setError('Metinden soru-cevap çiftleri üretilemedi. Lütfen daha karmaşık bir metin girin.');\n        return;\n      }\n\n      onSubmit(pairs);\n    }\n  };\n\n  if (!isOpen) return null;\n\n  return (\n    <div className=\"fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-50 overflow-y-auto\">\n      <div className=\"w-full max-w-4xl max-h-[90vh] overflow-y-auto rounded-xl shadow-lg bg-white dark:bg-gray-800 text-gray-800 dark:text-gray-200\">\n        <div className=\"flex items-center justify-between p-4 border-b border-gray-200 dark:border-gray-700\">\n          <h3 className=\"text-lg font-semibold\">Toplu Eğitim</h3>\n          {!isProcessing && (\n            <button \n              className=\"p-1 rounded-full transition-colors hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200\" \n              aria-label=\"Kapat\"\n              onClick={onClose}\n            >\n              <X className=\"h-5 w-5\" />\n            </button>\n          )}\n        </div>\n\n        {isProcessing ? (\n          <div className=\"p-6 space-y-4\">\n            <div className=\"text-center space-y-2\">\n              <h4 className=\"text-lg font-medium\">Eğitim Sürüyor</h4>\n              <p className=\"text-sm text-gray-600 dark:text-gray-400\">\n                Veriler aşamalı olarak işleniyor, lütfen bekleyin...\n              </p>\n            </div>\n            \n            <div className=\"relative pt-1\">\n              <div className=\"flex mb-2 items-center justify-between\">\n                <div>\n                  <span className=\"text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full bg-primary-200 text-primary-800 dark:bg-primary-900 dark:text-primary-200\">\n                    İlerleme\n                  </span>\n                </div>\n                <div className=\"text-right\">\n                  <span className=\"text-sm font-bold inline-block text-primary-800 dark:text-primary-200\">\n                    {progress}%\n                  </span>\n                </div>\n              </div>\n              \n              <div className=\"overflow-hidden h-3 mb-4 text-xs flex rounded bg-primary-200 dark:bg-gray-700\">\n                <div \n                  style={{ width: `${progress}%` }} \n                  className=\"shadow-none flex flex-col text-center whitespace-nowrap text-white justify-center bg-primary-500 dark:bg-primary-600 transition-all duration-500 ease-out\"\n                />\n              </div>\n              \n              {/* Progress aşamaları */}\n              <div className=\"flex justify-between text-xs text-gray-600 dark:text-gray-400 mt-2\">\n                <span className={progress >= 10 ? 'text-green-600 dark:text-green-400 font-medium' : ''}>\n                  Hazırlık {progress >= 10 ? '✓' : ''}\n                </span>\n                <span className={progress >= 50 ? 'text-green-600 dark:text-green-400 font-medium' : ''}>\n                  İşleme {progress >= 50 ? '✓' : ''}\n                </span>\n                <span className={progress >= 95 ? 'text-green-600 dark:text-green-400 font-medium' : ''}>\n                  Tamamlanıyor {progress >= 95 ? '✓' : ''}\n                </span>\n              </div>\n            </div>\n            \n            {/* Animasyonlu loading göstergesi */}\n            <div className=\"flex justify-center\">\n              <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-primary-500\"></div>\n            </div>\n          </div>\n        ) : (\n          <>\n            <div className=\"p-4 space-y-4\">\n              <div className=\"flex justify-center border-b border-gray-200 dark:border-gray-700 pb-3\">\n                <div className=\"flex space-x-2\">\n                  <button\n                    className={`px-4 py-2 rounded-md ${\n                      mode === TrainingMode.PAIR \n                        ? 'btn-gradient text-primary-foreground' \n                        : 'bg-secondary hover:bg-secondary/80 text-secondary-foreground'\n                    } transition-all duration-200`}\n                    onClick={() => setMode(TrainingMode.PAIR)}\n                  >\n                    Manuel Giriş\n                  </button>\n                  <button\n                    className={`px-4 py-2 rounded-md ${\n                      mode === TrainingMode.BULK \n                        ? 'btn-gradient text-primary-foreground' \n                        : 'bg-secondary hover:bg-secondary/80 text-secondary-foreground'\n                    } transition-all duration-200`}\n                    onClick={() => setMode(TrainingMode.BULK)}\n                  >\n                    Toplu Metin\n                  </button>\n                  <button\n                    className={`px-4 py-2 rounded-md ${\n                      mode === TrainingMode.PARAGRAPH \n                        ? 'btn-gradient text-primary-foreground' \n                        : 'bg-secondary hover:bg-secondary/80 text-secondary-foreground'\n                    } transition-all duration-200`}\n                    onClick={() => setMode(TrainingMode.PARAGRAPH)}\n                  >\n                    Paragraf Analizi\n                  </button>\n                </div>\n              </div>\n\n              {error && (\n                <div className=\"bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-md p-3 flex items-start space-x-2\">\n                  <AlertCircle className=\"h-5 w-5 text-red-500 dark:text-red-400 flex-shrink-0 mt-0.5\" />\n                  <p className=\"text-sm text-red-600 dark:text-red-300\">{error}</p>\n                </div>\n              )}\n\n              {mode === TrainingMode.PAIR && (\n                <div className=\"space-y-4\">\n                  <p className=\"text-sm text-gray-600 dark:text-gray-400\">\n                    Yapay zekanın öğrenmesi için birden fazla soru-cevap çifti ekleyebilirsiniz.\n                  </p>\n\n                  {trainingPairs.map((pair, index) => (\n                    <div key={index} className=\"border border-gray-200 dark:border-gray-700 rounded-lg p-3 space-y-3\">\n                      <div className=\"flex items-center justify-between\">\n                        <h4 className=\"text-sm font-medium\">{index + 1}. Soru-Cevap Çifti</h4>\n                        {trainingPairs.length > 1 && (\n                          <button\n                            onClick={() => handleRemovePair(index)}\n                            className=\"text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300\"\n                            title=\"Bu çifti sil\"\n                          >\n                            <Trash2 className=\"h-4 w-4\" />\n                          </button>\n                        )}\n                      </div>\n\n                      <div>\n                        <label className=\"block text-xs text-gray-600 dark:text-gray-400 mb-1\">\n                          Soru / Girdi\n                        </label>\n                        <input\n                          type=\"text\"\n                          value={pair.input}\n                          onChange={(e) => handlePairChange(index, 'input', e.target.value)}\n                          className=\"w-full p-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-primary-500\"\n                          placeholder=\"Örn: Türkiye'nin başkenti neresidir?\"\n                        />\n                      </div>\n\n                      <div>\n                        <label className=\"block text-xs text-gray-600 dark:text-gray-400 mb-1\">\n                          Cevap / Çıktı\n                        </label>\n                        <input\n                          type=\"text\"\n                          value={pair.output}\n                          onChange={(e) => handlePairChange(index, 'output', e.target.value)}\n                          className=\"w-full p-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-primary-500\"\n                          placeholder=\"Örn: Türkiye'nin başkenti Ankara'dır.\"\n                        />\n                      </div>\n                    </div>\n                  ))}\n\n                  <button\n                    onClick={handleAddPair}\n                    className=\"flex items-center text-primary-600 dark:text-primary-400 hover:text-primary-700 dark:hover:text-primary-300 text-sm\"\n                  >\n                    <PlusCircle className=\"h-4 w-4 mr-1\" />\n                    Yeni Soru-Cevap Çifti Ekle\n                  </button>\n                </div>\n              )}\n\n              {mode === TrainingMode.BULK && (\n                <div className=\"space-y-4\">\n                  <p className=\"text-sm text-gray-600 dark:text-gray-400\">\n                    Aşağıdaki formatta toplu metin girebilirsiniz. Her satır için <span className=\"font-mono text-xs bg-gray-100 dark:bg-gray-700 px-1 py-0.5 rounded\">soru{\"=>\"}cevap</span> formatını kullanın:\n                  </p>\n\n                  <div className=\"bg-gray-50 dark:bg-gray-900/50 border border-gray-200 dark:border-gray-700 rounded p-3 text-sm text-gray-700 dark:text-gray-300\">\n                    <p className=\"whitespace-pre-wrap font-mono text-xs\">\n                      Merhaba nasılsın?{\"=>\"}İyiyim teşekkürler, size nasıl yardımcı olabilirim?{'\\n'}\n                      Bugün hava nasıl?{\"=>\"}Bugün hava güneşli ve sıcak.{'\\n'}\n                      Türkiye'nin başkenti neresi?{\"=>\"}Ankara{'\\n'}\n                      En büyük gezegen hangisidir?{\"=>\"}Jüpiter{'\\n'}\n                      Suyun kaynama noktası kaçtır?{\"=>\"}100 derece Celsius (deniz seviyesinde)\n                    </p>\n                  </div>\n\n                  <div className=\"bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-md p-3 text-sm\">\n                    <p className=\"font-medium text-blue-800 dark:text-blue-300\">İpuçları:</p>\n                    <ul className=\"list-disc ml-5 mt-1 space-y-1 text-xs text-blue-700 dark:text-blue-300\">\n                      <li>Her satırda bir soru-cevap çifti olmalıdır</li>\n                      <li>Soru ve cevap {\"=>\"} işareti ile ayrılmalıdır</li>\n                      <li>Birden fazla satır girerek çoklu örnekler verebilirsiniz</li>\n                      <li>Boş satırlar otomatik olarak atlanır</li>\n                    </ul>\n                  </div>\n\n                  <textarea\n                    value={bulkText}\n                    onChange={(e) => setBulkText(e.target.value)}\n                    rows={10}\n                    className=\"w-full p-3 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-primary-500\"\n                    placeholder=\"Soru1=>Cevap1&#10;Soru2=>Cevap2&#10;Soru3=>Cevap3\"\n                  />\n                </div>\n              )}\n\n              {mode === TrainingMode.PARAGRAPH && (\n                <div className=\"space-y-4\">\n                  <p className=\"text-sm text-gray-600 dark:text-gray-400\">\n                    Bir metin paragrafı girin. Sistem otomatik olarak bu metinden soru-cevap çiftleri üretecektir.\n                  </p>\n\n                  <textarea\n                    value={paragraphText}\n                    onChange={(e) => setParagraphText(e.target.value)}\n                    rows={8}\n                    className=\"w-full p-3 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-primary-500\"\n                    placeholder=\"Örnek: Ahmet Ankara'da yaşıyor. O bir yazılım mühendisi olarak çalışıyor. Hafta sonları kitap okumayı ve müzik dinlemeyi seviyor.\"\n                  />\n\n                  <div className=\"bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-md p-3 text-sm text-yellow-800 dark:text-yellow-300\">\n                    <p className=\"font-medium\">Nasıl Çalışır?</p>\n                    <ul className=\"list-disc ml-5 mt-1 space-y-1 text-xs\">\n                      <li>Sistem paragrafı cümlelere ayırır</li>\n                      <li>Her cümle için olası sorular üretir</li>\n                      <li>Örneğin, \"<b>Ahmet Ankara'da yaşıyor</b>\" cümlesi için, \"<i>Ahmet nerede yaşıyor?</i>\" gibi sorular oluşturur</li>\n                      <li>Daha karmaşık metin, daha kaliteli soru-cevap çiftleri oluşturur</li>\n                    </ul>\n                  </div>\n                </div>\n              )}\n            </div>\n\n            <div className=\"p-4 border-t border-gray-200 dark:border-gray-700 flex justify-end space-x-2\">\n              <button\n                className=\"px-4 py-2 rounded-md border border-border bg-background hover:bg-secondary text-foreground transition-all duration-200\"\n                onClick={onClose}\n              >\n                İptal\n              </button>\n\n              <button\n                className=\"px-4 py-2 rounded-md btn-gradient text-primary-foreground hover:shadow-lg transition-all duration-200\"\n                onClick={handleSubmit}\n              >\n                Eğitimi Başlat\n              </button>\n            </div>\n          </>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default BatchTrainingModal;\n","size_bytes":19835},"client/src/components/CellDetailsModal.tsx":{"content":"import React from 'react';\nimport { X, Info, ArrowRight, Activity, BarChart2, Clock } from 'lucide-react';\nimport { NetworkNode, Relation } from '@/lib/NeuralNetworkUtils';\n\ninterface CellDetailsModalProps {\n  isOpen: boolean;\n  node: NetworkNode | null;\n  relations: Relation[];\n  bidirectionalRelations: Relation[];\n  onClose: () => void;\n}\n\nconst CellDetailsModal: React.FC<CellDetailsModalProps> = ({\n  isOpen,\n  node,\n  relations,\n  bidirectionalRelations,\n  onClose\n}) => {\n  if (!isOpen || !node) return null;\n  \n  // İnsan tarafından okunabilir tarih formatı\n  const formatDate = (timestamp: number) => {\n    return new Date(timestamp).toLocaleString('tr-TR', {\n      day: '2-digit',\n      month: '2-digit',\n      year: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit'\n    });\n  };\n  \n  // Sınıflandırma oranını görsel barla gösterme\n  const ProgressBar = ({ value, max, color }: { value: number, max: number, color: string }) => {\n    const percentage = Math.min(100, Math.max(0, (value / max) * 100));\n    \n    return (\n      <div className=\"w-full h-2 bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden\">\n        <div \n          className={`h-full ${color} rounded-full transition-all duration-300`}\n          style={{ width: `${percentage}%` }}\n        />\n      </div>\n    );\n  };\n  \n  // İlişkiler\n  const nodeRelations = relations.filter(rel => \n    rel.userWord === node.word || rel.systemWord === node.word\n  );\n  \n  // Çift yönlü ilişkiler\n  const nodeBiRelations = bidirectionalRelations.filter(rel => \n    rel.userWord === node.word || rel.systemWord === node.word\n  );\n\n  const allRelations = [...nodeRelations, ...nodeBiRelations];\n  \n  return (\n    <div className=\"fixed inset-0 bg-black/50 flex items-center justify-center p-2 md:p-4 z-50 overflow-y-auto\">\n      <div className=\"w-full max-w-2xl max-h-[90vh] overflow-y-auto rounded-xl shadow-lg bg-gray-50 dark:bg-gray-800 text-gray-800 dark:text-gray-200\">\n        <div className=\"flex items-center justify-between p-4 border-b border-gray-200 dark:border-gray-700\">\n          <div className=\"flex items-center space-x-2\">\n            <Info className=\"h-5 w-5 text-primary-500\" />\n            <h3 className=\"text-lg font-semibold\">Düğüm Detayları</h3>\n          </div>\n          <button \n            className=\"p-1 rounded-full transition-colors hover:bg-gray-200 dark:hover:bg-gray-700 text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200\" \n            aria-label=\"Kapat\"\n            onClick={onClose}\n          >\n            <X className=\"h-5 w-5\" />\n          </button>\n        </div>\n        \n        <div className=\"p-4\">\n          <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n            <div className=\"space-y-3\">\n              <div>\n                <h4 className=\"text-sm font-medium text-gray-600 dark:text-gray-400\">Kelime</h4>\n                <p className=\"text-xl font-bold text-primary-600 dark:text-primary-400\">{node.word}</p>\n              </div>\n              \n              <div>\n                <h4 className=\"text-sm font-medium text-gray-600 dark:text-gray-400\">Kimlik</h4>\n                <p className=\"text-xs font-mono bg-gray-100 dark:bg-gray-700 p-1 rounded\">{node.id}</p>\n              </div>\n              \n              <div>\n                <h4 className=\"text-sm font-medium text-gray-600 dark:text-gray-400 mb-1\">Aktivasyon Seviyesi</h4>\n                <ProgressBar value={node.activation} max={1} color=\"bg-blue-500\" />\n                <p className=\"text-xs text-gray-500 dark:text-gray-400 mt-1\">{Math.round(node.activation * 100)}%</p>\n              </div>\n              \n              {node.category && (\n                <div>\n                  <h4 className=\"text-sm font-medium text-gray-600 dark:text-gray-400\">Kategori</h4>\n                  <div className=\"inline-block bg-primary-100 dark:bg-primary-900/30 text-primary-700 dark:text-primary-300 rounded-full px-2 py-0.5 text-xs\">\n                    {node.category}\n                  </div>\n                </div>\n              )}\n              \n              <div>\n                <h4 className=\"text-sm font-medium text-gray-600 dark:text-gray-400\">Kullanım Sayısı</h4>\n                <p>{node.count} kez</p>\n              </div>\n              \n              <div>\n                <h4 className=\"text-sm font-medium text-gray-600 dark:text-gray-400\">Derinlik</h4>\n                <p>{node.depth}</p>\n              </div>\n            </div>\n            \n            <div className=\"space-y-3\">\n              <div>\n                <h4 className=\"text-sm font-medium text-gray-600 dark:text-gray-400 mb-1\">Bağımlılık</h4>\n                <ProgressBar value={node.dependency} max={100} color=\"bg-green-500\" />\n                <p className=\"text-xs text-gray-500 dark:text-gray-400 mt-1\">{node.dependency}%</p>\n              </div>\n              \n              <div>\n                <h4 className=\"text-sm font-medium text-gray-600 dark:text-gray-400 mb-1\">İlişki</h4>\n                <ProgressBar value={node.association} max={100} color=\"bg-orange-500\" />\n                <p className=\"text-xs text-gray-500 dark:text-gray-400 mt-1\">{node.association}%</p>\n              </div>\n              \n              <div>\n                <h4 className=\"text-sm font-medium text-gray-600 dark:text-gray-400 mb-1\">Sıklık</h4>\n                <ProgressBar value={node.frequency} max={100} color=\"bg-purple-500\" />\n                <p className=\"text-xs text-gray-500 dark:text-gray-400 mt-1\">{node.frequency}</p>\n              </div>\n              \n              <div>\n                <h4 className=\"text-sm font-medium text-gray-600 dark:text-gray-400 mb-1\">Geri Bildirim</h4>\n                <ProgressBar \n                  value={node.feedback + 100} \n                  max={200} \n                  color={node.feedback >= 0 ? \"bg-emerald-500\" : \"bg-red-500\"} \n                />\n                <p className=\"text-xs text-gray-500 dark:text-gray-400 mt-1\">{node.feedback}</p>\n              </div>\n              \n              <div>\n                <h4 className=\"text-sm font-medium text-gray-600 dark:text-gray-400 mb-1\">Önem</h4>\n                <ProgressBar value={node.importance || 0} max={100} color=\"bg-yellow-500\" />\n                <p className=\"text-xs text-gray-500 dark:text-gray-400 mt-1\">{node.importance || 0}%</p>\n              </div>\n              \n              <div className=\"flex justify-between text-xs text-gray-500 dark:text-gray-400\">\n                <div className=\"flex items-center\">\n                  <Clock className=\"h-3 w-3 mr-1\" />\n                  Oluşturulma: {formatDate(node.createdAt)}\n                </div>\n                <div className=\"flex items-center\">\n                  <Activity className=\"h-3 w-3 mr-1\" />\n                  Son Aktivasyon: {formatDate(node.lastActivation)}\n                </div>\n              </div>\n            </div>\n          </div>\n          \n          {node.parentWords && node.parentWords.length > 0 && (\n            <div className=\"mt-4\">\n              <h4 className=\"text-sm font-medium text-gray-600 dark:text-gray-400 mb-2\">Üst Kelimeler</h4>\n              <div className=\"flex flex-wrap gap-1\">\n                {node.parentWords.map((word, index) => (\n                  <div key={index} className=\"inline-block bg-gray-100 dark:bg-gray-700 rounded px-2 py-1 text-xs\">\n                    {word}\n                  </div>\n                ))}\n              </div>\n            </div>\n          )}\n          \n          {node.connections && node.connections.length > 0 && (\n            <div className=\"mt-4\">\n              <h4 className=\"text-sm font-medium text-gray-600 dark:text-gray-400 mb-2\">Bağlantılar ({node.connections.length})</h4>\n              <div className=\"grid grid-cols-2 sm:grid-cols-3 gap-2\">\n                {node.connections.slice(0, 9).map((conn, index) => {\n                  const strength = node.connectionStrengths?.[conn] || 0.5;\n                  return (\n                    <div key={index} className=\"flex items-center justify-between bg-gray-100 dark:bg-gray-700 rounded px-2 py-1\">\n                      <span className=\"text-xs truncate\">{conn.split('-')[0]}</span>\n                      <span className=\"text-xs text-primary-500 dark:text-primary-400\">{Math.round(strength * 100)}%</span>\n                    </div>\n                  );\n                })}\n                {node.connections.length > 9 && (\n                  <div className=\"flex items-center justify-center bg-gray-100 dark:bg-gray-700 rounded px-2 py-1\">\n                    <span className=\"text-xs text-gray-500 dark:text-gray-400\">+ {node.connections.length - 9} daha</span>\n                  </div>\n                )}\n              </div>\n            </div>\n          )}\n          \n          {allRelations.length > 0 && (\n            <div className=\"mt-4\">\n              <h4 className=\"text-sm font-medium text-gray-600 dark:text-gray-400 mb-2\">İlişkiler ({allRelations.length})</h4>\n              <div className=\"space-y-2\">\n                {allRelations.slice(0, 5).map((relation, index) => {\n                  const isSource = relation.userWord === node.word;\n                  const otherWord = isSource ? relation.systemWord : relation.userWord;\n                  \n                  return (\n                    <div key={index} className=\"bg-gray-100 dark:bg-gray-700 rounded p-2\">\n                      <div className=\"flex items-center justify-between mb-1\">\n                        <div className=\"flex items-center text-sm\">\n                          <span>{isSource ? node.word : otherWord}</span>\n                          <ArrowRight className=\"h-3 w-3 mx-1\" />\n                          <span>{isSource ? otherWord : node.word}</span>\n                        </div>\n                        <div className=\"text-xs text-gray-500 dark:text-gray-400\">\n                          {relation.bidirectional ? 'İki Yönlü' : 'Tek Yönlü'}\n                        </div>\n                      </div>\n                      \n                      <div className=\"grid grid-cols-2 gap-2 text-xs\">\n                        <div>\n                          <span className=\"text-gray-600 dark:text-gray-400\">Güç:</span> {relation.strength}%\n                        </div>\n                        <div>\n                          <span className=\"text-gray-600 dark:text-gray-400\">İlişki:</span> {relation.association}%\n                        </div>\n                        <div>\n                          <span className=\"text-gray-600 dark:text-gray-400\">Bağımlılık:</span> {relation.dependency}%\n                        </div>\n                        <div>\n                          <span className=\"text-gray-600 dark:text-gray-400\">Öğrenme:</span> {relation.learningCount} kez\n                        </div>\n                      </div>\n                    </div>\n                  );\n                })}\n                \n                {allRelations.length > 5 && (\n                  <div className=\"text-center text-xs text-gray-500 dark:text-gray-400 py-1\">\n                    + {allRelations.length - 5} ilişki daha\n                  </div>\n                )}\n              </div>\n            </div>\n          )}\n          \n          {node.activationHistory && node.activationHistory.length > 1 && (\n            <div className=\"mt-4\">\n              <h4 className=\"text-sm font-medium text-gray-600 dark:text-gray-400 mb-2\">Aktivasyon Geçmişi</h4>\n              <div className=\"h-24 bg-gray-100 dark:bg-gray-700 rounded-md p-2 flex items-end\">\n                {node.activationHistory.map((value, index) => {\n                  const height = `${Math.max(5, value * 100)}%`;\n                  return (\n                    <div \n                      key={index}\n                      className=\"flex-1 mx-0.5 bg-primary-500 dark:bg-primary-600 rounded-t\"\n                      style={{ height }}\n                      title={`${Math.round(value * 100)}%`}\n                    />\n                  );\n                })}\n              </div>\n              <div className=\"flex justify-between text-xs text-gray-500 dark:text-gray-400 mt-1\">\n                <span>En eski</span>\n                <span>En yeni</span>\n              </div>\n            </div>\n          )}\n          \n          {node.semanticVector && (\n            <div className=\"mt-4\">\n              <h4 className=\"text-sm font-medium text-gray-600 dark:text-gray-400 mb-2 flex items-center\">\n                <BarChart2 className=\"h-4 w-4 mr-1\" />\n                Anlamsal Vektör\n              </h4>\n              <div className=\"text-xs font-mono bg-gray-100 dark:bg-gray-700 p-2 rounded overflow-x-auto\">\n                [{node.semanticVector.map(v => v.toFixed(2)).join(', ')}]\n              </div>\n            </div>\n          )}\n        </div>\n        \n        <div className=\"p-4 border-t border-gray-200 dark:border-gray-700 flex justify-end\">\n          <button\n            className=\"px-4 py-2 rounded-md bg-primary-500 hover:bg-primary-600 text-white transition-colors\"\n            onClick={onClose}\n          >\n            Kapat\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default CellDetailsModal;\n","size_bytes":13255},"client/src/components/ChatInterface.tsx":{"content":"import React, { useState, useEffect } from 'react';\nimport { Moon, Sun } from 'lucide-react';\n\ninterface Message {\n  id: string;\n  content: string;\n  sender: 'user' | 'bot';\n  timestamp: Date;\n  confidence?: number;\n  usedTraining?: any;\n  notification?: string;\n}\n\nfunction ChatInterface() {\n  const [isDarkMode, setIsDarkMode] = useState(false);\n\n  const toggleTheme = () => {\n    setIsDarkMode(!isDarkMode);\n  };\n\n  // Notification state\n  const [notification, setNotification] = useState<{ message: string; type: 'success' | 'error' | 'info' | 'warning' } | null>(null);\n\n  // Notification system'i neural network hook'a bağla\n  useEffect(() => {\n    const notificationHandler = {\n      show: (message: string, type: 'success' | 'error' | 'info' | 'warning') => {\n        setNotification({ message, type });\n        setTimeout(() => setNotification(null), 5000);\n      }\n    };\n\n    setNotificationRef(notificationHandler);\n\n    return () => {\n      setNotificationRef(null);\n    };\n  }, [setNotificationRef]);\n\n  return (\n    <div className={isDarkMode ? 'dark' : ''}>\n      <div className=\"bg-white text-gray-800 dark:bg-gray-800 dark:text-white min-h-screen\">\n        <header className=\"p-4 flex justify-between items-center\">\n          <h1 className=\"text-2xl font-bold\">Chat Interface</h1>\n          {/* Theme button has been removed as per request */}\n        </header>\n        <main className=\"p-4\">\n          <p>This is the main content of the chat interface.</p>\n        </main>\n      </div>\n    </div>\n  );\n}\n\nexport default ChatInterface;","size_bytes":1554},"client/src/components/ChatPanel.tsx":{"content":"import React, { useState, useRef, useEffect } from 'react';\nimport { EnhancedMemorySystem } from '@/lib/EnhancedMemorySystem';\nimport { Send, RefreshCw, Database, Trash2, Edit, ThumbsUp, ThumbsDown, Mic, MicOff, Smile, Volume2, Volume, RotateCcw, Bot, User } from 'lucide-react';\nimport { Tooltip } from '@/components/ui/tooltip';\nimport { TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';\nimport { Badge } from '@/components/ui/badge';\nimport { Button } from '@/components/ui/button';\nimport { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';\nimport { TurkishDictionary } from '@/lib/TurkishDictionary'; // TurkishDictionary import edildi\nimport { Message } from '@shared/schema';\n\ninterface ChatPanelProps {\n  onSendMessage: (message: string) => void;\n  onCorrectAnswer: (messageId: string) => void;\n  onShowMemory: () => void;\n  onClearChat: () => void;\n  onClearTraining: () => void;\n  onFeedback: (messageId: string, isPositive: boolean) => void;\n  messages: Message[];\n  isProcessing: boolean;\n  memorySystem: EnhancedMemorySystem;\n  relationCount: number;\n  onToggleVoice: () => void;\n  isVoiceEnabled: boolean;\n  onUserMessageLearned?: (message: string) => Promise<boolean>;\n}\n\nconst ChatPanel: React.FC<ChatPanelProps> = ({\n  onSendMessage,\n  onCorrectAnswer,\n  onShowMemory,\n  onClearChat,\n  onClearTraining,\n  onFeedback,\n  messages,\n  isProcessing,\n  memorySystem,\n  relationCount,\n  onToggleVoice,\n  isVoiceEnabled,\n  onUserMessageLearned\n}) => {\n  const [message, setMessage] = useState('');\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n  const messagesContainerRef = useRef<HTMLDivElement>(null);\n  const dictionary = useRef(new TurkishDictionary()).current; // Türkçe sözlük örneği oluşturuldu\n  const [teachingMode, setTeachingMode] = useState({ isActive: false, questionId: null as string | null, question: '', incorrectAnswer: '' });\n\n  // Toast bildirimleri için basit bir state yönetimi\n  const [toasts, setToasts] = useState<{ id: number; message: string; type: 'success' | 'error' | 'warning' }[]>([]);\n  const addToast = (message: string, type: 'success' | 'error' | 'warning') => {\n    const id = Date.now();\n    setToasts(prev => [...prev, { id, message, type }]);\n    setTimeout(() => {\n      setToasts(prev => prev.filter(toast => toast.id !== id));\n    }, 3000);\n  };\n\n  const scrollToBottom = () => {\n    if (messagesContainerRef.current) {\n      messagesContainerRef.current.scrollTop = 0;\n    }\n  };\n\n  useEffect(() => {\n    if (messages.length > 0 && messages[messages.length - 1].isUser === false) {\n      scrollToBottom();\n    }\n  }, [messages]);\n\n  const handleSendMessage = async () => {\n    if (!message.trim() || isProcessing) return;\n\n    const text = message.trim();\n    setMessage('');\n\n    // Kullanıcıdan öğrenme formatını kontrol et [CEVAP] ile başlıyorsa\n    if (text.startsWith('[CEVAP]')) {\n      // Öğrenme işlemini ChatPanel içinde değil, App.tsx'te handle et\n      if (onUserMessageLearned) {\n        const learned = await onUserMessageLearned(text);\n        if (learned) {\n          console.log('✅ Öğrenme işlemi başarıyla tamamlandı');\n          // Teşekkür mesajı genellikle bot tarafından gönderilir, burada sadece logluyoruz.\n          // Eğer bot kendi teşekkür mesajını göndermiyorsa, burada bir toast eklenebilir.\n          // addToast(\"✅ Cevap sisteme eklendi. Teşekkürler!\", \"success\");\n          return; // Öğrenme işlemi başarılıysa normal mesaj gönderimi yapma\n        } else {\n          console.log('❌ Öğrenme işlemi başarısız oldu');\n          addToast(\"❌ Öğrenme sırasında bir hata oluştu veya girdi geçersiz.\", \"error\");\n        }\n      }\n    }\n\n    onSendMessage(text);\n  };\n\n  const formatTime = (timestamp: number) => {\n    return new Date(timestamp).toLocaleTimeString('tr-TR', {\n      hour: '2-digit',\n      minute: '2-digit'\n    });\n  };\n\n  const [showEmojiPicker, setShowEmojiPicker] = useState(false);\n  const [audioPlaying, setAudioPlaying] = useState(false);\n\n  // Gelişmiş emoji kategorileri\n  const emojiCategories = {\n    olumlu: ['😊', '👍', '🎉', '❤️', '😄', '🥰', '😁', '🙏', '💪', '🤩', '😍', '🔥', '👏', '💯'],\n    ifadeler: ['🤔', '😅', '😌', '😎', '🧐', '🤓', '😇', '😉', '🙃', '😬', '😴', '🥳'],\n    jestler: ['👋', '🙌', '👌', '✌️', '👊', '🤝', '🤲', '👍', '👎', '👆', ' 👉', '👈'],\n    nesneler: ['✅', '⭐', '📝', '📌', '📢', '💡', '🎯', '🔍', '📊', '📈', '🛠️', '🎵', '🎮', '💻'],\n    semboller: ['❓', '❗', '⚠️', '⏰', '💬', '🔄', '✨', '💭', '🌟', '🔎', '➡️', '⬅️', '🔺', '🔻']\n  };\n\n  // Aktif kategori ve tüm emojileri birleştir\n  const [activeEmojiCategory, setActiveEmojiCategory] = useState<keyof typeof emojiCategories>('olumlu');\n  const commonEmojis = emojiCategories[activeEmojiCategory];\n\n  // Sesli yanıt çalma/durdurma fonksiyonu\n  const playAudio = (text: string) => {\n    // Ses zaten çalınıyorsa durdur\n    if (audioPlaying) {\n      window.speechSynthesis.cancel();\n      setAudioPlaying(false);\n      return;\n    }\n\n    const utterance = new SpeechSynthesisUtterance(text);\n    utterance.lang = 'tr-TR';\n    utterance.onend = () => setAudioPlaying(false);\n    setAudioPlaying(true);\n    window.speechSynthesis.speak(utterance);\n  };\n\n  const [longConversationTopic, setLongConversationTopic] = useState('');\n\n  // Uzun konuşma oluşturma\n  const generateLongConversation = () => {\n    // Hafızadan uzun bir paragraf oluştur\n    const paragraphText = memorySystem.generateLongConversation(\n      longConversationTopic || undefined,\n      7 // İstenen cümle sayısı\n    );\n\n    // Sistem mesajı olarak ekle\n    onSendMessage(`Uzun konuşma (${longConversationTopic || 'genel konu'}): ${paragraphText}`);\n\n    // Popover'ı kapatmak için konuyu temizle\n    setLongConversationTopic('');\n  };\n\n  // Öğretme modunu yönetmek için yeni fonksiyonlar\n  const handleTeachAnswer = (messageId: string) => {\n    const message = messages.find(m => m.id === messageId);\n    if (!message || message.isUser) return;\n\n    // Önceki kullanıcı mesajını bul\n    const messageIndex = messages.findIndex(m => m.id === messageId);\n    if (messageIndex <= 0) return;\n\n    const userMessage = messages[messageIndex - 1];\n    if (!userMessage.isUser) return;\n\n    // Soruyu localStorage'a kaydet (App.tsx'daki sistem ile uyumlu)\n    localStorage.setItem('pending_question', JSON.stringify({\n      id: messageId,\n      question: userMessage.content.trim(),\n      timestamp: Date.now()\n    }));\n\n    // Öğretme modunu aç\n    setTeachingMode({\n      isActive: true,\n      questionId: messageId,\n      question: userMessage.content,\n      incorrectAnswer: message.content\n    });\n\n    // Kullanıcıya bilgilendirme toast'ı göster\n    addToast(\"✏️ Öğretme modu açıldı! Doğru cevabı yazıp 'Öğret' butonuna basın.\", \"success\");\n  };\n\n  const handleSubmitTeaching = async (answer: string) => {\n    if (!teachingMode.isActive || !answer.trim()) return;\n\n    try {\n      // [CEVAP] formatında cevabı gönder\n      const formattedAnswer = `[CEVAP] ${answer.trim()}`;\n\n      // Öğretilen cevabı sisteme gönder\n      const wasLearned = await onUserMessageLearned(formattedAnswer);\n\n      if (wasLearned) {\n        // Öğretme modunu kapat\n        setTeachingMode({\n          isActive: false,\n          questionId: null,\n          question: '',\n          incorrectAnswer: ''\n        });\n\n        // Başarı mesajı - sistem tarafından zaten \"✅ Öğrendim! Teşekkür ederim!\" mesajı gönderildi\n        addToast(\"✅ Yeni bilgi başarıyla öğretildi!\", \"success\");\n      } else {\n        addToast(\"❌ Öğretilecek soru bulunamadı. Önce bilinmeyen bir soru sorun.\", \"warning\");\n      }\n\n    } catch (error) {\n      console.error('Öğretme hatası:', error);\n      addToast(\"❌ Öğretme sırasında bir hata oluştu.\", \"error\");\n    }\n  };\n\n  // Öğretme modu aktif olduğunda kullanılacak modal veya input\n  const TeachingInput = () => (\n    <div className=\"fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 p-4\">\n      <div className=\"bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-md border border-gray-200 dark:border-gray-700\">\n        <div className=\"flex items-center mb-4\">\n          <span className=\"text-2xl mr-3\">✏️</span>\n          <h3 className=\"text-lg font-semibold text-gray-900 dark:text-white\">Beni Eğit!</h3>\n        </div>\n        \n        <div className=\"bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-md p-3 mb-4\">\n          <p className=\"text-sm font-medium text-blue-800 dark:text-blue-300 mb-1\">📋 Soru:</p>\n          <p className=\"text-sm text-blue-700 dark:text-blue-300\">{teachingMode.question}</p>\n        </div>\n\n        <div className=\"bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-md p-3 mb-4\">\n          <p className=\"text-sm font-medium text-red-800 dark:text-red-300 mb-1\">❌ Hatalı cevabım:</p>\n          <p className=\"text-sm text-red-700 dark:text-red-300\">{teachingMode.incorrectAnswer}</p>\n        </div>\n\n        <div className=\"mb-4\">\n          <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n            ✅ Doğru cevabı yazın:\n          </label>\n          <textarea\n            id=\"teaching-textarea\"\n            rows={4}\n            className=\"w-full p-3 border border-gray-300 dark:border-gray-600 rounded-md focus:ring-2 focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white\"\n            placeholder=\"Bu sorunun doğru cevabını buraya yazın...\"\n            onKeyDown={(e) => {\n              if (e.key === 'Enter' && !e.shiftKey) {\n                e.preventDefault();\n                handleSubmitTeaching(e.currentTarget.value);\n              } else if (e.key === 'Escape') {\n                setTeachingMode({ isActive: false, questionId: null, question: '', incorrectAnswer: '' });\n              }\n            }}\n            autoFocus\n          />\n        </div>\n\n        <div className=\"flex justify-end space-x-3\">\n          <Button \n            variant=\"outline\" \n            onClick={() => setTeachingMode({ isActive: false, questionId: null, question: '', incorrectAnswer: '' })}\n          >\n            ❌ İptal\n          </Button>\n          <Button \n            className=\"bg-green-600 hover:bg-green-700 text-white\"\n            onClick={() => {\n              const textarea = document.getElementById('teaching-textarea') as HTMLTextAreaElement;\n              if (textarea && textarea.value.trim()) {\n                handleSubmitTeaching(textarea.value.trim());\n              } else {\n                addToast(\"❌ Lütfen doğru cevabı yazın!\", \"error\");\n              }\n            }}\n          >\n            ✅ Öğret\n          </Button>\n        </div>\n      </div>\n    </div>\n  );\n\n\n  return (\n    <div className=\"glass-card h-full flex flex-col max-h-[calc(100vh-180px)] min-h-[500px]\">\n      <div className=\"px-4 py-3 bg-secondary/30 border-b border-border/50 flex items-center justify-between flex-shrink-0\">\n        <h2 className=\"text-lg font-semibold text-gray-800 dark:text-gray-200\">\n          Sohbet\n        </h2>\n\n        <div className=\"flex space-x-2\">\n          <button\n            onClick={() => {\n              console.log('Hafıza butonu tıklandı');\n              onShowMemory();\n            }}\n            className=\"p-2 rounded-md text-gray-500 hover:text-gray-700 hover:bg-gray-100 dark:text-gray-400 dark:hover:text-white dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-primary-500\"\n            aria-label=\"Hafıza Sistemi\"\n            title=\"Hafıza Sistemi\"\n          >\n            <Database className=\"h-5 w-5\" />\n          </button>\n\n          <div className=\"flex gap-2\">\n            <Button\n              variant=\"ghost\"\n              size=\"icon\"\n              onClick={onClearChat}\n              className=\"text-gray-600 dark:text-gray-400\"\n              title=\"Sohbeti Temizle\"\n            >\n              <Trash2 className=\"h-5 w-5\" />\n            </Button>\n          </div>\n\n          <div className=\"ml-2\">\n            <Button\n              variant=\"ghost\"\n              size=\"icon\"\n              onClick={() => {\n                if (confirm('Tüm eğitim verilerini, hafızayı ve sinir ağını silmek istediğinize emin misiniz?')) {\n                  // Hafızayı temizle\n                  memorySystem.clearMemory();\n\n                  // Eğitim verilerini temizle\n                  onClearTraining();\n\n                  // localStorage'dan sinir ağı verilerini temizle\n                  localStorage.removeItem('neural_user_networks');\n                  localStorage.removeItem('neural_system_networks');\n                  localStorage.removeItem('neural_relations');\n                  localStorage.removeItem('neural_bidirectional_relations');\n                  localStorage.removeItem('neural_training_history');\n                  localStorage.removeItem('neural_stats');\n\n                  // Sayfayı yenile\n                  window.location.reload();\n                }\n              }}\n              className=\"text-red-600 dark:text-red-400\"\n              title=\"Eğitim Verilerini Sıfırla\"\n            >\n              <RotateCcw className=\"h-5 w-5\" />\n            </Button>\n          </div>\n        </div>\n      </div>\n\n      <div ref={messagesContainerRef} className=\"overflow-y-auto flex-1 scrollbar-thin px-4 sm:px-6\" style={{ display: 'flex', flexDirection: 'column-reverse', minHeight: '300px' }}>\n        <div style={{ display: 'flex', flexDirection: 'column' }}>\n          {(!messages || messages.length === 0) ? (\n            <div className=\"text-center py-12 animate-fade-in\">\n              <div className=\"modern-card max-w-md mx-auto p-8\">\n                <div className=\"w-16 h-16 mx-auto mb-4 bg-gradient-to-br from-primary/20 to-primary/5 rounded-full flex items-center justify-center\">\n                  <span className=\"text-2xl\">🤖</span>\n                </div>\n                <h3 className=\"text-lg font-semibold text-foreground mb-2\">NöroBot'a Hoş Geldiniz!</h3>\n                <p className=\"text-sm text-muted-foreground mb-4\">Yapay zeka destekli Türkçe asistanınızla sohbete başlamak için bir mesaj gönderin.</p>\n                <div className=\"flex items-center justify-center space-x-2 text-xs text-muted-foreground bg-muted rounded-lg px-3 py-2\">\n                  <span className=\"w-2 h-2 bg-green-400 rounded-full animate-pulse\"></span>\n                  <span>Aktif İlişki: {relationCount}</span>\n                </div>\n              </div>\n            </div>\n          ) : (\n            <div className=\"space-y-6 py-4\">\n              {messages.map((msg) => (\n                <div\n                  key={msg.id}\n                  className={`flex ${msg.isUser ? 'justify-end' : 'justify-start'} animate-slide-up`}\n                >\n                  <div className=\"flex items-start space-x-3 max-w-[85%]\">\n                    {/* Avatar */}\n                    {!msg.isUser && (\n                      <div className=\"flex-shrink-0 w-8 h-8 bg-gradient-to-br from-primary to-primary/80 rounded-full flex items-center justify-center\">\n                        <span className=\"text-sm\">🤖</span>\n                      </div>\n                    )}\n\n                    <div\n                      className={`${msg.isUser ? 'chat-message-user' : 'chat-message-bot'} animate-fade-in`}\n                    >\n                    {/* Modül bilgisi gösterme */}\n                    {msg.module && !msg.isUser && (\n                      <div className=\"mb-1\">\n                        <Badge variant={\n                          msg.module === 'info' ? 'default' :\n                            msg.module === 'humor' ? 'secondary' :\n                              msg.module === 'advice' ? 'outline' : msg.module === 'feedback' ? 'destructive' : 'default'\n                        } className=\"text-[10px] py-0 px-2\">\n                          {msg.module === 'info' ? 'Bilgi' :\n                            msg.module === 'humor' ? 'Mizah' :\n                              msg.module === 'advice' ? 'Tavsiye' : msg.module === 'feedback' ? 'Geri Bildirim' : 'Öğrenme Talebi'}\n                        </Badge>\n                      </div>\n                    )}\n\n                      <div className=\"prose prose-sm max-w-none text-foreground\">{msg.content}</div>\n\n                      <div className=\"text-xs mt-3 flex justify-between items-center opacity-80\">\n                        <span className=\"flex items-center gap-2 text-muted-foreground\">\n                          {formatTime(msg.timestamp)}\n                          {msg.isSpoken && <Volume2 className=\"h-3 w-3 text-primary\" />}\n                        </span>\n\n                        {!msg.isUser && (\n                          <div className=\"flex items-center space-x-1\">\n                            {/* Sesli okuma butonu */}\n                            <button\n                              onClick={() => playAudio(msg.content)}\n                              className={`p-2 rounded-lg transition-all hover:scale-110 ${\n                                audioPlaying\n                                  ? 'bg-primary text-primary-foreground'\n                                  : 'hover:bg-muted text-muted-foreground hover:text-foreground'\n                              }`}\n                              aria-label=\"Sesli Oku\"\n                              title=\"Sesli Oku\"\n                            >\n                              {audioPlaying ? <Volume2 className=\"h-3 w-3\" /> : <Volume className=\"h-3 w-3\" />}\n                            </button>\n\n                            {/* Geri bildirim düğmeleri */}\n                            <div className=\"flex space-x-1\">\n                              <button\n                                onClick={() => onFeedback(msg.id, true)}\n                                className={`p-2 rounded-lg transition-all hover:scale-110 ${\n                                  msg.feedback === 1\n                                    ? 'bg-green-500 text-white shadow-md'\n                                    : 'hover:bg-green-100 dark:hover:bg-green-900 text-muted-foreground hover:text-green-600'\n                                }`}\n                                aria-label=\"Beğen\"\n                                title=\"Beğen\"\n                              >\n                                <ThumbsUp className=\"h-3 w-3\" />\n                              </button>\n                              <button\n                                onClick={() => onFeedback(msg.id, false)}\n                                className={`p-2 rounded-lg transition-all hover:scale-110 ${\n                                  msg.feedback === -1\n                                    ? 'bg-red-500 text-white shadow-md'\n                                    : 'hover:bg-red-100 dark:hover:bg-red-900 text-muted-foreground hover:text-red-600'\n                                }`}\n                                aria-label=\"Beğenme\"\n                                title=\"Beğenme\"\n                              >\n                                <ThumbsDown className=\"h-3 w-3\" />\n                              </button>\n                            </div>\n\n                            <button\n                              onClick={() => handleTeachAnswer(msg.id)}\n                              className=\"p-2 rounded-lg transition-all hover:scale-110 text-blue-500 hover:text-blue-600 hover:bg-blue-50 dark:hover:bg-blue-900/20 border border-blue-200 dark:border-blue-800\"\n                              aria-label=\"Beni Eğit - Doğru Cevabı Öğret\"\n                              title=\"✏️ Beni Eğit - Doğru Cevabı Öğret\"\n                            >\n                              <Edit className=\"h-4 w-4\" />\n                            </button>\n                          </div>\n                        )}\n                      </div>\n                    </div>\n\n                    {/* User Avatar */}\n                    {msg.isUser && (\n                      <div className=\"flex-shrink-0 w-8 h-8 bg-gradient-to-br from-secondary to-secondary/80 rounded-full flex items-center justify-center ml-3\">\n                        <span className=\"text-sm\">👤</span>\n                      </div>\n                    )}\n                  </div>\n                </div>\n              ))}\n              <div ref={messagesEndRef} />\n            </div>\n          )}\n        </div>\n      </div>\n\n      {/* Toast bildirimleri */}\n      <div className=\"fixed top-4 right-4 z-50 w-full max-w-sm space-y-2\">\n        {toasts.map(toast => (\n          <div key={toast.id} className={`p-3 rounded-md shadow-lg ${\n            toast.type === 'success' ? 'bg-green-100 text-green-700 border border-green-300' :\n            toast.type === 'error' ? 'bg-red-100 text-red-700 border border-red-300' :\n            'bg-yellow-100 text-yellow-700 border border-yellow-300'\n          }`}>\n            {toast.message}\n          </div>\n        ))}\n      </div>\n\n\n      {/* Emoji seçici */}\n      {showEmojiPicker && (\n        <div className=\"p-2 border-t border-gray-200 dark:border-gray-700\">\n          {/* Emoji kategorileri */}\n          <div className=\"mb-2 flex justify-center overflow-x-auto whitespace-nowrap\">\n            {Object.keys(emojiCategories).map((category) => (\n              <button\n                key={category}\n                onClick={() => setActiveEmojiCategory(category as keyof typeof emojiCategories)}\n                className={`px-3 py-1 mx-1 text-xs rounded-md ${\n                  activeEmojiCategory === category\n                    ? 'bg-primary-100 dark:bg-primary-900 text-primary-600 dark:text-primary-300'\n                    : 'bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-600'\n                }`}\n              >\n                {category === 'olumlu' ? '😊 Olumlu' :\n                  category === 'ifadeler' ? '🤔 İfadeler' :\n                    category === 'jestler' ? '👋 Jestler' :\n                      category === 'nesneler' ? '✅ Nesneler' : '❓ Semboller'}\n              </button>\n            ))}\n          </div>\n\n          {/* Emojiler */}\n          <div className=\"flex flex-wrap justify-center gap-2 max-h-[180px] overflow-y-auto\">\n            {commonEmojis.map(emoji => (\n              <button\n                key={emoji}\n                onClick={() => {\n                  setMessage(prev => prev + emoji);\n                }}\n                className=\"w-9 h-9 flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md text-xl transition-transform hover:scale-110\"\n              >\n                {emoji}\n              </button>\n            ))}\n          </div>\n\n          {/* Anlık emoji ifadeleri */}\n          <div className=\"mt-2 flex justify-center\">\n            <button\n              onClick={() => {\n                setMessage(prev => prev + \" 👍\");\n                setShowEmojiPicker(false);\n              }}\n              className=\"mx-1 px-3 py-1 bg-green-100 dark:bg-green-900 text-green-600 dark:text-green-300 rounded-md text-xs flex items-center\"\n            >\n              <span className=\"mr-1\">👍</span> Evet\n            </button>\n            <button\n              onClick={() => {\n                setMessage(prev => prev + \" 👎\");\n                setShowEmojiPicker(false);\n              }}\n              className=\"mx-1 px-3 py-1 bg-red-100 dark:bg-red-900 text-red-600 dark:text-red-300 rounded-md text-xs flex items-center\"\n            >\n              <span className=\"mr-1\">👎</span> Hayır\n            </button>\n            <button\n              onClick={() => {\n                setMessage(prev => prev + \" 🤔\");\n                setShowEmojiPicker(false);\n              }}\n              className=\"mx-1 px-3 py-1 bg-yellow-100 dark:bg-yellow-900 text-yellow-600 dark:text-yellow-300 rounded-md text-xs flex items-center\"\n            >\n              <span className=\"mr-1\">🤔</span> Hmmm\n            </button>\n            <button\n              onClick={() => {\n                setMessage(prev => prev + \" 😂\");\n                setShowEmojiPicker(false);\n              }}\n              className=\"mx-1 px-3 py-1 bg-blue-100 dark:bg-blue-900 text-blue-600 dark:text-blue-300 rounded-md text-xs flex items-center\"\n            >\n              <span className=\"mr-1\">😂</span> Komik\n            </button>\n          </div>\n        </div>\n      )}\n\n      {/* Öğretme modu aktifse input modal'ı göster */}\n      {teachingMode.isActive && <TeachingInput />}\n\n      <div className=\"bg-background/90 border-t border-border/50 p-3 flex-shrink-0\">\n        <form onSubmit={(e) => { e.preventDefault(); handleSendMessage(); }} className=\"w-full\">\n          <div className=\"flex items-center gap-2 w-full max-w-full\">\n            <input\n              type=\"text\"\n              value={message}\n              onChange={(e) => setMessage(e.target.value)}\n              placeholder=\"Mesajınızı yazın...\"\n              className=\"modern-input flex-1 min-w-0 h-10 rounded-l-lg border-r-0\"\n              disabled={isProcessing}\n            />\n            <Popover>\n              <PopoverTrigger asChild>\n                <Button variant=\"outline\" size=\"icon\" className=\"h-10 w-10 rounded-none border-l-0 border-r-0\">\n                  <span className=\"text-lg\">📝</span>\n                </Button>\n              </PopoverTrigger>\n              <PopoverContent className=\"w-80\">\n                <div className=\"grid gap-4\">\n                  <h4 className=\"font-medium leading-none\">Uzun Konuşma</h4>\n                  <p className=\"text-sm text-muted-foreground\">\n                    Hafızadaki bilgilerden anlamlı bir paragraf oluştur.\n                  </p>\n                  <div className=\"flex gap-2\">\n                    <input\n                      placeholder=\"Konu (isteğe bağlı)\"\n                      id=\"topic\"\n                      className=\"modern-input flex-1 h-10\"\n                      onChange={(e) => setLongConversationTopic(e.target.value)}\n                      value={longConversationTopic}\n                    />\n                    <Button size=\"sm\" variant=\"gradient\" onClick={generateLongConversation}>Oluştur</Button>\n                  </div>\n                </div>\n              </PopoverContent>\n            </Popover>\n\n            {/* Ses Butonu */}\n            {onToggleVoice && (\n              <button\n                type=\"button\"\n                onClick={() => {\n                  console.log(\"🎙️ Mikrofon butonuna tıklandı!\");\n                  if (onToggleVoice) onToggleVoice();\n                }}\n                className={`h-10 px-3 border border-l-0 border-r-0 border-border rounded-none transition-all duration-300 ${\n                  isVoiceEnabled\n                    ? 'btn-gradient shadow-md'\n                    : 'bg-secondary hover:bg-secondary/80 text-secondary-foreground'\n                } focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2`}\n                aria-label={isVoiceEnabled ? \"Sesi kapat\" : \"Sesi aç\"}\n                title={isVoiceEnabled ? \"Sesi kapat\" : \"Sesi aç\"}\n              >\n                {isVoiceEnabled ? <Mic className=\"h-5 w-5\" /> : <MicOff className=\"h-5 w-5\" />}\n              </button>\n            )}\n\n            {/* Emoji Butonu */}\n            <button\n              type=\"button\"\n              onClick={() => setShowEmojiPicker(!showEmojiPicker)}\n              className=\"h-10 px-3 border border-l-0 border-r-0 border-border bg-secondary hover:bg-secondary/80 text-secondary-foreground rounded-none transition-all duration-300 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\"\n              aria-label=\"Emoji Ekle\"\n              title=\"Emoji Ekle\"\n            >\n              <Smile className=\"h-5 w-5\" />\n            </button>\n\n            {/* Gönder Butonu */}\n            <button\n              type=\"submit\"\n              disabled={isProcessing || !message.trim()}\n              className={`h-10 px-4 border border-l-0 border-border rounded-r-lg transition-all duration-300 ${\n                isProcessing || !message.trim()\n                  ? 'bg-muted cursor-not-allowed text-muted-foreground'\n                  : 'btn-gradient hover:shadow-lg'\n              } focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2`}\n            >\n              {isProcessing ? (\n                <div className=\"w-4 h-4 border-2 border-current border-t-transparent rounded-full animate-spin\" />\n              ) : (\n                <Send className=\"h-4 w-4\" />\n              )}\n            </button>\n          </div>\n        </form>\n      </div>\n    </div>\n  );\n};\n\nexport default ChatPanel;","size_bytes":29042},"client/src/components/CorrectAnswerModal.tsx":{"content":"\nimport React, { useState, useEffect } from 'react';\nimport { X } from 'lucide-react';\nimport { useTheme } from '../contexts/ThemeContext';\n\ninterface CorrectAnswerModalProps {\n  isOpen: boolean;\n  originalQuestion?: string;\n  onSubmit: (answer: string, editedQuestion?: string) => void;\n  onClose: () => void;\n  incorrectAnswer?: string;\n}\n\nconst CorrectAnswerModal: React.FC<CorrectAnswerModalProps> = ({\n  isOpen,\n  originalQuestion,\n  onSubmit,\n  onClose,\n  incorrectAnswer\n}) => {\n  const [answer, setAnswer] = useState('');\n  const [editedQuestion, setEditedQuestion] = useState(originalQuestion || '');\n  const { isDarkMode } = useTheme();\n  \n  const handleSubmit = () => {\n    if (answer.trim()) {\n      onSubmit(answer.trim(), editedQuestion.trim());\n      setAnswer('');\n      setEditedQuestion('');\n    }\n  };\n  \n  // Update edited question when originalQuestion changes\n  useEffect(() => {\n    setEditedQuestion(originalQuestion || '');\n  }, [originalQuestion]);\n  \n  if (!isOpen) return null;\n  \n  return (\n    <div className=\"fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-50\">\n      <div className=\"w-full max-w-md rounded-xl shadow-lg bg-white dark:bg-gray-800 text-gray-800 dark:text-gray-200\">\n        <div className=\"flex items-center justify-between p-4 border-b border-gray-200 dark:border-gray-700\">\n          <div>\n            <h3 className=\"text-lg font-semibold\">Manuel Eğitim</h3>\n            <p className=\"text-sm text-gray-600 dark:text-gray-400 mt-1\">\n              Henüz bu konuda yeterli bilgim yok. Bana doğru cevabı öğretebilirsiniz.\n            </p>\n          </div>\n          <button \n            className=\"p-1 rounded-full transition-colors hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200\" \n            aria-label=\"Kapat\"\n            onClick={onClose}\n          >\n            <X className=\"h-5 w-5\" />\n          </button>\n        </div>\n        \n        <div className=\"p-4 space-y-4\">\n          {incorrectAnswer && (\n            <div className=\"bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-md p-3\">\n              <p className=\"text-sm font-medium text-red-800 dark:text-red-300 mb-1\">❌ Hatalı Cevap:</p>\n              <p className=\"text-sm text-red-700 dark:text-red-400\">{incorrectAnswer}</p>\n            </div>\n          )}\n          \n          <div>\n            <label className=\"block text-sm font-medium mb-2\">\n              Soru (düzenleyebilirsiniz):\n            </label>\n            <input\n              type=\"text\"\n              value={editedQuestion}\n              onChange={(e) => setEditedQuestion(e.target.value)}\n              className=\"w-full p-3 rounded-md border bg-white dark:bg-gray-700 border-gray-300 dark:border-gray-600 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500\"\n              placeholder=\"Soruyu buraya yazın...\"\n            />\n          </div>\n          \n          <div>\n            <label className=\"block text-sm font-medium mb-2\">\n              Doğru Cevap:\n            </label>\n            <textarea\n              value={answer}\n              onChange={(e) => setAnswer(e.target.value)}\n              rows={5}\n              className=\"w-full p-3 rounded-md border bg-white dark:bg-gray-700 border-gray-300 dark:border-gray-600 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500\"\n              placeholder=\"Doğru cevabı buraya yazın...\"\n            />\n          </div>\n        </div>\n        \n        <div className=\"p-4 border-t border-gray-200 dark:border-gray-700 flex justify-end space-x-2\">\n          <button\n            className=\"px-4 py-2 rounded-md border border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors\"\n            onClick={onClose}\n          >\n            İptal\n          </button>\n          \n          <button\n            className=\"px-4 py-2 rounded-md bg-blue-500 hover:bg-blue-600 text-white transition-colors disabled:opacity-50\"\n            onClick={handleSubmit}\n            disabled={!answer.trim()}\n          >\n            Eğit\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default CorrectAnswerModal;\n","size_bytes":4342},"client/src/components/EnhancedHeader.tsx":{"content":"import React from 'react';\nimport { Moon, Sun, Brain, Activity, Zap, Eye, Settings, Cpu, CircuitBoard, Bot } from 'lucide-react';\nimport { useTheme } from '../contexts/ThemeContext';\nimport { useIsMobile } from '../hooks/use-mobile';\n\ninterface EnhancedHeaderProps {\n  showAIStatus: boolean;\n  setShowAIStatus: (show: boolean) => void;\n  showMemory: boolean;\n  setShowMemory: (show: boolean) => void;\n  showNetwork: boolean;\n  setShowNetwork: (show: boolean) => void;\n  isVoiceEnabled: boolean;\n  toggleVoice: () => void;\n}\n\nconst EnhancedHeader: React.FC<EnhancedHeaderProps> = ({ \n  showAIStatus, \n  setShowAIStatus,\n  showMemory,\n  setShowMemory,\n  showNetwork,\n  setShowNetwork,\n  isVoiceEnabled,\n  toggleVoice\n}) => {\n  const { isDarkMode, toggleTheme } = useTheme();\n  const isMobile = useIsMobile();\n\n  return (\n    <header className=\"bg-white dark:bg-gray-900 border-b border-gray-200 dark:border-gray-700 shadow-lg sticky top-0 z-40 backdrop-blur-sm bg-opacity-95 dark:bg-opacity-95\">\n      <div className=\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8\">\n        <div className=\"flex justify-between items-center h-16\">\n          {/* Logo ve Başlık - Modern Gradient Design */}\n          <div className=\"flex items-center space-x-4\">\n            <div className=\"relative\">\n              <div className=\"w-10 h-10 bg-gradient-to-br from-blue-500 via-purple-500 to-pink-500 rounded-xl flex items-center justify-center shadow-lg transform hover:scale-110 transition-all duration-300 hover:rotate-6\">\n                <Bot className=\"w-6 h-6 text-white\" />\n              </div>\n              <div className=\"absolute -inset-1 bg-gradient-to-br from-blue-500 via-purple-500 to-pink-500 rounded-xl opacity-20 animate-pulse\"></div>\n            </div>\n            <div>\n              <h1 className=\"text-2xl font-bold bg-gradient-to-r from-blue-600 via-purple-600 to-pink-600 dark:from-blue-400 dark:via-purple-400 dark:to-pink-400 bg-clip-text text-transparent\">\n                Gelişmiş AI Asistanı\n              </h1>\n              <p className=\"text-sm text-gray-600 dark:text-gray-400\">\n                🧠 Kendini Geliştiren Yapay Zeka\n              </p>\n            </div>\n          </div>\n\n          {/* Kontrol Paneli - Modern Button Group */}\n          <div className=\"flex items-center space-x-2\">\n            {/* AI Durumu Butonu - Yeni Özellik */}\n            <button\n              onClick={() => setShowAIStatus(!showAIStatus)}\n              className={`\n                relative flex items-center space-x-2 px-4 py-2 rounded-lg transition-all duration-300 \n                ${showAIStatus \n                  ? 'bg-gradient-to-r from-blue-500 to-purple-500 text-white shadow-lg' \n                  : 'bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700'\n                }\n                transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50\n              `}\n              title=\"AI Durumu ve Yetenekleri\"\n            >\n              <Activity className=\"w-4 h-4\" />\n              {!isMobile && <span className=\"text-sm font-medium\">AI Durumu</span>}\n              {/* Aktiflik göstergesi */}\n              <div className=\"absolute -top-1 -right-1 w-3 h-3 bg-green-400 rounded-full animate-pulse shadow-sm\"></div>\n            </button>\n\n            {/* Bellek Butonu */}\n            <button\n              onClick={() => setShowMemory(!showMemory)}\n              className={`\n                flex items-center space-x-2 px-3 py-2 rounded-lg transition-all duration-300 \n                ${showMemory \n                  ? 'bg-gradient-to-r from-green-500 to-emerald-500 text-white shadow-lg' \n                  : 'bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700'\n                }\n                transform hover:scale-105\n              `}\n              title=\"Bellek Sistemi\"\n            >\n              <Eye className=\"w-4 h-4\" />\n              {!isMobile && <span className=\"text-sm\">Bellek</span>}\n            </button>\n\n            {/* Ağ Görselleştirme Butonu */}\n            <button\n              onClick={() => setShowNetwork(!showNetwork)}\n              className={`\n                flex items-center space-x-2 px-3 py-2 rounded-lg transition-all duration-300 \n                ${showNetwork \n                  ? 'bg-gradient-to-r from-purple-500 to-pink-500 text-white shadow-lg' \n                  : 'bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700'\n                }\n                transform hover:scale-105\n              `}\n              title=\"Sinir Ağı Görselleştirmesi\"\n            >\n              <Settings className=\"w-4 h-4\" />\n              {!isMobile && <span className=\"text-sm\">Ağ</span>}\n            </button>\n\n            {/* Ses Kontrolü */}\n            <button\n              onClick={toggleVoice}\n              className={`\n                flex items-center space-x-2 px-3 py-2 rounded-lg transition-all duration-300 \n                ${isVoiceEnabled \n                  ? 'bg-gradient-to-r from-orange-500 to-red-500 text-white shadow-lg' \n                  : 'bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700'\n                }\n                transform hover:scale-105\n              `}\n              title={isVoiceEnabled ? 'Sesi Kapat' : 'Sesi Aç'}\n            >\n              <Zap className={`w-4 h-4 ${isVoiceEnabled ? 'animate-pulse' : ''}`} />\n              {!isMobile && <span className=\"text-sm\">Ses</span>}\n            </button>\n\n            {/* Tema Değiştirme */}\n            <button \n              onClick={toggleTheme}\n              className=\"\n                p-3 rounded-lg bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 \n                hover:bg-gray-200 dark:hover:bg-gray-700 transition-all duration-300 transform hover:scale-110\n                focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50\n              \"\n              title={isDarkMode ? \"Açık Tema'ya Geç\" : \"Koyu Tema'ya Geç\"}\n            >\n              {isDarkMode ? (\n                <Sun className=\"h-5 w-5 text-yellow-500\" />\n              ) : (\n                <Moon className=\"h-5 w-5 text-blue-600\" />\n              )}\n            </button>\n          </div>\n        </div>\n      </div>\n      \n      {/* İlerleme Çubuğu - AI Gelişim Göstergesi */}\n      <div className=\"h-1 bg-gradient-to-r from-blue-500 via-purple-500 to-pink-500 opacity-30\"></div>\n    </header>\n  );\n};\n\nexport default EnhancedHeader;","size_bytes":6650},"client/src/components/Header.tsx":{"content":"\nimport React from 'react';\nimport { Moon, Sun, Brain, Menu, X, Cpu, CircuitBoard, Bot } from 'lucide-react';\nimport { useTheme } from '../contexts/ThemeContext';\nimport { useCallback } from 'react';\nimport { useIsMobile } from '../hooks/use-mobile';\nimport { useEffect } from 'react';\n\ninterface HeaderProps {\n  onToggleMenu?: () => void;\n  isMenuOpen?: boolean;\n}\n\nconst Header: React.FC<HeaderProps> = ({ onToggleMenu, isMenuOpen }) => {\n  // Tema değiştirme - güçlendirilmiş\n  const { isDarkMode, toggleTheme } = useTheme();\n\n  // Tema değişikliğini konsola kaydet (hata ayıklama)\n  useEffect(() => {\n    console.log(`Header bileşeni tema durumu: ${isDarkMode ? 'Koyu' : 'Açık'}`);\n  }, [isDarkMode]);\n  \n  const isMobile = useIsMobile();\n\n  return (\n    <header className=\"glass-card border-b-0 shadow-xl sticky top-0 z-50 h-16 sm:h-18\">\n      <div className=\"max-w-7xl mx-auto responsive-padding py-2 sm:py-3 h-full\">\n        <div className=\"flex justify-between items-center h-full\">\n          {/* Logo ve Başlık - Modern */}\n          <div className=\"flex items-center space-x-3 sm:space-x-4 animate-fade-in\">\n            <div className=\"relative\">\n              <div className=\"relative transform hover:scale-110 transition-all duration-500 hover:rotate-12\">\n                <Bot className=\"w-8 h-8 sm:w-10 sm:h-10 text-primary animate-bounce-subtle\" />\n                <div className=\"absolute -inset-2 bg-gradient-to-r from-primary/20 via-primary/10 to-primary/20 rounded-full blur-md animate-pulse-slow\"></div>\n              </div>\n            </div>\n            <div className=\"min-w-0\">\n              <h1 className=\"text-lg sm:text-2xl font-bold text-gradient tracking-tight\">\n                NöroBot\n              </h1>\n              <p className=\"text-xs sm:text-xs text-muted-foreground truncate animate-fade-in\">\n                {isMobile ? '🤖 AI Asistan' : '🧠 Akıllı Türkçe Asistan'}\n              </p>\n            </div>\n          </div>\n\n          {/* Sağ taraf kontrolleri - Modern */}\n          <div className=\"flex items-center space-x-2 sm:space-x-3\">\n\n\n            {/* Mobil menü toggle - Modern */}\n            {isMobile && onToggleMenu && (\n              <button\n                onClick={onToggleMenu}\n                className=\"modern-card p-3 rounded-xl transition-all duration-300 transform hover:scale-105 group\"\n                aria-label={isMenuOpen ? 'Menüyü kapat' : 'Menüyü aç'}\n              >\n                {isMenuOpen ? (\n                  <X className=\"w-4 h-4 text-destructive transition-transform group-hover:rotate-90\" />\n                ) : (\n                  <Menu className=\"w-4 h-4 text-primary transition-transform group-hover:scale-110\" />\n                )}\n              </button>\n            )}\n          </div>\n        </div>\n      </div>\n      \n      {/* Modern gradient underline */}\n      <div className=\"h-px bg-gradient-to-r from-transparent via-primary to-transparent opacity-50\"></div>\n    </header>\n  );\n};\n\nexport default Header;\n","size_bytes":3028},"client/src/components/MemoryPanel.tsx":{"content":"import React, { useState } from 'react';\nimport { X, Database, Brain, Clock, Sparkles, Folder, Trash2 } from 'lucide-react';\nimport { EnhancedMemorySystem, Memory, MemoryCluster } from '@/lib/EnhancedMemorySystem';\n\ninterface MemoryPanelProps {\n  memorySystem: EnhancedMemorySystem;\n  isVisible: boolean;\n  onClose: () => void;\n}\n\nconst MemoryPanel: React.FC<MemoryPanelProps> = ({\n  memorySystem,\n  isVisible,\n  onClose\n}) => {\n  const [activeTab, setActiveTab] = useState<'short' | 'long' | 'clusters' | 'semantic'>('short');\n\n  if (!isVisible) return null;\n\n  // İnsan tarafından okunabilir tarih formatı\n  const formatDate = (timestamp: number) => {\n    return new Date(timestamp).toLocaleString('tr-TR', {\n      day: '2-digit',\n      month: '2-digit',\n      year: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit'\n    });\n  };\n\n  const renderMemoryItem = (memory: Memory) => (\n    <div className=\"bg-white dark:bg-gray-700 rounded-lg shadow-sm p-3 mb-3 border border-gray-100 dark:border-gray-600 relative overflow-hidden\">\n      <button\n        onClick={() => memorySystem.removeMemory(memory.content)}\n        className=\"absolute top-2 right-2 text-gray-400 hover:text-red-500 dark:text-gray-500 dark:hover:text-red-400\"\n      >\n        <X className=\"h-4 w-4\" />\n      </button>\n      <div className=\"text-sm mb-2 pr-8 dark:text-white\">{memory.content}</div>\n      <div className=\"flex text-xs text-gray-500 dark:text-gray-300 border-t border-gray-100 dark:border-gray-600 pt-2 mt-1 justify-between\">\n        <div className=\"flex items-center\">\n          <Clock className=\"h-3 w-3 mr-1\" />\n          {formatDate(memory.timestamp)}\n        </div>\n        <div className=\"flex items-center\">\n          <Sparkles className=\"h-3 w-3 mr-1\" />\n          İlgililik: {memory.relevance}%\n        </div>\n      </div>\n    </div>\n  );\n\n  const renderClusterItem = (cluster: MemoryCluster) => (\n    <div className=\"bg-white dark:bg-gray-700 rounded-lg shadow-sm p-3 mb-3 border border-gray-100 dark:border-gray-600\">\n      <div className=\"flex items-center justify-between mb-2\">\n        <div className=\"font-medium dark:text-white\">{cluster.topic}</div>\n        <div className=\"text-xs bg-primary-100 dark:bg-primary-900/30 text-primary-700 dark:text-primary-300 rounded-full px-2 py-0.5\">\n          {cluster.memories.length} anı\n        </div>\n      </div>\n\n      <div className=\"text-xs text-gray-500 dark:text-gray-400 mb-2\">\n        <div className=\"flex items-center mb-1\">\n          <Sparkles className=\"h-3 w-3 mr-1\" />\n          Güç: {cluster.strength}%\n        </div>\n        <div className=\"flex items-center\">\n          <Clock className=\"h-3 w-3 mr-1\" />\n          Son erişim: {formatDate(cluster.lastAccessed)}\n        </div>\n      </div>\n\n      {cluster.memories.length > 0 && (\n        <div className=\"text-xs bg-gray-50 dark:bg-gray-800/90 rounded p-2 mt-2 max-h-20 overflow-y-auto\">\n          <div className=\"font-medium mb-1 dark:text-white\">İçeriği:</div>\n          {cluster.memories.slice(0, 2).map((mem, idx) => (\n            <div key={idx} className=\"truncate text-gray-600 dark:text-gray-200\">\n              {mem.content}\n            </div>\n          ))}\n          {cluster.memories.length > 2 && (\n            <div className=\"text-primary-500 dark:text-primary-400 mt-1\">\n              + {cluster.memories.length - 2} daha...\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  );\n\n  return (\n    <div className=\"fixed inset-0 bg-black/50 flex items-center justify-center p-2 md:p-4 z-50 overflow-y-auto\">\n      <div className=\"w-full max-w-2xl max-h-[90vh] overflow-hidden rounded-xl shadow-lg bg-gray-50 dark:bg-gray-800 text-gray-800 dark:text-gray-100 flex flex-col\">\n        <div className=\"flex items-center justify-between p-4 border-b border-gray-200 dark:border-gray-700\">\n          <div className=\"flex items-center space-x-2\">\n            <Brain className=\"h-5 w-5 text-primary-500\" />\n            <h3 className=\"text-lg font-semibold\">Hafıza Sistemi</h3>\n          </div>\n          <button \n            className=\"p-1 rounded-full transition-colors hover:bg-gray-200 dark:hover:bg-gray-700 text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200\" \n            aria-label=\"Kapat\"\n            onClick={onClose}\n          >\n            <X className=\"h-5 w-5\" />\n          </button>\n        </div>\n\n        <div className=\"flex bg-gray-100 dark:bg-gray-700 p-1 border-b border-gray-200 dark:border-gray-600\">\n          <button\n            className={`flex-1 py-2 px-3 rounded-md text-sm font-medium ${\n              activeTab === 'short'\n                ? 'bg-white dark:bg-gray-800 text-primary-600 dark:text-primary-400 shadow-sm'\n                : 'text-gray-600 dark:text-gray-300 hover:bg-white/50 dark:hover:bg-gray-600/50'\n            }`}\n            onClick={() => setActiveTab('short')}\n          >\n            <div className=\"flex items-center justify-center\">\n              <Database className=\"h-4 w-4 mr-1.5\" />\n              Kısa Süreli Bellek\n            </div>\n          </button>\n\n          <button\n            className={`flex-1 py-2 px-3 rounded-md text-sm font-medium ${\n              activeTab === 'long'\n                ? 'bg-white dark:bg-gray-800 text-primary-600 dark:text-primary-400 shadow-sm'\n                : 'text-gray-600 dark:text-gray-300 hover:bg-white/50 dark:hover:bg-gray-600/50'\n            }`}\n            onClick={() => setActiveTab('long')}\n          >\n            <div className=\"flex items-center justify-center\">\n              <Brain className=\"h-4 w-4 mr-1.5\" />\n              Uzun Süreli Bellek\n            </div>\n          </button>\n\n          <button\n            className={`flex-1 py-2 px-3 rounded-md text-sm font-medium ${\n              activeTab === 'clusters'\n                ? 'bg-white dark:bg-gray-800 text-primary-600 dark:text-primary-400 shadow-sm'\n                : 'text-gray-600 dark:text-gray-300 hover:bg-white/50 dark:hover:bg-gray-600/50'\n            }`}\n            onClick={() => setActiveTab('clusters')}\n          >\n            <div className=\"flex items-center justify-center\">\n              <Folder className=\"h-4 w-4 mr-1.5\" />\n              Bellek Kümeleri\n            </div>\n          </button>\n\n          <button\n            className={`flex-1 py-2 px-3 rounded-md text-sm font-medium ${\n              activeTab === 'semantic'\n                ? 'bg-white dark:bg-gray-800 text-primary-600 dark:text-primary-400 shadow-sm'\n                : 'text-gray-600 dark:text-gray-300 hover:bg-white/50 dark:hover:bg-gray-600/50'\n            }`}\n            onClick={() => setActiveTab('semantic')}\n          >\n            <div className=\"flex items-center justify-center\">\n              <Brain className=\"h-4 w-4 mr-1.5\" />\n              Anlamlandırma\n            </div>\n          </button>\n        </div>\n\n        <div className=\"p-4 overflow-y-auto flex-1\">\n          {activeTab === 'short' && (\n            <div>\n              <div className=\"flex items-center justify-between mb-4\">\n                <h4 className=\"font-medium\">Kısa Süreli Anılar ({memorySystem.shortTerm.length})</h4>\n                <div className=\"text-xs text-gray-500 dark:text-gray-400\">\n                  Maksimum kapasite: {memorySystem.maxShortTerm}\n                </div>\n              </div>\n\n              <div className=\"flex flex-col\">\n                {memorySystem.shortTerm.length === 0 ? (\n                  <div className=\"text-center py-8 text-gray-500 dark:text-gray-400\">\n                    <Database className=\"h-8 w-8 mx-auto mb-2 opacity-50\" />\n                    <p>Henüz kısa süreli anı oluşturulmadı.</p>\n                  </div>\n                ) : (\n                  <div>\n                    {memorySystem.shortTerm.map((memory, index) => (\n                      <div key={index}>\n                        {renderMemoryItem(memory)}\n                      </div>\n                    ))}\n                  </div>\n                )}\n                <button\n                  onClick={() => {\n                    if (confirm('Tüm kısa süreli anıları silmek istediğinize emin misiniz?')) {\n                      memorySystem.shortTerm = [];\n                      memorySystem.saveMemories();\n                    }\n                  }}\n                  className=\"self-end mt-4 p-2 rounded-full hover:bg-red-100 dark:hover:bg-red-900/30 text-red-600 dark:text-red-400\"\n                  title=\"Tüm kısa süreli anıları sil\"\n                >\n                  <Trash2 className=\"h-5 w-5\" />\n                </button>\n              </div>\n            </div>\n          )}\n\n          {activeTab === 'long' && (\n            <div>\n              <div className=\"flex items-center justify-between mb-4\">\n                <h4 className=\"font-medium\">Uzun Süreli Anılar ({memorySystem.longTerm.length})</h4>\n                <div className=\"text-xs text-gray-500 dark:text-gray-400\">\n                  Maksimum kapasite: {memorySystem.maxLongTerm}\n                </div>\n              </div>\n\n              <div className=\"flex flex-col\">\n                {memorySystem.longTerm.length === 0 ? (\n                  <div className=\"text-center py-8 text-gray-500 dark:text-gray-400\">\n                    <Brain className=\"h-8 w-8 mx-auto mb-2 opacity-50\" />\n                    <p>Henüz uzun süreli anı oluşturulmadı.</p>\n                  </div>\n                ) : (\n                  <div>\n                    {memorySystem.longTerm.map((memory, index) => (\n                      <div key={index}>\n                        {renderMemoryItem(memory)}\n                      </div>\n                    ))}\n                  </div>\n                )}\n                <button\n                  onClick={() => {\n                    if (confirm('Tüm uzun süreli anıları silmek istediğinize emin misiniz?')) {\n                      memorySystem.longTerm = [];\n                      memorySystem.saveMemories();\n                    }\n                  }}\n                  className=\"self-end mt-4 p-2 rounded-full hover:bg-red-100 dark:hover:bg-red-900/30 text-red-600 dark:text-red-400\"\n                  title=\"Tüm uzun süreli anıları sil\"\n                >\n                  <Trash2 className=\"h-5 w-5\" />\n                </button>\n              </div>\n            </div>\n          )}\n\n          {activeTab === 'clusters' && (\n            <div>\n              <div className=\"flex items-center justify-between mb-4\">\n                <h4 className=\"font-medium\">Bellek Kümeleri ({memorySystem.memoryClusters.length})</h4>\n                <div className=\"text-xs text-gray-500 dark:text-gray-400\">\n                  Maksimum küme: {memorySystem.maxClusters}\n                </div>\n              </div>\n\n              <div className=\"flex flex-col\">\n                {memorySystem.memoryClusters.length === 0 ? (\n                  <div className=\"text-center py-8 text-gray-500 dark:text-gray-400\">\n                    <Folder className=\"h-8 w-8 mx-auto mb-2 opacity-50\" />\n                    <p>Henüz bellek kümesi oluşturulmadı.</p>\n                  </div>\n                ) : (\n                  <div>\n                    {memorySystem.memoryClusters.map((cluster, index) => (\n                      <div key={index}>\n                        {renderClusterItem(cluster)}\n                      </div>\n                    ))}\n                  </div>\n                )}\n                <button\n                  onClick={() => {\n                    if (confirm('Tüm bellek kümelerini silmek istediğinize emin misiniz?')) {\n                      memorySystem.memoryClusters = [];\n                      memorySystem.saveMemories();\n                    }\n                  }}\n                  className=\"self-end mt-4 p-2 rounded-full hover:bg-red-100 dark:hover:bg-red-900/30 text-red-600 dark:text-red-400\"\n                  title=\"Tüm bellek kümelerini sil\"\n                >\n                  <Trash2 className=\"h-5 w-5\" />\n                </button>\n              </div>\n            </div>\n          )}\n\n          {activeTab === 'semantic' && (\n            <div>\n              <div className=\"flex items-center justify-between mb-4\">\n                <h4 className=\"font-medium\">Anlamlandırma Analizi</h4>\n              </div>\n\n              <div className=\"flex flex-col\">\n                {memorySystem.shortTerm.map((memory, index) => (\n                  memory.semanticAnalysis && (\n                    <div key={index} className=\"bg-white dark:bg-gray-700 rounded-lg shadow-sm p-3 mb-3 border border-gray-100 dark:border-gray-600\">\n                      <div className=\"text-sm mb-2\">\n                        <div className=\"font-medium mb-1\">Girdi: {memory.content}</div>\n                        <div className=\"text-xs text-gray-500\">\n                          {memory.semanticAnalysis.words.map((w, i) => (\n                            <div key={i}>\n                              <span className=\"font-medium\">{w.word}</span>: {w.meaning} ({w.role})\n                            </div>\n                          ))}\n                        </div>\n                      </div>\n                      <div className=\"text-xs border-t pt-2 mt-2\">\n                        <div>Amaç: {memory.semanticAnalysis.intent}</div>\n                        <div>Güven: {(memory.semanticAnalysis.confidence * 100).toFixed(1)}%</div>\n                        <div>Başarı Oranı: {(memory.semanticAnalysis.statistics.successRate * 100).toFixed(1)}%</div>\n                      </div>\n                    </div>\n                  )\n                ))}\n              </div>\n            </div>\n          )}\n        </div>\n\n        <div className=\"p-4 border-t border-gray-200 dark:border-gray-700 flex justify-end\">\n          <button\n            className=\"px-4 py-2 rounded-md bg-primary-500 hover:bg-primary-600 text-white transition-colors\"\n            onClick={onClose}\n          >\n            Kapat\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default MemoryPanel;","size_bytes":14066},"client/src/components/NetworkVisualizer.tsx":{"content":"import React, { useEffect, useRef, useState } from 'react';\nimport * as THREE from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\nimport { NetworkNode, Relation } from '@/lib/NeuralNetworkUtils';\n\ninterface NetworkVisualizerProps {\n  mode: 'simple' | 'detailed' | '3d';\n  userNetworks: (NetworkNode | null)[][][];\n  systemNetworks: (NetworkNode | null)[][][];\n  activatedNodes: NetworkNode[];\n  relations: Relation[];\n  bidirectionalRelations: Relation[];\n  showRelations: boolean;\n  onNodeClick: (node: NetworkNode) => void;\n}\n\nconst NetworkVisualizer: React.FC<NetworkVisualizerProps> = ({\n  mode,\n  userNetworks,\n  systemNetworks,\n  activatedNodes,\n  relations,\n  bidirectionalRelations,\n  showRelations,\n  onNodeClick\n}) => {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);\n  const sceneRef = useRef<THREE.Scene | null>(null);\n  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);\n  const controlsRef = useRef<OrbitControls | null>(null);\n  const nodeObjectsRef = useRef<THREE.Mesh[]>([]);\n  const nodeDataRef = useRef<NetworkNode[]>([]);\n  const lineObjectsRef = useRef<THREE.Line[]>([]);\n  const svgRef = useRef<SVGSVGElement | null>(null);\n\n  const [selectedNode, setSelectedNode] = useState<NetworkNode | null>(null);\n\n  useEffect(() => {\n    if (mode === '3d') {\n      initThreeJS();\n      return () => {\n        if (rendererRef.current) {\n          rendererRef.current.dispose();\n          controlsRef.current?.dispose();\n          while(sceneRef.current?.children.length) {\n            const obj = sceneRef.current.children[0];\n            sceneRef.current.remove(obj);\n          }\n        }\n      };\n    }\n  }, [mode]);\n\n  useEffect(() => {\n    if (mode === '3d') {\n      updateNetwork3D();\n    }\n  }, [userNetworks, systemNetworks, activatedNodes, mode, showRelations]);\n\n  // 3D görselleştirme için üç.js kurulumu\n  const initThreeJS = () => {\n    if (!containerRef.current) return;\n\n    // Scene\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(0x111827); // dark:bg-gray-900\n    sceneRef.current = scene;\n\n    // Camera\n    const camera = new THREE.PerspectiveCamera(\n      75,\n      containerRef.current.clientWidth / containerRef.current.clientHeight,\n      0.1,\n      1000\n    );\n    camera.position.z = 20;\n    cameraRef.current = camera;\n\n    // Renderer\n    const renderer = new THREE.WebGLRenderer({ antialias: true });\n    renderer.setSize(containerRef.current.clientWidth, containerRef.current.clientHeight);\n    containerRef.current.innerHTML = '';\n    containerRef.current.appendChild(renderer.domElement);\n    rendererRef.current = renderer;\n\n    // Controls\n    const controls = new OrbitControls(camera, renderer.domElement);\n    controls.enableDamping = true;\n    controls.dampingFactor = 0.05;\n    controlsRef.current = controls;\n\n    // Lighting\n    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);\n    scene.add(ambientLight);\n\n    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\n    directionalLight.position.set(10, 10, 10);\n    scene.add(directionalLight);\n\n    // Animation loop\n    const animate = () => {\n      requestAnimationFrame(animate);\n      controls.update();\n      renderer.render(scene, camera);\n    };\n    animate();\n\n    // Window resize handler\n    const handleResize = () => {\n      if (!containerRef.current || !cameraRef.current || !rendererRef.current) return;\n\n      cameraRef.current.aspect = containerRef.current.clientWidth / containerRef.current.clientHeight;\n      cameraRef.current.updateProjectionMatrix();\n      rendererRef.current.setSize(containerRef.current.clientWidth, containerRef.current.clientHeight);\n    };\n\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  };\n\n  // 3D Ağ güncellemesi\n  const updateNetwork3D = () => {\n    if (!sceneRef.current || !mode === '3d') return;\n\n    // Clear previous objects\n    nodeObjectsRef.current.forEach(obj => sceneRef.current?.remove(obj));\n    lineObjectsRef.current.forEach(obj => sceneRef.current?.remove(obj));\n    nodeObjectsRef.current = [];\n    lineObjectsRef.current = [];\n    nodeDataRef.current = [];\n\n    // Node geometry for user and system nodes\n    const userGeometry = new THREE.SphereGeometry(0.3, 16, 16);\n    const systemGeometry = new THREE.SphereGeometry(0.3, 16, 16);\n\n    // Node materials\n    const userMaterial = new THREE.MeshPhongMaterial({ color: 0x4F46E5 }); // primary-600\n    const systemMaterial = new THREE.MeshPhongMaterial({ color: 0x8B5CF6 }); // purple-500\n    const activatedMaterial = new THREE.MeshPhongMaterial({ color: 0xF97316 }); // orange-500\n\n    // Collect all non-null nodes\n    const allUserNodes: NetworkNode[] = [];\n    const allSystemNodes: NetworkNode[] = [];\n\n    userNetworks.forEach((layer, layerIdx) => {\n      layer.forEach(row => {\n        row.forEach(node => {\n          if (node) {\n            // Position node in 3D space\n            const position = node.position || new THREE.Vector3(\n              (Math.random() * 2 - 1) * 10,\n              (Math.random() * 2 - 1) * 10,\n              layerIdx * 5 - 7.5\n            );\n\n            // Create node mesh\n            const isActivated = activatedNodes.some(aNode => aNode.id === node.id);\n            const material = isActivated ? activatedMaterial : userMaterial;\n            const nodeMesh = new THREE.Mesh(userGeometry, material);\n            nodeMesh.position.copy(position);\n\n            // Save reference to node data\n            nodeMesh.userData = { nodeId: node.id };\n\n            sceneRef.current?.add(nodeMesh);\n            nodeObjectsRef.current.push(nodeMesh);\n            nodeDataRef.current.push(node);\n            allUserNodes.push(node);\n          }\n        });\n      });\n    });\n\n    systemNetworks.forEach((layer, layerIdx) => {\n      layer.forEach(row => {\n        row.forEach(node => {\n          if (node) {\n            // Position node in 3D space\n            const position = node.position || new THREE.Vector3(\n              (Math.random() * 2 - 1) * 10,\n              (Math.random() * 2 - 1) * 10,\n              layerIdx * 5 + 2.5  // Offset from user networks\n            );\n\n            // Create node mesh\n            const isActivated = activatedNodes.some(aNode => aNode.id === node.id);\n            const material = isActivated ? activatedMaterial : systemMaterial;            const nodeMesh = new THREE.Mesh(systemGeometry, material);\n            nodeMesh.position.copy(position);\n\n            // Save reference to node data\n            nodeMesh.userData = { nodeId: node.id };\n\n            sceneRef.current?.add(nodeMesh);\n            nodeObjectsRef.current.push(nodeMesh);\n            nodeDataRef.current.push(node);\n            allSystemNodes.push(node);\n          }\n        });\n      });\n    });\n\n    // Add connections if showing relations\n    if (showRelations) {\n      // Create connections between nodes based on relations\n      const lineMaterial = new THREE.LineBasicMaterial({ \n        color: 0x6366F1,\n        opacity: 0.5,\n        transparent: true\n      });\n\n      relations.forEach(relation => {\n        const sourceNode = allUserNodes.find(node => node.word === relation.userWord);\n        const targetNode = allSystemNodes.find(node => node.word === relation.systemWord);\n\n        if (sourceNode && targetNode && sourceNode.position && targetNode.position) {\n          const points = [\n            new THREE.Vector3(sourceNode.position.x, sourceNode.position.y, sourceNode.position.z),\n            new THREE.Vector3(targetNode.position.x, targetNode.position.y, targetNode.position.z)\n          ];\n\n          const geometry = new THREE.BufferGeometry().setFromPoints(points);\n          const line = new THREE.Line(geometry, lineMaterial);\n\n          sceneRef.current?.add(line);\n          lineObjectsRef.current.push(line);\n        }\n      });\n    }\n\n    // Add raycaster for interaction\n    const raycaster = new THREE.Raycaster();\n    const mouse = new THREE.Vector2();\n\n    const handleCanvasClick = (event: MouseEvent) => {\n      if (!containerRef.current || !cameraRef.current) return;\n\n      // Calculate mouse position in normalized device coordinates\n      const rect = containerRef.current.getBoundingClientRect();\n      mouse.x = ((event.clientX - rect.left) / containerRef.current.clientWidth) * 2 - 1;\n      mouse.y = -((event.clientY - rect.top) / containerRef.current.clientHeight) * 2 + 1;\n\n      // Update the picking ray with the camera and mouse position\n      raycaster.setFromCamera(mouse, cameraRef.current);\n\n      // Calculate objects intersecting the picking ray\n      const intersects = raycaster.intersectObjects(nodeObjectsRef.current);\n\n      if (intersects.length > 0) {\n        const clickedNodeMesh = intersects[0].object as THREE.Mesh;\n        const nodeId = clickedNodeMesh.userData.nodeId;\n        const nodeData = nodeDataRef.current.find(node => node.id === nodeId);\n\n        if (nodeData) {\n          setSelectedNode(nodeData);\n          onNodeClick(nodeData);\n        }\n      }\n    };\n\n    if (containerRef.current) {\n      const canvas = containerRef.current.querySelector('canvas');\n      if (canvas) {\n        canvas.addEventListener('click', handleCanvasClick);\n        return () => canvas.removeEventListener('click', handleCanvasClick);\n      }\n    }\n  };\n\n  // 2D SVG Görselleştirme\n  const renderSimpleNetwork = () => {\n    // Convert flat network structure for visualization\n    const userNodes: NetworkNode[] = [];\n    const systemNodes: NetworkNode[] = [];\n\n    // Extract non-null nodes \n    userNetworks.forEach(layer => \n      layer.forEach(row => \n        row.forEach(node => {\n          if (node) userNodes.push(node);\n        })\n      )\n    );\n\n    systemNetworks.forEach(layer => \n      layer.forEach(row => \n        row.forEach(node => {\n          if (node) systemNodes.push(node);\n        })\n      )\n    );\n\n    // Get most activated nodes for visualization\n    const topUserNodes = userNodes\n      .sort((a, b) => b.activation - a.activation)\n      .slice(0, 10);\n\n    const topSystemNodes = systemNodes\n      .sort((a, b) => b.activation - a.activation)\n      .slice(0, 10);\n\n    // Create visualization\n    const width = 800;\n    const height = 400;\n\n    // Eğitilmemiş veya boş ağ kontrolü\n    const hasNodes = userNetworks.some(layer => \n      layer.some(row => row.some(node => node !== null))\n    ) || systemNetworks.some(layer => \n      layer.some(row => row.some(node => node !== null))\n    );\n\n    if (!hasNodes || !relations.length || !activatedNodes.length) {\n      return (\n        <svg \n          width=\"100%\" \n          height=\"100%\" \n          viewBox={`0 0 ${width} ${height}`} \n          className=\"visualization-simple\"\n          ref={svgRef}\n        >\n          <text x={width/2} y={height/2} textAnchor=\"middle\" className=\"text-gray-400\">\n            Henüz ağ eğitilmemiş veya aktif bağlantı yok.\n          </text>\n        </svg>\n      );\n    }\n\n    // Generate connection paths\n    const connections = showRelations \n      ? topUserNodes.flatMap(userNode => {\n          return topSystemNodes.map(systemNode => {\n            // Find if relation exists\n            const relation = relations.find(r => \n              r.userWord === userNode.word && r.systemWord === systemNode.word\n            );\n\n            if (relation) {\n              const strength = relation.association / 100;\n              return {\n                from: userNode,\n                to: systemNode,\n                strength\n              };\n            }\n            return null;\n          }).filter(Boolean);\n        })\n      : [];\n\n    return (\n      <svg \n        width=\"100%\" \n        height=\"100%\" \n        viewBox={`0 0 ${width} ${height}`} \n        className=\"visualization-simple\"\n        ref={svgRef}\n      >\n        {/* Connection lines */}\n        <g className=\"connections\">\n          {connections.map((conn, idx) => {\n            if (!conn) return null;\n\n            const userX = 100;\n            const userY = 100 + (topUserNodes.indexOf(conn.from) * 40);\n            const systemX = 400;\n            const systemY = 100 + (topSystemNodes.indexOf(conn.to) * 40);\n\n            return (\n              <path \n                key={`conn-${idx}`}\n                d={`M${userX},${userY} C${userX + 150},${userY - 50} ${systemX - 150},${systemY + 50} ${systemX},${systemY}`}\n                stroke=\"#8B5CF6\" \n                strokeWidth={1.5 * (conn.strength || 0.6)}\n                strokeOpacity={0.6}\n                fill=\"none\"\n                className=\"connection-line\"\n              />\n            );\n          })}\n        </g>\n\n        {/* User Nodes */}\n        <g className=\"neural-layer\" data-layer=\"1\" data-type=\"user\">\n          {topUserNodes.map((node, idx) => {\n            const y = 100 + (idx * 40);\n            const isActivated = activatedNodes.some(n => n.id === node.id);\n\n            return (\n              <g key={`user-${idx}`}>\n                <circle \n                  cx=\"100\" \n                  cy={y} \n                  r=\"12\" \n                  fill={isActivated ? \"#F97316\" : \"#4F46E5\"} \n                  className=\"neural-node\" \n                  data-word={node.word}\n                  onClick={() => onNodeClick(node)}\n                />\n                <text \n                  x=\"120\" \n                  y={y + 4} \n                  fontSize=\"11\" \n                  fill=\"currentColor\" \n                  className=\"select-none\"\n                >\n                  {node.word}\n                </text>\n              </g>\n            );\n          })}\n        </g>\n\n        {/* System Nodes */}\n        <g className=\"neural-layer\" data-layer=\"1\" data-type=\"system\">\n          {topSystemNodes.map((node, idx) => {\n            const y = 100 + (idx * 40);\n            const isActivated = activatedNodes.some(n => n.id === node.id);\n\n            return (\n              <g key={`system-${idx}`}>\n                <circle \n                  cx=\"400\" \n                  cy={y} \n                  r=\"12\" \n                  fill={isActivated ? \"#F97316\" : \"#8B5CF6\"} \n                  className=\"neural-node\" \n                  data-word={node.word}\n                  onClick={() => onNodeClick(node)}\n                />\n                <text \n                  x=\"420\" \n                  y={y + 4} \n                  fontSize=\"11\" \n                  fill=\"currentColor\" \n                  className=\"select-none\"\n                >\n                  {node.word}\n                </text>\n              </g>\n            );\n          })}\n        </g>\n\n        {/* Layer Labels */}\n        <g className=\"neural-layer-labels\">\n          <text x=\"100\" y=\"50\" fill=\"currentColor\" className=\"text-xs font-medium text-center\">\n            Kullanıcı Kelimeler\n          </text>\n          <text x=\"400\" y=\"50\" fill=\"currentColor\" className=\"text-xs font-medium text-center\">\n            Sistem Kelimeler\n          </text>\n        </g>\n      </svg>\n    );\n  };\n\n  const renderDetailedNetwork = () => {\n    // Similar to simple but with more details and more nodes\n    // Extract non-null nodes, showing more node details and layer structure\n    const allUserNodes: NetworkNode[][] = userNetworks.map(layer => {\n      return layer.flatMap(row => row.filter(node => node !== null) as NetworkNode[]);\n    });\n\n    const allSystemNodes: NetworkNode[][] = systemNetworks.map(layer => {\n      return layer.flatMap(row => row.filter(node => node !== null) as NetworkNode[]);\n    });\n\n    // Create 4-layer visualization (up to 4 layers from each network)\n    const width = 800;\n    const height = 500;\n\n    return (\n      <svg \n        width=\"100%\" \n        height=\"100%\" \n        viewBox={`0 0 ${width} ${height}`} \n        className=\"visualization-detailed\"\n        ref={svgRef}\n      >\n        {/* Draw connections if needed */}\n        {showRelations && (\n          <g className=\"connections\">\n            {relations.slice(0, 50).map((relation, idx) => {\n              // Find node positions\n              let userNodePos = null;\n              let systemNodePos = null;\n\n              // Search for user node\n              for (let l = 0; l < allUserNodes.length; l++) {\n                const layerNodes = allUserNodes[l];\n                const nodeIdx = layerNodes.findIndex(n => n.word === relation.userWord);\n\n                if (nodeIdx >= 0) {\n                  const x = 100 + (l * 150);\n                  const y = 100 + (nodeIdx * 30);\n                  userNodePos = { x, y };\n                  break;\n                }\n              }\n\n              // Search for system node\n              for (let l = 0; l < allSystemNodes.length; l++) {\n                const layerNodes = allSystemNodes[l];\n                const nodeIdx = layerNodes.findIndex(n => n.word === relation.systemWord);\n\n                if (nodeIdx >= 0) {\n                  const x = 400 + (l * 150);\n                  const y = 100 + (nodeIdx * 30);\n                  systemNodePos = { x, y };\n                  break;\n                }\n              }\n\n              if (userNodePos && systemNodePos) {\n                return (\n                  <path \n                    key={`rel-${idx}`}\n                    d={`M${userNodePos.x},${userNodePos.y} C${userNodePos.x + 50},${userNodePos.y} ${systemNodePos.x - 50},${systemNodePos.y} ${systemNodePos.x},${systemNodePos.y}`}\n                    stroke=\"#8B5CF6\" \n                    strokeWidth={1.5 * (relation.strength / 100 || 0.6)}\n                    strokeOpacity={0.6}\n                    fill=\"none\"\n                    className=\"connection-line\"\n                  />\n                );\n              }\n\n              return null;\n            })}\n          </g>\n        )}\n\n        {/* Draw user network layers */}\n        {allUserNodes.slice(0, 2).map((layerNodes, layerIdx) => {\n          const x = 100 + (layerIdx * 150);\n\n          return (\n            <g key={`user-layer-${layerIdx}`} className=\"neural-layer\" data-layer={layerIdx} data-type=\"user\">\n              {layerNodes.slice(0, 15).map((node, nodeIdx) => {\n                const y = 100 + (nodeIdx * 30);\n                const isActivated = activatedNodes.some(n => n.id === node.id);\n\n                return (\n                  <g key={`user-node-${layerIdx}-${nodeIdx}`}>\n                    <circle \n                      cx={x} \n                      cy={y} \n                      r=\"10\" \n                      fill={isActivated ? \"#F97316\" : \"#4F46E5\"} \n                      opacity={node.activation.toFixed(1)} \n                      className=\"neural-node\" \n                      data-word={node.word}\n                      onClick={() => onNodeClick(node)}\n                    />\n                    <text \n                      x={x + 15} \n                      y={y + 4} \n                      fontSize=\"10\" \n                      fill=\"currentColor\" \n                      className=\"select-none\"\n                    >\n                      {node.word}\n                    </text>\n                  </g>\n                );\n              })}\n\n              <text x={x} y=\"70\" fill=\"currentColor\" className=\"text-xs font-medium\">\n                Kullanıcı K{layerIdx + 1}\n              </text>\n            </g>\n          );\n        })}\n\n        {/* Draw system network layers */}\n        {allSystemNodes.slice(0, 2).map((layerNodes, layerIdx) => {\n          const x = 400 + (layerIdx * 150);\n\n          return (\n            <g key={`system-layer-${layerIdx}`} className=\"neural-layer\" data-layer={layerIdx} data-type=\"system\">\n              {layerNodes.slice(0, 15).map((node, nodeIdx) => {\n                const y = 100 + (nodeIdx * 30);\n                const isActivated = activatedNodes.some(n => n.id === node.id);\n\n                return (\n                  <g key={`system-node-${layerIdx}-${nodeIdx}`}>\n                    <circle \n                      cx={x} \n                      cy={y} \n                      r=\"10\" \n                      fill={isActivated ? \"#F97316\" : \"#8B5CF6\"} \n                      opacity={node.activation.toFixed(1)} \n                      className=\"neural-node\" \n                      data-word={node.word}\n                      onClick={() => onNodeClick(node)}\n                    />\n                    <text \n                      x={x + 15} \n                      y={y + 4} \n                      fontSize=\"10\" \n                      fill=\"currentColor\" \n                      className=\"select-none\"\n                    >\n                      {node.word}\n                    </text>\n                  </g>\n                );\n              })}\n\n              <text x={x} y=\"70\" fill=\"currentColor\" className=\"text-xs font-medium\">\n                Sistem K{layerIdx + 1}\n              </text>\n            </g>\n          );\n        })}\n      </svg>\n    );\n  };\n\n  return (\n    <div \n      ref={containerRef} \n      className=\"w-full h-full bg-white dark:bg-gray-800 rounded-xl shadow-sm border border-gray-200 dark:border-gray-700 overflow-hidden flex flex-col\"\n    >\n      {mode === 'simple' && renderSimpleNetwork()}\n      {mode === 'detailed' && renderDetailedNetwork()}\n      {mode === '3d' && <div className=\"w-full h-full\" />}\n\n      {/* Selected node info panel */}\n      {selectedNode && (\n        <div className=\"absolute bottom-0 left-0 right-0 bg-white dark:bg-gray-800 bg-opacity-90 dark:bg-opacity-90 p-3 text-sm border-t border-gray-200 dark:border-gray-700\">\n          <div className=\"flex justify-between items-start\">\n            <div>\n              <span className=\"font-medium text-primary-600 dark:text-primary-400\">{selectedNode.word}</span>\n              <div className=\"mt-1 grid grid-cols-2 gap-x-4 gap-y-1 text-xs\">\n                <div>Aktivasyon: <span className=\"font-medium\">{selectedNode.activation.toFixed(2)}</span></div>\n                <div>Kullanım: <span className=\"font-medium\">{selectedNode.count}</span></div>\n                <div>Bağlantı Sayısı: <span className=\"font-medium\">{selectedNode.connections.length}</span></div>\n                <div>Derinlik: <span className=\"font-medium\">{selectedNode.depth}</span></div>\n              </div>\n            </div>\n            <button \n              className=\"text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200\"\n              onClick={() => setSelectedNode(null)}\n            >\n              <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M6 18L18 6M6 6l12 12\" />\n              </svg>\n            </button>\n          </div>\n          <div className=\"mt-2 text-xs\">\n            <span className=\"font-medium\">Bağlantılar:</span> {selectedNode.parentWords.join(', ') || 'Bağlantı yok'}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default NetworkVisualizer;\n","size_bytes":23023},"client/src/components/NeuralNetwork3D.tsx":{"content":"import { useRef, useEffect, useState } from 'react';\nimport * as THREE from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\nimport { NetworkNode, Relation } from '@/lib/NeuralNetworkUtils';\nimport { useTheme } from '@/contexts/ThemeContext';\n\ninterface NeuralNetwork3DProps {\n  userNetworks: (NetworkNode | null)[][][];\n  systemNetworks: (NetworkNode | null)[][][];\n  relations: Relation[];\n  bidirectionalRelations: Relation[];\n  activatedNodes: {\n    layer: number;\n    row: number;\n    col: number;\n    type: 'user' | 'system';\n  }[];\n  onNodeClick?: (node: NetworkNode, layer: number, row: number, col: number, type: 'user' | 'system') => void;\n}\n\nexport default function NeuralNetwork3D({\n  userNetworks,\n  systemNetworks,\n  relations,\n  bidirectionalRelations,\n  activatedNodes,\n  onNodeClick\n}: NeuralNetwork3DProps) {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const { isDarkMode } = useTheme();\n  const [hoveredNode, setHoveredNode] = useState<{\n    node: NetworkNode;\n    x: number;\n    y: number;\n  } | null>(null);\n  \n  // Scene state with references for cleanup\n  const sceneRef = useRef<{\n    scene?: THREE.Scene;\n    camera?: THREE.PerspectiveCamera;\n    renderer?: THREE.WebGLRenderer;\n    controls?: OrbitControls;\n    nodeObjects?: THREE.Object3D[];\n    relationLines?: THREE.Line[];\n    raycaster?: THREE.Raycaster;\n    animationFrameId?: number;\n  }>({\n    nodeObjects: [],\n    relationLines: []\n  });\n  \n  // Renkleri belirle\n  const colors = {\n    background: isDarkMode ? 0x111827 : 0xf9fafb,\n    userNode: isDarkMode ? 0x3b82f6 : 0x3b82f6,\n    systemNode: isDarkMode ? 0x10b981 : 0x10b981,\n    activatedNode: 0xef4444,\n    relation: isDarkMode ? 0x9ca3af : 0x6b7280,\n    bidirectionalRelation: isDarkMode ? 0xfbbf24 : 0xd97706,\n    text: isDarkMode ? 0xffffff : 0x000000\n  };\n\n  // Initialize scene only once\n  useEffect(() => {\n    if (!containerRef.current) return;\n    \n    // Dimension\n    const width = containerRef.current.clientWidth;\n    const height = containerRef.current.clientHeight;\n    \n    // Scene setup\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(colors.background);\n    \n    // Camera setup\n    const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);\n    camera.position.z = 30;\n    camera.position.y = 15;\n    camera.position.x = 15;\n    \n    // Renderer setup\n    const renderer = new THREE.WebGLRenderer({ antialias: true });\n    renderer.setSize(width, height);\n    renderer.setPixelRatio(window.devicePixelRatio);\n    containerRef.current.appendChild(renderer.domElement);\n    \n    // Controls\n    const controls = new OrbitControls(camera, renderer.domElement);\n    controls.enableDamping = true;\n    \n    // Lighting\n    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);\n    scene.add(ambientLight);\n    \n    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\n    directionalLight.position.set(1, 1, 1);\n    scene.add(directionalLight);\n    \n    // Raycaster for interaction\n    const raycaster = new THREE.Raycaster();\n    const mouse = new THREE.Vector2();\n    \n    // Add to refs\n    sceneRef.current = {\n      scene,\n      camera,\n      renderer,\n      controls,\n      nodeObjects: [],\n      relationLines: [],\n      raycaster\n    };\n    \n    // Mouse move handler for hover\n    const handleMouseMove = (event: MouseEvent) => {\n      if (!containerRef.current) return;\n      \n      const rect = containerRef.current.getBoundingClientRect();\n      mouse.x = ((event.clientX - rect.left) / width) * 2 - 1;\n      mouse.y = -((event.clientY - rect.top) / height) * 2 + 1;\n    };\n    \n    // Click handler for nodes\n    const handleClick = () => {\n      if (!sceneRef.current.raycaster || !sceneRef.current.camera || !sceneRef.current.scene || !onNodeClick) return;\n      \n      raycaster.setFromCamera(mouse, camera);\n      const intersects = raycaster.intersectObjects(scene.children, true);\n      \n      if (intersects.length > 0) {\n        const object = intersects[0].object;\n        \n        // Check if it's a node\n        if (object.userData.isNode && object.userData.nodeData) {\n          const { nodeData, layer, row, col, type } = object.userData;\n          onNodeClick(nodeData, layer, row, col, type);\n        }\n      }\n    };\n    \n    // Add event listeners\n    window.addEventListener('mousemove', handleMouseMove);\n    window.addEventListener('click', handleClick);\n    \n    // Handle resize\n    const handleResize = () => {\n      if (!containerRef.current || !sceneRef.current.camera || !sceneRef.current.renderer) return;\n      \n      const width = containerRef.current.clientWidth;\n      const height = containerRef.current.clientHeight;\n      \n      sceneRef.current.camera.aspect = width / height;\n      sceneRef.current.camera.updateProjectionMatrix();\n      sceneRef.current.renderer.setSize(width, height);\n    };\n    \n    window.addEventListener('resize', handleResize);\n    \n    // Animation loop\n    const animate = () => {\n      if (!sceneRef.current.controls || !sceneRef.current.renderer || !sceneRef.current.scene || !sceneRef.current.camera) return;\n      \n      sceneRef.current.controls.update();\n      sceneRef.current.renderer.render(sceneRef.current.scene, sceneRef.current.camera);\n      \n      // Raycasting for hover\n      if (sceneRef.current.raycaster) {\n        raycaster.setFromCamera(mouse, camera);\n        const intersects = raycaster.intersectObjects(scene.children, true);\n        \n        // Reset all nodes to original color\n        scene.traverse((object) => {\n          if (object.userData.isNode && object.userData.originalColor) {\n            (object as THREE.Mesh).material = new THREE.MeshLambertMaterial({\n              color: object.userData.activated ? colors.activatedNode : object.userData.originalColor\n            });\n          }\n        });\n        \n        // Set hovered node\n        if (intersects.length > 0) {\n          const object = intersects[0].object;\n          \n          if (object.userData.isNode && object.userData.nodeData) {\n            // Highlight hovered node\n            (object as THREE.Mesh).material = new THREE.MeshLambertMaterial({\n              color: 0xff00ff, // Highlight color\n              emissive: 0x440044\n            });\n            \n            // Store hovered node for tooltip\n            const worldPos = new THREE.Vector3();\n            object.getWorldPosition(worldPos);\n            \n            const vector = worldPos.clone();\n            vector.project(camera);\n            \n            const x = (vector.x * 0.5 + 0.5) * width;\n            const y = -(vector.y * 0.5 - 0.5) * height;\n            \n            setHoveredNode({\n              node: object.userData.nodeData,\n              x,\n              y\n            });\n          } else {\n            setHoveredNode(null);\n          }\n        } else {\n          setHoveredNode(null);\n        }\n      }\n      \n      sceneRef.current.animationFrameId = requestAnimationFrame(animate);\n    };\n    \n    const animationId = requestAnimationFrame(animate);\n    sceneRef.current.animationFrameId = animationId;\n    \n    // Cleanup\n    return () => {\n      window.removeEventListener('mousemove', handleMouseMove);\n      window.removeEventListener('click', handleClick);\n      window.removeEventListener('resize', handleResize);\n      \n      if (sceneRef.current.animationFrameId) {\n        cancelAnimationFrame(sceneRef.current.animationFrameId);\n      }\n      \n      if (sceneRef.current.renderer && containerRef.current) {\n        containerRef.current.removeChild(sceneRef.current.renderer.domElement);\n      }\n      \n      // Dispose of all geometries and materials\n      if (sceneRef.current.scene) {\n        sceneRef.current.scene.traverse((object) => {\n          if (object instanceof THREE.Mesh) {\n            object.geometry.dispose();\n            \n            if (Array.isArray(object.material)) {\n              object.material.forEach(material => material.dispose());\n            } else {\n              object.material.dispose();\n            }\n          }\n        });\n      }\n    };\n  }, []);\n  \n  // Update scene when data changes\n  useEffect(() => {\n    if (!sceneRef.current.scene || !sceneRef.current.camera) return;\n    \n    const { scene } = sceneRef.current;\n    \n    // Clear previous nodes and relations\n    if (sceneRef.current.nodeObjects) {\n      sceneRef.current.nodeObjects.forEach(obj => {\n        scene.remove(obj);\n      });\n    }\n    \n    if (sceneRef.current.relationLines) {\n      sceneRef.current.relationLines.forEach(line => {\n        scene.remove(line);\n      });\n    }\n    \n    sceneRef.current.nodeObjects = [];\n    sceneRef.current.relationLines = [];\n    \n    // Store node positions for relations\n    const nodePositions = new Map<string, THREE.Vector3>();\n    \n    // Determine space between layers\n    const layerSpacing = 10;\n    const layerOffsetX = -(userNetworks.length * layerSpacing) / 2;\n    \n    // Create user network nodes\n    userNetworks.forEach((layer, layerIndex) => {\n      layer.forEach((row, rowIndex) => {\n        row.forEach((node, colIndex) => {\n          if (node) {\n            const x = layerOffsetX + layerIndex * layerSpacing;\n            const y = rowIndex * 1.2 - layer.length / 2;\n            const z = colIndex * 1.2 - row.length / 2;\n            \n            // Check if node is activated\n            const isActivated = activatedNodes.some(\n              an => an.layer === layerIndex && an.row === rowIndex && an.col === colIndex && an.type === 'user'\n            );\n            \n            const nodeGeometry = new THREE.SphereGeometry(isActivated ? 0.4 : 0.3, 16, 16);\n            const nodeMaterial = new THREE.MeshLambertMaterial({\n              color: isActivated ? colors.activatedNode : colors.userNode\n            });\n            \n            const nodeMesh = new THREE.Mesh(nodeGeometry, nodeMaterial);\n            nodeMesh.position.set(x, y, z);\n            \n            // Store metadata for interaction\n            nodeMesh.userData = {\n              isNode: true,\n              nodeData: node,\n              layer: layerIndex,\n              row: rowIndex,\n              col: colIndex,\n              type: 'user',\n              originalColor: colors.userNode,\n              activated: isActivated\n            };\n            \n            scene.add(nodeMesh);\n            sceneRef.current.nodeObjects?.push(nodeMesh);\n            \n            // Store position for relations\n            nodePositions.set(node.id, new THREE.Vector3(x, y, z));\n          }\n        });\n      });\n    });\n    \n    // Create system network nodes\n    systemNetworks.forEach((layer, layerIndex) => {\n      layer.forEach((row, rowIndex) => {\n        row.forEach((node, colIndex) => {\n          if (node) {\n            const x = layerOffsetX + (userNetworks.length + layerIndex) * layerSpacing;\n            const y = rowIndex * 1.2 - layer.length / 2;\n            const z = colIndex * 1.2 - row.length / 2;\n            \n            // Check if node is activated\n            const isActivated = activatedNodes.some(\n              an => an.layer === layerIndex && an.row === rowIndex && an.col === colIndex && an.type === 'system'\n            );\n            \n            const nodeGeometry = new THREE.SphereGeometry(isActivated ? 0.4 : 0.3, 16, 16);\n            const nodeMaterial = new THREE.MeshLambertMaterial({\n              color: isActivated ? colors.activatedNode : colors.systemNode\n            });\n            \n            const nodeMesh = new THREE.Mesh(nodeGeometry, nodeMaterial);\n            nodeMesh.position.set(x, y, z);\n            \n            // Store metadata for interaction\n            nodeMesh.userData = {\n              isNode: true,\n              nodeData: node,\n              layer: layerIndex,\n              row: rowIndex,\n              col: colIndex,\n              type: 'system',\n              originalColor: colors.systemNode,\n              activated: isActivated\n            };\n            \n            scene.add(nodeMesh);\n            sceneRef.current.nodeObjects?.push(nodeMesh);\n            \n            // Store position for relations\n            nodePositions.set(node.id, new THREE.Vector3(x, y, z));\n          }\n        });\n      });\n    });\n    \n    // Active relations filter\n    const activeRelations = relations.filter(rel => rel.strength > 30);\n    \n    // Create relations (connection lines)\n    activeRelations.forEach(relation => {\n      // Find node objects for both ends\n      const userNodePosition = findNodePositionByWord(userNetworks, relation.userWord, nodePositions);\n      const systemNodePosition = findNodePositionByWord(systemNetworks, relation.systemWord, nodePositions);\n      \n      if (userNodePosition && systemNodePosition) {\n        const points = [userNodePosition, systemNodePosition];\n        const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);\n        \n        // Line strength based on relation strength\n        const lineWidth = Math.max(1, Math.min(5, relation.strength / 30));\n        \n        const lineMaterial = new THREE.LineBasicMaterial({\n          color: colors.relation,\n          transparent: true,\n          opacity: relation.strength / 100, // Opacity based on strength\n          linewidth: lineWidth,\n        });\n        \n        const line = new THREE.Line(lineGeometry, lineMaterial);\n        line.userData = {\n          relation\n        };\n        \n        scene.add(line);\n        sceneRef.current.relationLines?.push(line);\n      }\n    });\n    \n    // Create bidirectional relations with different color\n    bidirectionalRelations.filter(rel => rel.strength > 40).forEach(relation => {\n      // Find node objects for both ends\n      const systemNodePosition = findNodePositionByWord(systemNetworks, relation.userWord, nodePositions);\n      const userNodePosition = findNodePositionByWord(userNetworks, relation.systemWord, nodePositions);\n      \n      if (userNodePosition && systemNodePosition) {\n        const points = [userNodePosition, systemNodePosition];\n        const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);\n        \n        // Line strength based on relation strength\n        const lineWidth = Math.max(1, Math.min(5, relation.strength / 30));\n        \n        const lineMaterial = new THREE.LineBasicMaterial({\n          color: colors.bidirectionalRelation,\n          transparent: true,\n          opacity: relation.strength / 100, // Opacity based on strength\n          linewidth: lineWidth,\n        });\n        \n        const line = new THREE.Line(lineGeometry, lineMaterial);\n        line.userData = {\n          relation\n        };\n        \n        scene.add(line);\n        sceneRef.current.relationLines?.push(line);\n      }\n    });\n  }, [userNetworks, systemNetworks, relations, bidirectionalRelations, activatedNodes, colors.userNode, colors.systemNode, colors.relation, colors.bidirectionalRelation, colors.activatedNode]);\n  \n  // Helper to find node position by word\n  const findNodePositionByWord = (\n    networks: (NetworkNode | null)[][][],\n    word: string,\n    nodePositions: Map<string, THREE.Vector3>\n  ): THREE.Vector3 | null => {\n    for (let layer = 0; layer < networks.length; layer++) {\n      for (let row = 0; row < networks[layer].length; row++) {\n        for (let col = 0; col < networks[layer][row].length; col++) {\n          const node = networks[layer][row][col];\n          if (node && node.word.toLowerCase() === word.toLowerCase()) {\n            const position = nodePositions.get(node.id);\n            if (position) return position;\n          }\n        }\n      }\n    }\n    return null;\n  };\n  \n  return (\n    <div className=\"relative w-full h-full min-h-[400px]\">\n      <div \n        ref={containerRef} \n        className=\"w-full h-full min-h-[400px] border rounded-lg overflow-hidden\"\n      ></div>\n      \n      {/* Hover tooltip */}\n      {hoveredNode && (\n        <div\n          className=\"absolute bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 p-2 rounded shadow-lg text-sm z-10 pointer-events-none\"\n          style={{\n            left: hoveredNode.x + 10,\n            top: hoveredNode.y + 10,\n            maxWidth: '200px'\n          }}\n        >\n          <div className=\"font-bold\">{hoveredNode.node.word}</div>\n          <div className=\"opacity-75 text-xs\">\n            Aktivasyon: {(hoveredNode.node.activation * 100).toFixed(0)}%\n          </div>\n          <div className=\"opacity-75 text-xs\">\n            Kullanım: {hoveredNode.node.count} kez\n          </div>\n          {hoveredNode.node.category && (\n            <div className=\"opacity-75 text-xs\">\n              Kategori: {hoveredNode.node.category}\n            </div>\n          )}\n        </div>\n      )}\n      \n      {/* Controls help */}\n      <div className=\"absolute bottom-2 right-2 bg-white/80 dark:bg-gray-800/80 text-gray-900 dark:text-gray-100 text-xs p-1 rounded\">\n        <div>Fare tekerleği - Yakınlaştır/Uzaklaştır</div>\n        <div>Sol tık + Sürükle - Kamerayı döndür</div>\n        <div>Sağ tık + Sürükle - Kaydır</div>\n      </div>\n    </div>\n  );\n}\n","size_bytes":17120},"client/src/components/NeuralNetworkPanel.tsx":{"content":"import React, { useState, useRef, useEffect } from 'react';\nimport { RefreshCw, ZoomIn, ZoomOut, PenTool, Plus, BarChart2, Activity, Trash2, Mic, MicOff, PlusCircle, MinusCircle, Network, Cpu, Brain, BrainCircuit } from 'lucide-react';\nimport { NetworkNode, Relation } from '@/lib/NeuralNetworkUtils';\nimport { useIsMobile } from '@/hooks/use-mobile';\nimport NeuralNetwork3D from './NeuralNetwork3D';\n\ninterface NeuralNetworkPanelProps {\n  userNetworks: (NetworkNode | null)[][][];\n  systemNetworks: (NetworkNode | null)[][][];\n  activatedNodes: NetworkNode[];\n  relations: Relation[];\n  bidirectionalRelations: Relation[];\n  onRefresh: () => void;\n  onShowCellDetails: (node: NetworkNode) => void;\n  onZoomIn: () => void;\n  onZoomOut: () => void;\n  onNewTraining: () => void;\n  onBatchTraining: () => void;\n  onAddCell?: () => void; // Yeni hücre ekleme\n  onRemoveCell?: () => void; // Hücre silme\n  onToggleVoice?: () => void; // Sesli iletişimi aç/kapat\n  isVoiceEnabled?: boolean; // Sesli iletişim etkin mi?\n  totalNodeCount: number;\n  activeRelationCount: number;\n}\n\nconst visualModes = [\n  { id: 'normal', name: 'Normal' },\n  { id: 'relations', name: 'İlişkisel' },\n  { id: '3d', name: '3D' },\n  { id: 'detailed', name: 'Detaylı' },\n  { id: 'simple', name: 'Basit' }\n];\n\nconst NeuralNetworkPanel: React.FC<NeuralNetworkPanelProps> = ({\n  userNetworks,\n  systemNetworks,\n  activatedNodes,\n  relations,\n  bidirectionalRelations,\n  onRefresh,\n  onShowCellDetails,\n  onZoomIn,\n  onZoomOut,\n  onNewTraining,\n  onBatchTraining,\n  onAddCell,\n  onRemoveCell,\n  onToggleVoice,\n  isVoiceEnabled = false,\n  totalNodeCount,\n  activeRelationCount\n}) => {\n  const isMobile = useIsMobile();\n  const [visualMode, setVisualMode] = useState<string>('normal');\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  \n  useEffect(() => {\n    if (!canvasRef.current || !containerRef.current) return;\n    \n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n    \n    // Canvas boyutlarını ayarla\n    const container = containerRef.current;\n    canvas.width = container.clientWidth;\n    canvas.height = container.clientHeight;\n    \n    // Canvas'ı temizle\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    \n    // Mod seçimine göre çizim yap\n    if (visualMode === 'simple') {\n      drawSimpleNetwork(ctx, canvas.width, canvas.height);\n    } else if (visualMode === 'relations') {\n      drawRelationNetwork(ctx, canvas.width, canvas.height);\n    } else {\n      drawDetailedNetwork(ctx, canvas.width, canvas.height);\n    }\n    \n  }, [visualMode, userNetworks, systemNetworks, activatedNodes, relations]);\n  \n  // Pencere boyutu değiştiğinde canvas'ı yeniden boyutlandır\n  useEffect(() => {\n    const handleResize = () => {\n      if (!canvasRef.current || !containerRef.current) return;\n      \n      const canvas = canvasRef.current;\n      const container = containerRef.current;\n      \n      canvas.width = container.clientWidth;\n      canvas.height = container.clientHeight;\n      \n      const ctx = canvas.getContext('2d');\n      if (!ctx) return;\n      \n      // Canvas'ı temizle ve yeniden çiz\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      \n      if (visualMode === 'simple') {\n        drawSimpleNetwork(ctx, canvas.width, canvas.height);\n      } else if (visualMode === 'relations') {\n        drawRelationNetwork(ctx, canvas.width, canvas.height);\n      } else {\n        drawDetailedNetwork(ctx, canvas.width, canvas.height);\n      }\n    };\n    \n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, [visualMode, userNetworks, systemNetworks, activatedNodes, relations]);\n  \n  // Basit ağ çizimi\n  const drawSimpleNetwork = (ctx: CanvasRenderingContext2D, width: number, height: number) => {\n    // Arkaplan\n    ctx.fillStyle = '#f8fafc';\n    ctx.fillRect(0, 0, width, height);\n    \n    // Ağ çizimi\n    const nodeRadius = 5;\n    const nodeCount = Math.min(totalNodeCount, 100);\n    \n    for (let i = 0; i < nodeCount; i++) {\n      const x = Math.random() * (width - 40) + 20;\n      const y = Math.random() * (height - 40) + 20;\n      \n      // Düğüm çizimi\n      ctx.beginPath();\n      ctx.arc(x, y, nodeRadius, 0, Math.PI * 2);\n      ctx.fillStyle = i % 2 === 0 ? '#3b82f6' : '#10b981';\n      ctx.fill();\n      \n      // Bağlantı çizimi (rastgele)\n      if (i > 0) {\n        const prevX = Math.random() * (width - 40) + 20;\n        const prevY = Math.random() * (height - 40) + 20;\n        \n        ctx.beginPath();\n        ctx.moveTo(x, y);\n        ctx.lineTo(prevX, prevY);\n        ctx.strokeStyle = 'rgba(148, 163, 184, 0.3)';\n        ctx.lineWidth = 0.5;\n        ctx.stroke();\n      }\n    }\n  };\n  \n  // İlişkisel ağ çizimi\n  const drawRelationNetwork = (ctx: CanvasRenderingContext2D, width: number, height: number) => {\n    // Arkaplan\n    ctx.fillStyle = '#f8fafc';\n    ctx.fillRect(0, 0, width, height);\n    \n    const centerX = width / 2;\n    const centerY = height / 2;\n    const maxRadius = Math.min(width, height) / 2 - 50;\n    \n    // Sistem ve kullanıcı düğümleri için renkler\n    const userColor = '#3b82f6';\n    const systemColor = '#10b981';\n    \n    // Kullanıcı düğümleri - solda\n    const userNodes: { x: number, y: number, word: string }[] = [];\n    const userWords = new Set<string>();\n    \n    // Kullanıcı ağından benzersiz kelimeleri topla\n    userNetworks.forEach(layer => {\n      layer.forEach(row => {\n        row.forEach(node => {\n          if (node && !userWords.has(node.word)) {\n            userWords.add(node.word);\n          }\n        });\n      });\n    });\n    \n    // En fazla 20 kullanıcı düğümü göster\n    const userWordArray = Array.from(userWords).slice(0, 20);\n    const userWordCount = userWordArray.length;\n    \n    for (let i = 0; i < userWordCount; i++) {\n      const angle = (i / userWordCount) * Math.PI - Math.PI / 2;\n      const x = centerX - Math.cos(angle) * (maxRadius * 0.8);\n      const y = centerY + Math.sin(angle) * (maxRadius * 0.8);\n      userNodes.push({ x, y, word: userWordArray[i] });\n    }\n    \n    // Sistem düğümleri - sağda\n    const systemNodes: { x: number, y: number, word: string }[] = [];\n    const systemWords = new Set<string>();\n    \n    // Sistem ağından benzersiz kelimeleri topla\n    systemNetworks.forEach(layer => {\n      layer.forEach(row => {\n        row.forEach(node => {\n          if (node && !systemWords.has(node.word)) {\n            systemWords.add(node.word);\n          }\n        });\n      });\n    });\n    \n    // En fazla 20 sistem düğümü göster\n    const systemWordArray = Array.from(systemWords).slice(0, 20);\n    const systemWordCount = systemWordArray.length;\n    \n    for (let i = 0; i < systemWordCount; i++) {\n      const angle = (i / systemWordCount) * Math.PI + Math.PI / 2;\n      const x = centerX + Math.cos(angle) * (maxRadius * 0.8);\n      const y = centerY + Math.sin(angle) * (maxRadius * 0.8);\n      systemNodes.push({ x, y, word: systemWordArray[i] });\n    }\n    \n    // İlişkileri çiz\n    ctx.lineWidth = 0.8;\n    relations.forEach(relation => {\n      const userNode = userNodes.find(n => n.word === relation.userWord);\n      const systemNode = systemNodes.find(n => n.word === relation.systemWord);\n      \n      if (userNode && systemNode) {\n        // İlişki gücüne göre çizgi kalınlığı\n        const lineWidth = Math.max(0.2, Math.min(3, relation.strength / 50));\n        \n        // İlişki gücüne göre opaklık\n        const opacity = Math.max(0.1, Math.min(0.8, relation.strength / 100));\n        \n        ctx.beginPath();\n        ctx.moveTo(userNode.x, userNode.y);\n        \n        // İlişki eğrisi\n        const controlX = (userNode.x + systemNode.x) / 2;\n        const controlY = centerY + (Math.random() * 40 - 20);\n        \n        ctx.quadraticCurveTo(controlX, controlY, systemNode.x, systemNode.y);\n        ctx.strokeStyle = `rgba(148, 163, 184, ${opacity})`;\n        ctx.lineWidth = lineWidth;\n        ctx.stroke();\n      }\n    });\n    \n    // Aktivasyon olan düğümleri koyu çiz\n    const activatedWordSet = new Set(activatedNodes.map(n => n.word));\n    \n    // Düğümleri çiz\n    const drawNode = (node: { x: number, y: number, word: string }, color: string, isActivated: boolean) => {\n      const radius = isActivated ? 7 : 5;\n      \n      // Düğüm arkaplanı\n      ctx.beginPath();\n      ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);\n      ctx.fillStyle = isActivated ? color : `${color}80`;\n      ctx.fill();\n      \n      // Sadece aktif düğümlerin etiketlerini göster\n      if (isActivated) {\n        ctx.font = '10px Arial';\n        ctx.fillStyle = '#1e293b';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillText(node.word, node.x, node.y + radius + 12);\n      }\n    };\n    \n    // Kullanıcı düğümlerini çiz\n    userNodes.forEach(node => {\n      drawNode(node, userColor, activatedWordSet.has(node.word));\n    });\n    \n    // Sistem düğümlerini çiz\n    systemNodes.forEach(node => {\n      drawNode(node, systemColor, activatedWordSet.has(node.word));\n    });\n  };\n  \n  // Detaylı ağ çizimi\n  const drawDetailedNetwork = (ctx: CanvasRenderingContext2D, width: number, height: number) => {\n    // Arkaplan\n    ctx.fillStyle = '#f8fafc';\n    ctx.fillRect(0, 0, width, height);\n    \n    // Katmanları çiz\n    const layers = 4; // Katman sayısı\n    const layerWidth = width / (layers + 1);\n    const nodeRadius = 6;\n    \n    // Her katmandaki düğüm sayısı\n    const nodesPerLayer = [8, 12, 12, 8];\n    \n    // Tüm düğümleri sakla\n    const allNodes: { x: number, y: number, layer: number, index: number }[] = [];\n    \n    // Katmanları çiz\n    for (let layer = 0; layer < layers; layer++) {\n      const layerX = (layer + 1) * layerWidth;\n      const nodeCount = nodesPerLayer[layer];\n      const layerHeight = height / (nodeCount + 1);\n      \n      for (let i = 0; i < nodeCount; i++) {\n        const y = (i + 1) * layerHeight;\n        \n        // Düğüm çizimi\n        ctx.beginPath();\n        ctx.arc(layerX, y, nodeRadius, 0, Math.PI * 2);\n        \n        // Katmana göre renk belirle\n        const color = layer < 2 ? '#3b82f6' : '#10b981';\n        ctx.fillStyle = color;\n        ctx.fill();\n        \n        // Düğümü kaydet\n        allNodes.push({ x: layerX, y, layer, index: i });\n      }\n    }\n    \n    // Bağlantıları çiz\n    ctx.lineWidth = 0.5;\n    ctx.strokeStyle = 'rgba(148, 163, 184, 0.3)';\n    \n    for (let layer = 0; layer < layers - 1; layer++) {\n      const currentLayerNodes = allNodes.filter(n => n.layer === layer);\n      const nextLayerNodes = allNodes.filter(n => n.layer === layer + 1);\n      \n      // Her düğümü bir sonraki katmandaki 2-3 düğüme bağla\n      currentLayerNodes.forEach(currentNode => {\n        // Kaç bağlantı yapılacak\n        const connectionCount = Math.floor(Math.random() * 2) + 2;\n        \n        for (let i = 0; i < connectionCount; i++) {\n          // Rastgele bir hedef düğüm seç\n          const targetIndex = Math.floor(Math.random() * nextLayerNodes.length);\n          const targetNode = nextLayerNodes[targetIndex];\n          \n          // Bağlantıyı çiz\n          ctx.beginPath();\n          ctx.moveTo(currentNode.x, currentNode.y);\n          ctx.lineTo(targetNode.x, targetNode.y);\n          ctx.stroke();\n        }\n      });\n    }\n  };\n  \n  const handleCanvasClick = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    // Canvas'ın X ve Y konumunu al\n    if (!canvasRef.current) return;\n    \n    const canvas = canvasRef.current;\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    \n    // Yakınlık kontrolü ve düğüm detaylarını göster\n    // Not: Gerçek uygulamada burada düğüm kontrolleri yapılır\n    \n    // Örnek bir düğüm oluşturup detaylarını göster\n    if (Math.random() > 0.5) {\n      const randomNetwork = Math.random() > 0.5 ? userNetworks : systemNetworks;\n      \n      // Rastgele bir düğüm bul\n      for (let layer = 0; layer < randomNetwork.length; layer++) {\n        for (let row = 0; row < randomNetwork[layer].length; row++) {\n          for (let col = 0; col < randomNetwork[layer][row].length; col++) {\n            const node = randomNetwork[layer][row][col];\n            if (node) {\n              onShowCellDetails(node);\n              return;\n            }\n          }\n        }\n      }\n    }\n  };\n  \n  return (\n    <div className={`\n      mx-auto bg-white dark:bg-gray-800 rounded-xl shadow-sm border border-gray-200 \n      dark:border-gray-700 overflow-hidden flex flex-col\n      w-full [aspect-ratio>1]:w-3/5\n    `}>\n      <div className=\"px-4 py-3 bg-gray-50 dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 flex items-center justify-between\">\n        <h2 className=\"text-lg font-semibold text-gray-800 dark:text-gray-200 flex items-center\">\n          <BrainCircuit className=\"w-5 h-5 mr-2 text-purple-500\" />\n          <span>Sinir Ağı Görselleştirmesi</span>\n          <span className=\"ml-2 text-xs font-normal px-2 py-0.5 rounded-full bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-100\">\n            {totalNodeCount} Düğüm\n          </span>\n        </h2>\n        \n        <div className=\"flex space-x-2\">\n          {/* Ses Butonları */}\n          {onToggleVoice && (\n            <button\n              onClick={onToggleVoice}\n              className={`p-2 rounded-md ${isVoiceEnabled ? 'text-blue-500 bg-blue-50 dark:bg-blue-900/30' : 'text-gray-500 hover:text-gray-700 hover:bg-gray-100 dark:text-gray-400 dark:hover:bg-gray-700'} focus:outline-none focus:ring-2 focus:ring-primary-500`}\n              aria-label={isVoiceEnabled ? \"Sesi kapat\" : \"Sesi aç\"}\n              title={isVoiceEnabled ? \"Sesi kapat\" : \"Sesi aç\"}\n            >\n              {isVoiceEnabled ? <Mic className=\"h-5 w-5\" /> : <MicOff className=\"h-5 w-5\" />}\n            </button>\n          )}\n          \n          {/* Hücre Ekleme Butonu */}\n          {onAddCell && (\n            <div className=\"relative group\">\n              <button\n                onClick={onAddCell}\n                className=\"p-2 rounded-md text-green-500 hover:text-green-700 hover:bg-green-50 dark:hover:bg-green-900/30 focus:outline-none focus:ring-2 focus:ring-primary-500 transition-all duration-300 hover:shadow-md\"\n                aria-label=\"Hücre Ekle\"\n                title=\"Yeni Hücre Ekle\"\n              >\n                <PlusCircle className=\"h-5 w-5\" />\n              </button>\n              <span className=\"absolute hidden group-hover:inline-block -bottom-6 left-1/2 transform -translate-x-1/2 px-2 py-1 bg-black/80 text-white text-xs rounded whitespace-nowrap z-10\">\n                Ağı Genişlet\n              </span>\n            </div>\n          )}\n          \n          {/* Hücre Silme Butonu */}\n          {onRemoveCell && (\n            <div className=\"relative group\">\n              <button\n                onClick={onRemoveCell}\n                className=\"p-2 rounded-md text-red-500 hover:text-red-700 hover:bg-red-50 dark:hover:bg-red-900/30 focus:outline-none focus:ring-2 focus:ring-primary-500 transition-all duration-300 hover:shadow-md\"\n                aria-label=\"Hücre Sil\"\n                title=\"Hücre Sil\"\n              >\n                <MinusCircle className=\"h-5 w-5\" />\n              </button>\n              <span className=\"absolute hidden group-hover:inline-block -bottom-6 left-1/2 transform -translate-x-1/2 px-2 py-1 bg-black/80 text-white text-xs rounded whitespace-nowrap z-10\">\n                Ağı Optimize Et\n              </span>\n            </div>\n          )}\n          \n          {/* Otomatik Geliştirme Butonu */}\n          <div className=\"relative group\">\n            <button\n              onClick={onRefresh}\n              className=\"p-2 rounded-md text-indigo-500 hover:text-indigo-700 hover:bg-indigo-50 dark:hover:bg-indigo-900/30 focus:outline-none focus:ring-2 focus:ring-primary-500 transition-all duration-300 hover:shadow-md\"\n              aria-label=\"Otomatik Geliştir\"\n              title=\"Ağı Otomatik Geliştir\"\n            >\n              <Activity className=\"h-5 w-5\" />\n            </button>\n            <span className=\"absolute hidden group-hover:inline-block -bottom-6 left-1/2 transform -translate-x-1/2 px-2 py-1 bg-black/80 text-white text-xs rounded whitespace-nowrap z-10\">\n              Oto-Geliştirme\n            </span>\n          </div>\n          \n          {/* Yenile Butonu */}\n          <button\n            onClick={onRefresh}\n            className=\"p-2 rounded-md text-gray-500 hover:text-gray-700 hover:bg-gray-100 dark:text-gray-400 dark:hover:text-white dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-primary-500\"\n            aria-label=\"Yenile\"\n            title=\"Yenile\"\n          >\n            <RefreshCw className=\"h-5 w-5\" />\n          </button>\n        </div>\n      </div>\n      \n      <div className=\"flex flex-wrap gap-3 items-center justify-between px-4 py-2 bg-gray-100 dark:bg-gray-700 border-b border-gray-200 dark:border-gray-600\">\n        <div className=\"flex items-center\">\n          <span className=\"text-sm font-medium text-gray-600 dark:text-gray-300 mr-2\">Görünüm:</span>\n          <select\n            value={visualMode}\n            onChange={(e) => setVisualMode(e.target.value)}\n            className=\"text-sm rounded-md border-0 py-1 pl-2 pr-8 bg-white dark:bg-gray-600 text-gray-700 dark:text-gray-200 focus:ring-2 focus:ring-primary-500\"\n          >\n            {visualModes.map((mode) => (\n              <option key={mode.id} value={mode.id}>\n                {mode.name}\n              </option>\n            ))}\n          </select>\n        </div>\n        \n        <div className=\"flex flex-wrap gap-2\">\n          <div className=\"flex items-center\">\n            <span className=\"text-xs font-medium text-gray-600 dark:text-gray-300 mr-1\">Gelişim:</span>\n            <select\n              onChange={(e) => console.log(\"Gelişim modu:\", e.target.value)}\n              className=\"text-xs rounded-md border-0 py-0.5 pl-2 pr-7 bg-white dark:bg-gray-600 text-gray-700 dark:text-gray-200 focus:ring-2 focus:ring-primary-500\"\n            >\n              <option value=\"auto\">Otomatik</option>\n              <option value=\"manuel\">Manuel</option>\n              <option value=\"supervised\">Denetimli</option>\n              <option value=\"reinforcement\">Pekiştirmeli</option>\n            </select>\n          </div>\n          \n          <div className=\"flex space-x-1\">\n            <button\n              onClick={onZoomIn}\n              className=\"p-1.5 rounded-md text-gray-500 hover:text-gray-700 hover:bg-gray-200 dark:text-gray-400 dark:hover:text-white dark:hover:bg-gray-600 focus:outline-none\"\n              aria-label=\"Yakınlaştır\"\n              title=\"Yakınlaştır\"\n            >\n              <ZoomIn className=\"h-4 w-4\" />\n            </button>\n            \n            <button\n              onClick={onZoomOut}\n              className=\"p-1.5 rounded-md text-gray-500 hover:text-gray-700 hover:bg-gray-200 dark:text-gray-400 dark:hover:text-white dark:hover:bg-gray-600 focus:outline-none\"\n              aria-label=\"Uzaklaştır\"\n              title=\"Uzaklaştır\"\n            >\n              <ZoomOut className=\"h-4 w-4\" />\n            </button>\n          </div>\n        </div>\n      </div>\n      \n      <div className=\"flex-1 relative\" ref={containerRef}>\n        <canvas\n          ref={canvasRef}\n          className=\"w-full h-full\"\n          onClick={handleCanvasClick}\n        />\n        \n        {visualMode === '3d' && (\n          <div className=\"absolute inset-0\">\n            <NeuralNetwork3D \n              userNetworks={userNetworks}\n              systemNetworks={systemNetworks}\n              relations={relations}\n              bidirectionalRelations={bidirectionalRelations}\n              activatedNodes={\n                // activatedNodes'u uygun formata dönüştür\n                activatedNodes.map(node => {\n                  // Düğümün konumunu bul\n                  for (let layer = 0; layer < userNetworks.length; layer++) {\n                    for (let row = 0; row < userNetworks[layer].length; row++) {\n                      for (let col = 0; col < userNetworks[layer][row].length; col++) {\n                        if (userNetworks[layer][row][col]?.id === node.id) {\n                          return { layer, row, col, type: 'user' as const };\n                        }\n                      }\n                    }\n                  }\n                  \n                  for (let layer = 0; layer < systemNetworks.length; layer++) {\n                    for (let row = 0; row < systemNetworks[layer].length; row++) {\n                      for (let col = 0; col < systemNetworks[layer][row].length; col++) {\n                        if (systemNetworks[layer][row][col]?.id === node.id) {\n                          return { layer, row, col, type: 'system' as const };\n                        }\n                      }\n                    }\n                  }\n                  \n                  // Eğer bulunamazsa varsayılan değer döndür\n                  return { layer: 0, row: 0, col: 0, type: 'user' as const };\n                }).filter(node => node !== undefined) as {\n                  layer: number;\n                  row: number;\n                  col: number;\n                  type: 'user' | 'system';\n                }[]\n              }\n              onNodeClick={(node) => onShowCellDetails(node)}\n            />\n          </div>\n        )}\n      </div>\n      \n      <div className=\"p-3 border-t border-gray-200 dark:border-gray-700\">\n        <div className=\"flex flex-wrap items-center justify-between\">\n          <div className=\"grid grid-cols-2 gap-x-4 gap-y-1 text-xs text-gray-500 dark:text-gray-400\">\n            <div className=\"flex items-center\"><span className=\"w-28\">Toplam Düğüm:</span> <span className=\"font-medium text-gray-700 dark:text-gray-300\">{totalNodeCount}</span></div>\n            <div className=\"flex items-center\"><span className=\"w-28\">Aktif İlişki:</span> <span className=\"font-medium text-gray-700 dark:text-gray-300\">{activeRelationCount}</span></div>\n            <div className=\"flex items-center\"><span className=\"w-28\">Son Öğrenme:</span> <span className=\"font-medium text-green-600 dark:text-green-400\">+{Math.floor(Math.random() * 15) + 1} Düğüm</span></div>\n            <div className=\"flex items-center\"><span className=\"w-28\">Gelişim Oranı:</span> <span className=\"font-medium text-blue-600 dark:text-blue-400\">%{Math.floor(Math.random() * 60) + 40}</span></div>\n          </div>\n          \n          <div className=\"flex flex-col space-y-2 mt-2 lg:mt-0\">\n            <div className=\"flex space-x-2\">\n              <button\n                onClick={onNewTraining}\n                className=\"flex items-center px-3 py-2 text-xs rounded bg-gray-100 hover:bg-gray-200 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-300 transition duration-300 hover:shadow-sm\"\n              >\n                <PenTool className=\"h-3.5 w-3.5 mr-1\" />\n                <span>Manuel Eğitim</span>\n              </button>\n              \n              <button\n                onClick={onBatchTraining}\n                className=\"flex items-center px-3 py-2 text-xs rounded bg-primary-100 hover:bg-primary-200 dark:bg-primary-900/30 dark:hover:bg-primary-800/40 text-primary-700 dark:text-primary-300 transition duration-300 hover:shadow-sm\"\n              >\n                <Plus className=\"h-3.5 w-3.5 mr-1\" />\n                <span>Toplu Eğitim</span>\n              </button>\n            </div>\n            \n            <div className=\"flex space-x-2\">\n              <button\n                onClick={() => console.log(\"Kendi Kendine Öğrenme\")}\n                className=\"flex items-center px-3 py-2 text-xs rounded bg-indigo-100 hover:bg-indigo-200 dark:bg-indigo-900/30 dark:hover:bg-indigo-800/40 text-indigo-700 dark:text-indigo-300 transition duration-300 hover:shadow-sm\"\n              >\n                <BarChart2 className=\"h-3.5 w-3.5 mr-1\" />\n                <span>Oto-Öğrenme</span>\n              </button>\n              \n              <button\n                onClick={() => console.log(\"Ağ Optimizasyonu\")}\n                className=\"flex items-center px-3 py-2 text-xs rounded bg-amber-100 hover:bg-amber-200 dark:bg-amber-900/30 dark:hover:bg-amber-800/40 text-amber-700 dark:text-amber-300 transition duration-300 hover:shadow-sm\"\n              >\n                <Activity className=\"h-3.5 w-3.5 mr-1\" />\n                <span>Ağ Optimizasyonu</span>\n              </button>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default NeuralNetworkPanel;\n","size_bytes":24942},"client/src/components/TurkishDictionaryPanel.tsx":{"content":"import { useState, useEffect } from 'react';\nimport { TurkishDictionary } from '../lib/TurkishDictionary';\nimport { Button } from './ui/button';\nimport { Input } from './ui/input';\nimport { Textarea } from './ui/textarea';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from './ui/select';\nimport { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from './ui/card';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from './ui/tabs';\nimport { Table, TableBody, TableHead, TableHeader, TableRow, TableCell } from './ui/table';\nimport { Dialog, DialogContent, DialogFooter, DialogHeader, DialogTitle, DialogTrigger } from './ui/dialog';\nimport { Label } from './ui/label';\nimport { ScrollArea } from './ui/scroll-area';\nimport { Badge } from './ui/badge';\nimport { AlertCircle, Info, Plus, Save, Trash2, Upload, Download } from 'lucide-react';\nimport { Alert, AlertDescription, AlertTitle } from './ui/alert';\nimport { useTheme } from '../contexts/ThemeContext';\n\n// Add this component to App.tsx to use it\nexport function TurkishDictionaryPanel() {\n  const [dictionary] = useState(() => new TurkishDictionary());\n  const [words, setWords] = useState<Array<any>>([]);\n  const [stats, setStats] = useState<any>({});\n  const [selectedWord, setSelectedWord] = useState<any>(null);\n  const [newWord, setNewWord] = useState({\n    word: '',\n    meaning: '',\n    type: 'isim',\n    examples: ''\n  });\n  const [bulkImport, setBulkImport] = useState('');\n  const [searchQuery, setSearchQuery] = useState('');\n  const [isAddDialogOpen, setIsAddDialogOpen] = useState(false);\n  const [isEditDialogOpen, setIsEditDialogOpen] = useState(false);\n  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);\n  const [isBulkImportDialogOpen, setIsBulkImportDialogOpen] = useState(false);\n  const [activeTab, setActiveTab] = useState('words');\n\n  // Verileri yükle\n  useEffect(() => {\n    loadDictionary();\n  }, []);\n\n  const loadDictionary = () => {\n    // Locale'den sözlüğü yükle\n    const loaded = dictionary.loadFromLocalStorage();\n\n    // Kelimeleri ve istatistikleri yükle\n    const allWords = dictionary.exportDictionary();\n    setWords(allWords);\n\n    // İstatistikleri güncelle\n    const stats = dictionary.getDictionaryStats();\n    const semanticStats = dictionary.getStatistics();\n    setStats({ ...stats, ...semanticStats });\n  };\n\n  const handleSaveDictionary = () => {\n    dictionary.saveToLocalStorage();\n    alert('Sözlük başarıyla kaydedildi!');\n  };\n\n  const handleAddWord = () => {\n    try {\n      const entry = {\n        word: newWord.word,\n        meaning: [newWord.meaning],\n        type: newWord.type as any,\n        examples: newWord.examples ? newWord.examples.split('\\n') : []\n      };\n\n      dictionary.addWord(entry);\n      setNewWord({\n        word: '',\n        meaning: '',\n        type: 'isim',\n        examples: ''\n      });\n      setIsAddDialogOpen(false);\n\n      // Yeni kelime listesini güncelle\n      const allWords = dictionary.exportDictionary();\n      setWords(allWords);\n\n      // İstatistikleri güncelle\n      const stats = dictionary.getDictionaryStats();\n      setStats(stats);\n    } catch (error) {\n      alert('Kelime eklenirken bir hata oluştu: ' + error);\n    }\n  };\n\n  const handleUpdateWord = () => {\n    if (!selectedWord) return;\n\n    try {\n      const entry = {\n        word: selectedWord.word,\n        meaning: selectedWord.meaning,\n        type: selectedWord.type,\n        examples: typeof selectedWord.examples === 'string' \n          ? selectedWord.examples.split('\\n') \n          : selectedWord.examples\n      };\n\n      dictionary.updateWord(selectedWord.word, entry);\n      setIsEditDialogOpen(false);\n\n      // Kelime listesini güncelle\n      const allWords = dictionary.exportDictionary();\n      setWords(allWords);\n    } catch (error) {\n      alert('Kelime güncellenirken bir hata oluştu: ' + error);\n    }\n  };\n\n  const handleDeleteWord = () => {\n    if (!selectedWord) return;\n\n    try {\n      dictionary.removeWord(selectedWord.word);\n      setSelectedWord(null);\n      setIsDeleteDialogOpen(false);\n\n      // Kelime listesini güncelle\n      const allWords = dictionary.exportDictionary();\n      setWords(allWords);\n\n      // İstatistikleri güncelle\n      const stats = dictionary.getDictionaryStats();\n      setStats(stats);\n    } catch (error) {\n      alert('Kelime silinirken bir hata oluştu: ' + error);\n    }\n  };\n\n  const handleBulkImport = () => {\n    try {\n      // JSON formatında toplu veri ekleme\n      const trimmedInput = bulkImport.trim();\n      let entries;\n\n      try {\n        entries = JSON.parse(trimmedInput);\n      } catch (parseError) {\n        // Basit metin formatında girdi kontrolü\n        if (trimmedInput.includes('\\n')) {\n          // Her satır bir kelime olarak değerlendir\n          const lines = trimmedInput.split('\\n').filter(line => line.trim().length > 0);\n          entries = lines.map(line => {\n            const parts = line.split(':');\n            const word = parts[0].trim();\n            const meaning = parts.length > 1 ? parts[1].trim() : `${word} anlamı`;\n            return {\n              word,\n              meaning: [meaning],\n              type: 'isim' // Varsayılan tür\n            };\n          });\n        } else {\n          throw parseError;\n        }\n      }\n\n      if (Array.isArray(entries)) {\n        // Eksik alanları olan girişleri düzelt\n        const validatedEntries = entries.map(entry => {\n          return {\n            word: entry.word,\n            meaning: Array.isArray(entry.meaning) ? entry.meaning : [entry.meaning || `${entry.word} anlamı`],\n            type: entry.type || 'isim',\n            examples: entry.examples || []\n          };\n        });\n\n        const result = dictionary.addBulkWords(validatedEntries);\n        alert(`${result.added} kelime eklendi, ${result.failed} kelime eklenemedi.`);\n\n        // Kelime listesini güncelle\n        const allWords = dictionary.exportDictionary();\n        setWords(allWords);\n\n        // İstatistikleri güncelle\n        const stats = dictionary.getDictionaryStats();\n        setStats(stats);\n\n        // Sözlüğü otomatik kaydet\n        dictionary.saveToLocalStorage();\n\n        setBulkImport('');\n        setIsBulkImportDialogOpen(false);\n      } else {\n        alert('Geçersiz veri formatı. JSON dizisi veya satır bazlı metin bekleniyor.');\n      }\n    } catch (error) {\n      alert('Toplu veri eklenirken bir hata oluştu: ' + error);\n    }\n  };\n\n  const exportDictionary = () => {\n    try {\n      const dictionaryData = dictionary.exportDictionary();\n      const jsonData = JSON.stringify(dictionaryData, null, 2);\n\n      // Dosyayı indirme\n      const blob = new Blob([jsonData], { type: 'application/json' });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = 'turkish_dictionary.json';\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    } catch (error) {\n      alert('Sözlük dışa aktarılırken bir hata oluştu: ' + error);\n    }\n  };\n\n  const filteredWords = searchQuery \n    ? words.filter(word => \n        word.word.toLowerCase().includes(searchQuery.toLowerCase()) ||\n        word.meaning.some((m: string) => m.toLowerCase().includes(searchQuery.toLowerCase()))\n      )\n    : words;\n\n  return (\n    <div className=\"tab-panel-container\">\n      <Card className=\"mb-4\">\n        <CardHeader>\n          <CardTitle className=\"text-2xl font-bold\">Türkçe Sözlük Yönetimi</CardTitle>\n          <CardDescription>\n            Kelime ekleyebilir, düzenleyebilir ve silebilirsiniz. Toplu veri yükleme ve dışa aktarma işlemleri de yapabilirsiniz.\n          </CardDescription>\n        </CardHeader>\n        <CardContent>\n          <Tabs defaultValue=\"words\" value={activeTab} onValueChange={setActiveTab}>\n            <TabsList className=\"w-full mb-4\">\n              <TabsTrigger value=\"words\" className=\"flex-1\">Kelimeler</TabsTrigger>\n              <TabsTrigger value=\"stats\" className=\"flex-1\">İstatistikler</TabsTrigger>\n              <TabsTrigger value=\"export\" className=\"flex-1\">Dışa/İçe Aktar</TabsTrigger>\n            </TabsList>\n\n            <TabsContent value=\"words\">\n              <div className=\"flex mb-4 gap-2\">\n                <Input \n                  placeholder=\"Kelime ara...\" \n                  value={searchQuery} \n                  onChange={e => setSearchQuery(e.target.value)} \n                  className=\"flex-1\"\n                />\n                <Button onClick={() => setIsAddDialogOpen(true)}>\n                  <Plus className=\"mr-2 h-4 w-4\" /> Kelime Ekle\n                </Button>\n              </div>\n\n              <ScrollArea className=\"border rounded-md p-2 mb-4\" style={{ height: '400px', maxHeight: '60vh' }}>\n                <Table>\n                  <TableHeader>\n                    <TableRow>\n                      <TableHead>Kelime</TableHead>\n                      <TableHead>Tür</TableHead>\n                      <TableHead>Anlam</TableHead>\n                      <TableHead>İşlemler</TableHead>\n                    </TableRow>\n                  </TableHeader>\n                  <TableBody>\n                    {filteredWords.map((word, index) => (\n                      <TableRow key={index}>\n                        <TableCell>{word.word}</TableCell>\n                        <TableCell>\n                          <Badge variant=\"outline\">{word.type}</Badge>\n                        </TableCell>\n                        <TableCell>{Array.isArray(word.meaning) ? word.meaning[0] : word.meaning}</TableCell>\n                        <TableCell>\n                          <div className=\"flex gap-2\">\n                            <Button \n                              variant=\"outline\" \n                              size=\"sm\" \n                              onClick={() => {\n                                setSelectedWord(word);\n                                setIsEditDialogOpen(true);\n                              }}\n                            >\n                              Düzenle\n                            </Button>\n                            <Button \n                              variant=\"destructive\" \n                              size=\"sm\" \n                              onClick={() => {\n                                setSelectedWord(word);\n                                setIsDeleteDialogOpen(true);\n                              }}\n                            >\n                              Sil\n                            </Button>\n                          </div>\n                        </TableCell>\n                      </TableRow>\n                    ))}\n                  </TableBody>\n                </Table>\n              </ScrollArea>\n            </TabsContent>\n\n            <TabsContent value=\"stats\">\n              <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n                <Card>\n                  <CardHeader>\n                    <CardTitle>Sözlük İstatistikleri</CardTitle>\n                  </CardHeader>\n                  <CardContent>\n                    <div className=\"flex flex-col gap-2\">\n                      <div className=\"flex justify-between\">\n                        <span>Toplam Kelime Sayısı:</span>\n                        <span className=\"font-bold\">{stats.totalWords || 0}</span>\n                      </div>\n                      <div className=\"border-t pt-2\">\n                        <h4 className=\"font-semibold mb-2\">Kelime Türlerine Göre Dağılım:</h4>\n                        {stats.wordsByType && Object.entries(stats.wordsByType).map(([type, count]) => (\n                          <div key={type} className=\"flex justify-between\">\n                            <span>{type}:</span>\n                            <span>{count as number}</span>\n                          </div>\n                        ))}\n                      </div>\n                    </div>\n                  </CardContent>\n                </Card>\n\n                <Card>\n                  <CardHeader>\n                    <CardTitle>Anlamlandırma & Başarı İstatistikleri</CardTitle>\n                  </CardHeader>\n                  <CardContent>\n                    <div className=\"flex flex-col gap-3\">\n                      {/* Başarı Skoru */}\n                      <div className=\"bg-gradient-to-r from-green-50 to-blue-50 dark:from-green-900 dark:to-blue-900 p-3 rounded-lg\">\n                        <h4 className=\"font-semibold mb-2 text-green-700 dark:text-green-300\">🎯 Başarı Skoru</h4>\n                        <div className=\"grid grid-cols-2 gap-2 text-sm\">\n                          <div className=\"flex justify-between\">\n                            <span>Başarı Oranı:</span>\n                            <span className=\"font-bold text-green-600\">{stats.successPercentage || '0%'}</span>\n                          </div>\n                          <div className=\"flex justify-between\">\n                            <span>Başarısızlık Oranı:</span>\n                            <span className=\"font-bold text-red-600\">{stats.failurePercentage || '0%'}</span>\n                          </div>\n                        </div>\n                      </div>\n\n                      {/* Detaylı İstatistikler */}\n                      <div className=\"grid grid-cols-2 gap-3\">\n                        <div className=\"flex justify-between\">\n                          <span>Toplam Sorgu:</span>\n                          <span className=\"font-bold\">{stats.totalQueries || 0}</span>\n                        </div>\n                        <div className=\"flex justify-between\">\n                          <span>Başarılı:</span>\n                          <span className=\"font-bold text-green-600\">{stats.successfulQueries || 0}</span>\n                        </div>\n                        <div className=\"flex justify-between\">\n                          <span>Başarısız:</span>\n                          <span className=\"font-bold text-red-600\">{stats.failedQueries || 0}</span>\n                        </div>\n                        <div className=\"flex justify-between\">\n                          <span>Ortalama Güven:</span>\n                          <span className=\"font-bold text-blue-600\">{stats.averageConfidence || '0%'}</span>\n                        </div>\n                      </div>\n\n                      {/* En Başarılı Kalıp */}\n                      <div className=\"border-t pt-2\">\n                        <div className=\"flex justify-between\">\n                          <span>En Başarılı Kalıp:</span>\n                          <span className=\"font-bold text-purple-600\">{stats.mostSuccessfulPattern || 'Henüz veri yok'}</span>\n                        </div>\n                      </div>\n\n                      {/* Kalıp Detayları */}\n                      <div className=\"border-t pt-2\">\n                        <h4 className=\"font-semibold mb-2\">Sık Kullanılan Kalıplar:</h4>\n                        <div className=\"max-h-32 overflow-y-auto\">\n                          {stats.commonPatterns && Object.entries(stats.commonPatterns).map(([pattern, count]) => (\n                            <div key={pattern} className=\"flex justify-between text-sm py-1\">\n                              <span className=\"truncate\">{pattern}:</span>\n                              <Badge variant=\"outline\">{count as number}</Badge>\n                            </div>\n                          ))}\n                          {(!stats.commonPatterns || Object.keys(stats.commonPatterns).length === 0) && (\n                            <p className=\"text-gray-500 text-sm\">Henüz kalıp verisi yok</p>\n                          )}\n                        </div>\n                      </div>\n\n                      {/* Öğrenme Sistemi Kontrolü */}\n                      <div className=\"border-t pt-2\">\n                        <Button \n                          variant=\"outline\" \n                          size=\"sm\" \n                          onClick={() => {\n                            if (confirm('Öğrenme sistemini sıfırlamak istediğinizden emin misiniz?')) {\n                              dictionary.resetLearningSystem();\n                              loadDictionary();\n                            }\n                          }}\n                          className=\"w-full\"\n                        >\n                          📊 Öğrenme Sistemini Sıfırla\n                        </Button>\n                      </div>\n                    </div>\n                  </CardContent>\n                </Card>\n              </div>\n            </TabsContent>\n\n            <TabsContent value=\"export\">\n              <div className=\"grid grid-cols-1 gap-6\">\n                <Card>\n                  <CardHeader>\n                    <CardTitle>Veri Kaydet/Yükle</CardTitle>\n                    <CardDescription>\n                      Mevcut sözlük verilerini kaydedin veya toplu veri yükleyin\n                    </CardDescription>\n                  </CardHeader>\n                  <CardContent>\n                    <Alert className=\"mb-4\">\n                      <AlertCircle className=\"h-4 w-4\" />\n                      <AlertTitle>Dikkat</AlertTitle>\n                      <AlertDescription>\n                        Toplu veri yükleme işlemi mevcut verileri üzerine yazmaz, ekler. Veri yüklerken doğru formatta olduğundan emin olun.\n                      </AlertDescription>\n                    </Alert>\n\n                    <div className=\"flex flex-col gap-4\">\n                      <Button onClick={handleSaveDictionary} className=\"flex items-center\">\n                        <Save className=\"mr-2 h-4 w-4\" /> Sözlüğü Kaydet\n                      </Button>\n\n                      <Button onClick={exportDictionary} variant=\"outline\" className=\"flex items-center\">\n                        <Download className=\"mr-2 h-4 w-4\" /> JSON Olarak İndir\n                      </Button>\n\n                      <Button onClick={() => setIsBulkImportDialogOpen(true)} variant=\"secondary\" className=\"flex items-center\">\n                        <Upload className=\"mr-2 h-4 w-4\" /> Toplu Veri Yükle\n                      </Button>\n                    </div>\n                  </CardContent>\n                </Card>\n\n                <Card>\n                  <CardHeader>\n                    <CardTitle>Örnek Format</CardTitle>\n                    <CardDescription>\n                      Toplu veri yüklerken kullanılacak JSON formatı\n                    </CardDescription>\n                  </CardHeader>\n                  <CardContent>\n                    <pre className=\"bg-secondary p-4 rounded-md overflow-auto text-xs\">\n{`[\n  {\n    \"word\": \"kapı\",\n    \"meaning\": [\"bir yere girip çıkarken geçilen ve açılıp kapanma düzeni olan duvar veya bölme açıklığı\"],\n    \"type\": \"isim\",\n    \"examples\": [\"kapıyı çalmak\", \"kapıdan geçmek\"]\n  },\n  {\n    \"word\": \"pencere\",\n    \"meaning\": [\"bir yapının duvarlarında bulunan, içeriye ışık ve hava vermek için yapılmış, çerçeveli açıklık\"],\n    \"type\": \"isim\",\n    \"examples\": [\"pencereden bakmak\", \"pencereyi açmak\"]\n  }\n]`}\n                    </pre>\n                  </CardContent>\n                </Card>\n              </div>\n            </TabsContent>\n          </Tabs>\n        </CardContent>\n        <CardFooter className=\"form-bottom-fixed flex justify-between\">\n          <div className=\"text-sm text-muted-foreground\">\n            Toplam kelime sayısı: {words.length}\n          </div>\n          <div className=\"text-sm text-muted-foreground\">\n            Son güncelleme: {new Date().toLocaleString()}\n          </div>\n        </CardFooter>\n      </Card>\n\n      {/* Kelime Ekleme Dialog */}\n      <Dialog open={isAddDialogOpen} onOpenChange={setIsAddDialogOpen}>\n        <DialogContent>\n          <DialogHeader>\n            <DialogTitle>Yeni Kelime Ekle</DialogTitle>\n          </DialogHeader>\n          <div className=\"grid gap-4 py-4\">\n            <div className=\"grid grid-cols-4 items-center gap-4\">\n              <Label htmlFor=\"word\" className=\"text-right\">Kelime</Label>\n              <Input \n                id=\"word\" \n                value={newWord.word} \n                onChange={e => setNewWord({...newWord, word: e.target.value})}\n                className=\"col-span-3\"\n              />\n            </div>\n            <div className=\"grid grid-cols-4 items-center gap-4\">\n              <Label htmlFor=\"type\" className=\"text-right\">Tür</Label>\n              <Select \n                value={newWord.type} \n                onValueChange={value => setNewWord({...newWord, type: value})}\n              >\n                <SelectTrigger className=\"col-span-3\">\n                  <SelectValue placeholder=\"Kelime türü seçin\" />\n                </SelectTrigger>\n                <SelectContent>\n                  <SelectItem value=\"isim\">İsim</SelectItem>\n                  <SelectItem value=\"fiil\">Fiil</SelectItem>\n                  <SelectItem value=\"sıfat\">Sıfat</SelectItem>\n                  <SelectItem value=\"zamir\">Zamir</SelectItem>\n                  <SelectItem value=\"edat\">Edat</SelectItem>\n                  <SelectItem value=\"bağlaç\">Bağlaç</SelectItem>\n                  <SelectItem value=\"soru\">Soru</SelectItem>\n                  <SelectItem value=\"özel\">Özel</SelectItem>\n                </SelectContent>\n              </Select>\n            </div>\n            <div className=\"grid grid-cols-4 items-center gap-4\">\n              <Label htmlFor=\"meaning\" className=\"text-right\">Anlam</Label>\n              <Textarea \n                id=\"meaning\"\n                value={newWord.meaning}\n                onChange={e => setNewWord({...newWord, meaning: e.target.value})}\n                className=\"col-span-3\"\n                rows={3}\n              />\n            </div>\n            <div className=\"grid grid-cols-4 items-center gap-4\">\n              <Label htmlFor=\"examples\" className=\"text-right\">Örnekler</Label>\n              <Textarea \n                id=\"examples\"\n                value={newWord.examples}\n                onChange={e => setNewWord({...newWord, examples: e.target.value})}\n                className=\"col-span-3\"\n                placeholder=\"Her satıra bir örnek yazın\"\n                rows={3}\n              />\n            </div>\n          </div>\n          <DialogFooter>\n            <Button variant=\"outline\" onClick={() => setIsAddDialogOpen(false)}>İptal</Button>\n            <Button onClick={handleAddWord}>Ekle</Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n\n      {/* Kelime Düzenleme Dialog */}\n      <Dialog open={isEditDialogOpen} onOpenChange={setIsEditDialogOpen}>\n        <DialogContent>\n          <DialogHeader>\n            <DialogTitle>Kelime Düzenle</DialogTitle>\n          </DialogHeader>\n          {selectedWord && (\n            <div className=\"grid gap-4 py-4\">\n              <div className=\"grid grid-cols-4 items-center gap-4\">\n                <Label htmlFor=\"edit-word\" className=\"text-right\">Kelime</Label>\n                <Input \n                  id=\"edit-word\" \n                  value={selectedWord.word} \n                  onChange={e => setSelectedWord({...selectedWord, word: e.target.value})}\n                  className=\"col-span-3\"\n                  disabled\n                />\n              </div>\n              <div className=\"grid grid-cols-4 items-center gap-4\">\n                <Label htmlFor=\"edit-type\" className=\"text-right\">Tür</Label>\n                <Select \n                  value={selectedWord.type} \n                  onValueChange={value => setSelectedWord({...selectedWord, type: value})}\n                >\n                  <SelectTrigger className=\"col-span-3\">\n                    <SelectValue placeholder=\"Kelime türü seçin\" />\n                  </SelectTrigger>\n                  <SelectContent>\n                    <SelectItem value=\"isim\">İsim</SelectItem>\n                    <SelectItem value=\"fiil\">Fiil</SelectItem>\n                    <SelectItem value=\"sıfat\">Sıfat</SelectItem>\n                    <SelectItem value=\"zamir\">Zamir</SelectItem>\n                    <SelectItem value=\"edat\">Edat</SelectItem>\n                    <SelectItem value=\"bağlaç\">Bağlaç</SelectItem>\n                    <SelectItem value=\"soru\">Soru</SelectItem>\n                    <SelectItem value=\"özel\">Özel</SelectItem>\n                  </SelectContent>\n                </Select>\n              </div>\n              <div className=\"grid grid-cols-4 items-center gap-4\">\n                <Label htmlFor=\"edit-meaning\" className=\"text-right\">Anlam</Label>\n                <Textarea \n                  id=\"edit-meaning\"\n                  value={Array.isArray(selectedWord.meaning) ? selectedWord.meaning[0] : selectedWord.meaning}\n                  onChange={e => setSelectedWord({...selectedWord, meaning: [e.target.value]})}\n                  className=\"col-span-3\"\n                  rows={3}\n                />\n              </div>\n              <div className=\"grid grid-cols-4 items-center gap-4\">\n                <Label htmlFor=\"edit-examples\" className=\"text-right\">Örnekler</Label>\n                <Textarea \n                  id=\"edit-examples\"\n                  value={Array.isArray(selectedWord.examples) ? selectedWord.examples.join('\\n') : selectedWord.examples}\n                  onChange={e => setSelectedWord({...selectedWord, examples: e.target.value})}\n                  className=\"col-span-3\"\n                  placeholder=\"Her satıra bir örnek yazın\"\n                  rows={3}\n                />\n              </div>\n            </div>\n          )}\n          <DialogFooter>\n            <Button variant=\"outline\" onClick={() => setIsEditDialogOpen(false)}>İptal</Button>\n            <Button onClick={handleUpdateWord}>Güncelle</Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n\n      {/* Kelime Silme Dialog */}\n      <Dialog open={isDeleteDialogOpen} onOpenChange={setIsDeleteDialogOpen}>\n        <DialogContent>\n          <DialogHeader>\n            <DialogTitle>Kelime Sil</DialogTitle>\n          </DialogHeader>\n          {selectedWord && (\n            <div className=\"py-4\">\n              <p className=\"mb-2\">\n                <strong>{selectedWord.word}</strong> kelimesini silmek istediğinizden emin misiniz?\n              </p>\n              <p className=\"text-muted-foreground text-sm\">\n                Bu işlem geri alınamaz.\n              </p>\n            </div>\n          )}\n          <DialogFooter>\n            <Button variant=\"outline\" onClick={() => setIsDeleteDialogOpen(false)}>İptal</Button>\n            <Button variant=\"destructive\" onClick={handleDeleteWord}>Sil</Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n\n      {/* Toplu Veri Yükleme Dialog */}\n      <Dialog open={isBulkImportDialogOpen} onOpenChange={setIsBulkImportDialogOpen}>\n        <DialogContent className=\"max-w-3xl\">\n          <DialogHeader>\n            <DialogTitle>Toplu Veri Yükle</DialogTitle>\n          </DialogHeader>\n          <div className=\"py-4\">\n            <Tabs defaultValue=\"json\" className=\"mb-4\">\n              <TabsList className=\"w-full mb-4\">\n                <TabsTrigger value=\"json\">JSON Formatı</TabsTrigger>\n                <TabsTrigger value=\"simple\">Basit Metin</TabsTrigger>\n              </TabsList>\n\n              <TabsContent value=\"json\">\n                <Alert className=\"mb-4\">\n                  <Info className=\"h-4 w-4\" />\n                  <AlertTitle>JSON Formatı</AlertTitle>\n                  <AlertDescription>\n                    JSON formatında kelime listesi ekleyin. Her kelime için \"word\", \"meaning\", \"type\" ve isteğe bağlı olarak \"examples\" alanları içerebilir.\n                  </AlertDescription>\n                </Alert>\n                <pre className=\"bg-secondary p-2 rounded-md overflow-auto text-xs mb-4\">\n{`[\n  {\n    \"word\": \"örnek\",\n    \"meaning\": [\"bir şeyin benzeri\"],\n    \"type\": \"isim\",\n    \"examples\": [\"örnek vermek\", \"güzel bir örnek\"]\n  },\n  {\n    \"word\": \"kitap\",\n    \"meaning\": [\"basılı veya dijital eser\"],\n    \"type\": \"isim\"\n  }\n]`}\n                </pre>\n              </TabsContent>\n\n              <TabsContent value=\"simple\">\n                <Alert className=\"mb-4\">\n                  <Info className=\"h-4 w-4\" />\n                  <AlertTitle>Basit Metin Formatı</AlertTitle>\n                  <AlertDescription>\n                    Her satıra bir kelime gelecek şekilde \"kelime: açıklama\" formatında girebilirsiniz. Açıklama yoksa sadece kelimeyi yazabilirsiniz.\n                  </AlertDescription>\n                </Alert>\n                <pre className=\"bg-secondary p-2 rounded-md overflow-auto text-xs mb-4\">\n{`kalem: yazma aracı\ndefter: not almak için kullanılan kağıt tomarı\nbilgisayar: elektronik hesaplama ve veri işleme aracı`}\n                </pre>\n              </TabsContent>\n            </Tabs>\n\n            <Textarea \n              value={bulkImport}\n              onChange={e => setBulkImport(e.target.value)}\n              className=\"min-h-[300px] font-mono\"\n              placeholder='[{\"word\": \"örnek\", \"meaning\": [\"bir şeyin benzeri\"], \"type\": \"isim\"}] veya her satıra \"kelime: açıklama\" formatında'\n            />\n          </div>\n          <DialogFooter>\n            <Button variant=\"outline\" onClick={() => setIsBulkImportDialogOpen(false)}>İptal</Button>\n            <Button onClick={handleBulkImport}>Yükle</Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n    </div>\n  );\n}\n","size_bytes":29733},"client/src/contexts/ThemeContext.tsx":{"content":"import React, { createContext, useContext, useEffect, useState, ReactNode } from 'react';\n\ninterface ThemeContextType {\n  isDarkMode: boolean;\n  toggleTheme: () => void;\n}\n\nconst defaultTheme: ThemeContextType = {\n  isDarkMode: false,\n  toggleTheme: () => {}\n};\n\nconst ThemeContext = createContext<ThemeContextType>(defaultTheme);\n\ninterface ThemeProviderProps {\n  children: ReactNode;\n}\n\nexport const ThemeProvider: React.FC<ThemeProviderProps> = ({ children }) => {\n  const [isDarkMode, setIsDarkMode] = useState<boolean>(() => {\n    try {\n      if (typeof window !== 'undefined') {\n        const savedTheme = localStorage.getItem('theme');\n        return savedTheme === 'dark';\n      }\n      return false;\n    } catch (error) {\n      console.error('Tema yükleme hatası:', error);\n      return false;\n    }\n  });\n\n  const toggleTheme = () => {\n    setIsDarkMode(prev => {\n      const newValue = !prev;\n      try {\n        localStorage.setItem('theme', newValue ? 'dark' : 'light');\n      } catch (error) {\n        console.error('Tema kaydetme hatası:', error);\n      }\n      return newValue;\n    });\n  };\n\n  useEffect(() => {\n    const root = document.documentElement;\n\n    if (isDarkMode) {\n      root.classList.add('dark');\n      root.classList.remove('light');\n    } else {\n      root.classList.add('light');\n      root.classList.remove('dark');\n    }\n\n    console.log(`Tema başarıyla uygulandı: ${isDarkMode ? 'Koyu' : 'Açık'}`);\n  }, [isDarkMode]);\n\n  const contextValue: ThemeContextType = {\n    isDarkMode,\n    toggleTheme\n  };\n\n  return (\n    <ThemeContext.Provider value={contextValue}>\n      {children}\n    </ThemeContext.Provider>\n  );\n};\n\nexport const useTheme = (): ThemeContextType => {\n  const context = useContext(ThemeContext);\n  if (!context) {\n    throw new Error('useTheme must be used within a ThemeProvider');\n  }\n  return context;\n};","size_bytes":1866},"client/src/contexts/ToastContext.tsx":{"content":"import React, { createContext, useContext, useState, useCallback, ReactNode } from 'react';\n\nexport type ToastType = 'success' | 'error' | 'warning' | 'info';\n\nexport interface Toast {\n  id: string;\n  message: string;\n  type: ToastType;\n  duration?: number;\n}\n\ninterface ToastContextType {\n  toasts: Toast[];\n  addToast: (message: string, type?: ToastType, duration?: number) => void;\n  removeToast: (id: string) => void;\n}\n\n// Varsayılan değerler oluştur\nconst defaultToastContext: ToastContextType = {\n  toasts: [],\n  addToast: () => {},\n  removeToast: () => {}\n};\n\n// Toast bağlam oluştur (varsayılan değerlerle)\nconst ToastContext = createContext<ToastContextType>(defaultToastContext);\n\n// Toast sağlayıcı bileşeni\nexport const ToastProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const [toasts, setToasts] = useState<Toast[]>([]);\n  \n  // Benzersiz kimlik oluşturma\n  const generateId = (): string => {\n    return Math.random().toString(36).substring(2, 9);\n  };\n  \n  // Toast ekleme işlevi\n  const addToast = useCallback((message: string, type: ToastType = 'info', duration: number = 5000): void => {\n    const id = generateId();\n    const newToast: Toast = { id, message, type, duration };\n    \n    setToasts(prev => [...prev, newToast]);\n    \n    // Otomatik kaldırma\n    if (duration > 0) {\n      setTimeout(() => {\n        removeToast(id);\n      }, duration);\n    }\n  }, []);\n  \n  // Toast kaldırma işlevi\n  const removeToast = useCallback((id: string): void => {\n    setToasts(prev => prev.filter(toast => toast.id !== id));\n  }, []);\n  \n  // Bağlam değerini hazırla\n  const contextValue = {\n    toasts,\n    addToast,\n    removeToast\n  };\n  \n  return (\n    <ToastContext.Provider value={contextValue}>\n      {children}\n      \n      {/* Toast arayüzü */}\n      {toasts.length > 0 && (\n        <div className=\"fixed top-4 right-4 z-50 flex flex-col gap-2 max-w-md\">\n          {toasts.map(toast => (\n            <div \n              key={toast.id}\n              className={`p-4 rounded-md shadow-lg text-white flex justify-between items-center animate-slide-in\n                ${toast.type === 'success' ? 'bg-green-500' : \n                toast.type === 'error' ? 'bg-red-500' : \n                toast.type === 'warning' ? 'bg-yellow-500' : 'bg-blue-500'}`}\n            >\n              <span>{toast.message}</span>\n              <button \n                onClick={() => removeToast(toast.id)}\n                className=\"ml-2 text-white hover:text-gray-200\"\n              >\n                ✕\n              </button>\n            </div>\n          ))}\n        </div>\n      )}\n    </ToastContext.Provider>\n  );\n};\n\n// Custom hook\nexport const useToast = (): ToastContextType => {\n  const context = useContext(ToastContext);\n  return context;\n};\n","size_bytes":2791},"client/src/hooks/use-mobile.ts":{"content":"import { useState, useEffect } from 'react';\n\n// Mobil cihaz tespiti için hook\nexport function useIsMobile(breakpoint: number = 768): boolean {\n  const [isMobile, setIsMobile] = useState<boolean>(false);\n\n  useEffect(() => {\n    // İlk render'da kontrol et\n    const checkIfMobile = () => {\n      if (typeof window !== 'undefined') {\n        setIsMobile(window.innerWidth < breakpoint);\n      }\n    };\n    \n    checkIfMobile();\n    \n    // Ekran boyutu değişikliklerini dinle\n    window.addEventListener('resize', checkIfMobile);\n    \n    // Temizleme fonksiyonu\n    return () => {\n      window.removeEventListener('resize', checkIfMobile);\n    };\n  }, [breakpoint]);\n  \n  return isMobile;\n}\n\n// Geriye dönük uyumluluk için varsayılan export\nexport default useIsMobile;\n","size_bytes":778},"client/src/hooks/use-mobile.tsx":{"content":"import { useState, useEffect } from 'react';\n\nexport function useIsMobile(): boolean {\n  const [isMobile, setIsMobile] = useState(false);\n\n  useEffect(() => {\n    function handleResize() {\n      setIsMobile(window.innerWidth < 768);\n    }\n\n    // Set initial value\n    handleResize();\n\n    // Add event listener\n    window.addEventListener('resize', handleResize);\n\n    // Clean up event listener\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  return isMobile;\n}\n","size_bytes":498},"client/src/hooks/use-neural-network.ts":{"content":"import { useState, useEffect, useCallback, useRef } from 'react';\nimport { v4 as uuidv4 } from 'uuid';\nimport { \n  NetworkNode, \n  Relation,\n  TrainingPair,\n  ActivationResult,\n  createEmptyGrid,\n  addWordToNetwork,\n  createRelation,\n  reinforceRelation,\n  weakenRelations,\n  propagateActivation,\n  generateResponse,\n  findReverseAnswer,\n  determineQuestionType,\n  INITIAL_GRID_ROWS,\n  INITIAL_GRID_COLS,\n  INITIAL_NETWORK_LAYERS,\n  MIN_RELATION_SCORE\n} from '../lib/NeuralNetworkUtils';\nimport { TurkishDictionary } from '../lib/TurkishDictionary';\n\ninterface NotificationRef {\n  show: (message: string, type: 'success' | 'error' | 'info' | 'warning') => void;\n}\n\ninterface NetworkState {\n  userNetworks: (NetworkNode | null)[][][];\n  systemNetworks: (NetworkNode | null)[][][];\n  relations: Relation[];\n  bidirectionalRelations: Relation[];\n  trainingHistory: TrainingPair[];\n  activatedNodes: {\n    layer: number;\n    row: number;\n    col: number;\n    type: 'user' | 'system';\n  }[];\n  stats: {\n    nodeCount: number;\n    relationCount: number;\n    trainingCount: number;\n    lastTraining: number | null;\n  };\n}\n\ninterface NeuralNetworkHook {\n  userNetworks: (NetworkNode | null)[][][];\n  systemNetworks: (NetworkNode | null)[][][];\n  relations: Relation[];\n  bidirectionalRelations: Relation[];\n  trainingHistory: TrainingPair[];\n  trainHistory?: TrainingPair[]; // Added for backward compatibility\n  networkState?: NetworkState; // Added for backward compatibility\n  activatedNodes: {\n    layer: number;\n    row: number;\n    col: number;\n    type: 'user' | 'system';\n  }[];\n  trainNetwork: (userInput: string, systemOutput: string) => Promise<void>;\n  batchTrainNetworkItems: (\n    items: Array<{ input: string, output: string }>, \n    onProgress?: (progress: number, processed: number, total: number) => void\n  ) => Promise<void>;\n  processUserInput: (userInput: string) => Promise<{ response: string; confidence: number }>;\n  refreshNetwork: () => void;\n  getNetworkStats: () => { \n    nodeCount: number; \n    relationCount: number;\n    trainingCount: number;\n    lastTraining: number | null;\n  };\n  setNotificationRef: (ref: NotificationRef | null) => void;\n}\n\nexport function useNeuralNetwork(): NeuralNetworkHook {\n  // Türkçe sözlük instance'ı\n  const turkishDictionary = useRef(new TurkishDictionary()).current;\n  const notificationRef = useRef<NotificationRef | null>(null);\n\n  // Ağ durumu\n  const [networkState, setNetworkState] = useState<NetworkState>({\n    userNetworks: Array(INITIAL_NETWORK_LAYERS).fill(null).map(() => \n      createEmptyGrid(INITIAL_GRID_ROWS, INITIAL_GRID_COLS)\n    ),\n    systemNetworks: Array(INITIAL_NETWORK_LAYERS).fill(null).map(() => \n      createEmptyGrid(INITIAL_GRID_ROWS, INITIAL_GRID_COLS)\n    ),\n    relations: [],\n    bidirectionalRelations: [],\n    trainingHistory: [],\n    activatedNodes: [],\n    stats: {\n      nodeCount: 0,\n      relationCount: 0,\n      trainingCount: 0,\n      lastTraining: null\n    }\n  });\n\n  // Düğüm pozisyonları\n  const [nodePositions] = useState(new Map<string, { \n    layer: number; \n    row: number; \n    col: number;\n    type: 'user' | 'system';\n  }>());\n\n  // Ağları ve ilişkileri yerel depolamadan yükle\n  useEffect(() => {\n    loadNetworkState();\n  }, []);\n\n  // Yerel depolamaya kaydet (durum değiştiğinde)\n  useEffect(() => {\n    saveNetworkState();\n  }, [networkState]);\n\n  // Güvenli ağ durumu kaydetme\n  const saveNetworkState = () => {\n    try {\n      // Eğitim verilerini koru - sınırsız\n      const trainingHistory = networkState.trainingHistory;\n      const relations = networkState.relations;\n      const stats = networkState.stats;\n\n      // JSON boyutunu kontrol et\n      const trainingDataSize = JSON.stringify(trainingHistory).length;\n      const relationsDataSize = JSON.stringify(relations).length;\n\n      console.log(`💾 Kaydediliyor: ${trainingHistory.length} eğitim, ${relations.length} ilişki`);\n      console.log(`📊 Veri boyutu: Eğitim ${Math.round(trainingDataSize/1024)}KB, İlişki ${Math.round(relationsDataSize/1024)}KB`);\n\n      // Chunk-based kaydetme (5MB sınırı için)\n      const maxChunkSize = 4 * 1024 * 1024; // 4MB chunks\n\n      // Eğitim verilerini chunk'lara böl\n      if (trainingDataSize > maxChunkSize) {\n        const chunkSize = Math.floor(trainingHistory.length / Math.ceil(trainingDataSize / maxChunkSize));\n        for (let i = 0; i < trainingHistory.length; i += chunkSize) {\n          const chunk = trainingHistory.slice(i, i + chunkSize);\n          const chunkIndex = Math.floor(i / chunkSize);\n          localStorage.setItem(`neural_training_chunk_${chunkIndex}`, JSON.stringify(chunk));\n        }\n        localStorage.setItem('neural_training_chunks', Math.ceil(trainingHistory.length / chunkSize).toString());\n      } else {\n        localStorage.setItem('neural_training_history', JSON.stringify(trainingHistory));\n        localStorage.removeItem('neural_training_chunks');\n      }\n\n      // İlişkileri kaydet\n      localStorage.setItem('neural_relations', JSON.stringify(relations));\n      localStorage.setItem('neural_bidirectional_relations', JSON.stringify(networkState.bidirectionalRelations));\n\n      // İstatistikleri kaydet\n      localStorage.setItem('neural_stats', JSON.stringify(stats));\n\n      // Ağ verilerini minimal tut\n      localStorage.setItem('neural_user_networks', JSON.stringify(networkState.userNetworks.slice(0, 5)));\n      localStorage.setItem('neural_system_networks', JSON.stringify(networkState.systemNetworks.slice(0, 5)));\n\n      console.log(`✅ Tüm veriler kaydedildi: ${trainingHistory.length} eğitim verisi korundu`);\n\n    } catch (error) {\n      console.error('❌ Kaydetme hatası:', error);\n\n      // Hata durumunda en kritik verileri kaydet\n      try {\n        localStorage.setItem('neural_stats', JSON.stringify(networkState.stats));\n        localStorage.setItem('neural_training_history', JSON.stringify(networkState.trainingHistory.slice(-100))); // Son 100\n        console.log('⚠️ Sadece kritik veriler kaydedildi');\n      } catch (criticalError) {\n        console.error('💥 Kritik veri kaydetme hatası:', criticalError);\n      }\n    }\n  };\n\n  // Ağ durumunu yükle - chunk desteği ile\n  const loadNetworkState = () => {\n    try {\n      // Kullanıcı ağları\n      const userNetworksStr = localStorage.getItem('neural_user_networks');\n      const userNetworks = userNetworksStr \n        ? JSON.parse(userNetworksStr) \n        : Array(INITIAL_NETWORK_LAYERS).fill(null).map(() => \n            createEmptyGrid(INITIAL_GRID_ROWS, INITIAL_GRID_COLS)\n          );\n\n      // Sistem ağları\n      const systemNetworksStr = localStorage.getItem('neural_system_networks');\n      const systemNetworks = systemNetworksStr \n        ? JSON.parse(systemNetworksStr) \n        : Array(INITIAL_NETWORK_LAYERS).fill(null).map(() => \n            createEmptyGrid(INITIAL_GRID_ROWS, INITIAL_GRID_COLS)\n          );\n\n      // İlişkiler\n      const relationsStr = localStorage.getItem('neural_relations');\n      const relations = relationsStr ? JSON.parse(relationsStr) : [];\n\n      // Çift yönlü ilişkiler\n      const bidirectionalRelationsStr = localStorage.getItem('neural_bidirectional_relations');\n      const bidirectionalRelations = bidirectionalRelationsStr ? JSON.parse(bidirectionalRelationsStr) : [];\n\n      // Eğitim geçmişini yükle - chunk desteği ile\n      let trainingHistory = [];\n\n      // Chunk'ların sayısını kontrol et\n      const chunksCountStr = localStorage.getItem('neural_training_chunks');\n\n      if (chunksCountStr) {\n        // Chunk'lardan yükle\n        const chunksCount = parseInt(chunksCountStr);\n        console.log(`📦 ${chunksCount} chunk'tan eğitim verileri yükleniyor...`);\n\n        for (let i = 0; i < chunksCount; i++) {\n          const chunkStr = localStorage.getItem(`neural_training_chunk_${i}`);\n          if (chunkStr) {\n            const chunk = JSON.parse(chunkStr);\n            trainingHistory = trainingHistory.concat(chunk);\n          }\n        }\n\n        console.log(`✅ Chunk'lardan ${trainingHistory.length} eğitim verisi yüklendi`);\n      } else {\n        // Normal tek dosyadan yükle\n        const trainingHistoryStr = localStorage.getItem('neural_training_history');\n        trainingHistory = trainingHistoryStr ? JSON.parse(trainingHistoryStr) : [];\n\n        if (trainingHistory.length > 0) {\n          console.log(`✅ ${trainingHistory.length} eğitim verisi yüklendi`);\n        }\n      }\n\n      // İstatistikler\n      const statsStr = localStorage.getItem('neural_stats');\n      const stats = statsStr ? JSON.parse(statsStr) : {\n        nodeCount: 0,\n        relationCount: relations.length,\n        trainingCount: trainingHistory.length,\n        lastTraining: null\n      };\n\n      // İstatistikleri güncelle\n      stats.relationCount = relations.length;\n      stats.trainingCount = trainingHistory.length;\n\n      // Düğüm pozisyonlarını güncelle\n      updateNodePositions(userNetworks, systemNetworks);\n\n      // Ağ durumunu güncelle\n      setNetworkState({\n        userNetworks,\n        systemNetworks,\n        relations,\n        bidirectionalRelations,\n        trainingHistory,\n        activatedNodes: [],\n        stats\n      });\n\n      console.log(`🎉 Ağ durumu yüklendi: ${trainingHistory.length} eğitim, ${relations.length} ilişki`);\n\n    } catch (error) {\n      console.error('❌ Ağ durumu yüklenemedi:', error);\n\n      // Hata durumunda boş durumla başla\n      setNetworkState({\n        userNetworks: Array(INITIAL_NETWORK_LAYERS).fill(null).map(() => \n          createEmptyGrid(INITIAL_GRID_ROWS, INITIAL_GRID_COLS)\n        ),\n        systemNetworks: Array(INITIAL_NETWORK_LAYERS).fill(null).map(() => \n          createEmptyGrid(INITIAL_GRID_ROWS, INITIAL_GRID_COLS)\n        ),\n        relations: [],\n        bidirectionalRelations: [],\n        trainingHistory: [],\n        activatedNodes: [],\n        stats: {\n          nodeCount: 0,\n          relationCount: 0,\n          trainingCount: 0,\n          lastTraining: null\n        }\n      });\n    }\n  };\n\n  // Düğüm pozisyonlarını güncelle\n  const updateNodePositions = (\n    userNetworks: (NetworkNode | null)[][][], \n    systemNetworks: (NetworkNode | null)[][][]\n  ) => {\n    // Mevcut pozisyonları temizle\n    nodePositions.clear();\n\n    // Kullanıcı ağındaki düğümlerin pozisyonlarını kaydet\n    for (let layer = 0; layer < userNetworks.length; layer++) {\n      for (let row = 0; row < userNetworks[layer].length; row++) {\n        for (let col = 0; col < userNetworks[layer][0].length; col++) {\n          const node = userNetworks[layer][row][col];\n          if (node) {\n            nodePositions.set(node.id, { layer, row, col, type: 'user' });\n          }\n        }\n      }\n    }\n\n    // Sistem ağındaki düğümlerin pozisyonlarını kaydet\n    for (let layer = 0; layer < systemNetworks.length; layer++) {\n      for (let row = 0; row < systemNetworks[layer].length; row++) {\n        for (let col = 0; col < systemNetworks[layer][0].length; col++) {\n          const node = systemNetworks[layer][row][col];\n          if (node) {\n            nodePositions.set(node.id, { layer, row, col, type: 'system' });\n          }\n        }\n      }\n    }\n  };\n\n  // Ağ eğitimi - her veriyi garantili kaydet\n  const trainNetwork = useCallback(async (userInput: string, systemOutput: string) => {\n    const cleanUserInput = userInput.trim();\n    const cleanSystemOutput = systemOutput.trim();\n\n    if (!cleanUserInput || !cleanSystemOutput) {\n      console.log(`❌ Boş girdi atlandı: \"${userInput}\" => \"${systemOutput}\"`);\n      return;\n    }\n\n    console.log(`🔄 EĞİTİM BAŞLIYOR: \"${cleanUserInput}\" => \"${cleanSystemOutput}\"`);\n\n    try {\n      // Eğitim çiftini oluştur\n      const trainingPair: TrainingPair = {\n        id: uuidv4(),\n        input: cleanUserInput,\n        output: cleanSystemOutput,\n        timestamp: Date.now(),\n        usageCount: 0,\n        category: 'general'\n      };\n\n      // Durum güncellemesini direkt yap\n      setNetworkState(prevState => {\n        // YENİ: Aynı soruyu kontrol et ve güncelle\n        const existingTrainingIndex = prevState.trainingHistory.findIndex(item => \n          item.input.toLowerCase().trim() === cleanUserInput.toLowerCase().trim()\n        );\n\n        let newTrainingHistory;\n        if (existingTrainingIndex >= 0) {\n          // Mevcut soruyu güncelle\n          newTrainingHistory = [...prevState.trainingHistory];\n          newTrainingHistory[existingTrainingIndex] = trainingPair;\n          console.log(`🔄 Mevcut soru güncellendi: \"${cleanUserInput}\"`);\n        } else {\n          // Yeni soru ekle\n          newTrainingHistory = [...prevState.trainingHistory, trainingPair];\n          console.log(`➕ Yeni soru eklendi: \"${cleanUserInput}\"`);\n        }\n\n        // Kelimeleri ayır\n        const userWords = cleanUserInput.split(/\\s+/).filter(word => word.length > 0);\n        const systemWords = cleanSystemOutput.split(/\\s+/).filter(word => word.length > 0);\n\n        // İlişkileri oluştur/güncelle\n        const newRelations = [...prevState.relations];\n\n        for (const userWord of userWords) {\n          for (const systemWord of systemWords) {\n            const existingRelation = newRelations.find(rel => \n              rel.userWord.toLowerCase() === userWord.toLowerCase() && \n              rel.systemWord.toLowerCase() === systemWord.toLowerCase()\n            );\n\n            if (existingRelation) {\n              // Mevcut ilişkiyi güçlendir\n              existingRelation.strength = Math.min(100, existingRelation.strength + 5);\n              existingRelation.frequency += 1;\n              existingRelation.lastUsed = Date.now();\n            } else {\n              // Yeni ilişki oluştur\n              const newRelation = createRelation(\n                userWord,\n                systemWord,\n                60, // Başlangıç dependency\n                60, // Başlangıç association\n                1,  // Frequency\n                userWords.indexOf(userWord), // Order\n                0,  // Feedback\n                false, // Bidirectional\n                [], // Context\n                'semantic' // Type\n              );\n              newRelations.push(newRelation);\n            }\n          }\n        }\n\n        // Yeni durum\n        const newState = {\n          userNetworks: prevState.userNetworks,\n          systemNetworks: prevState.systemNetworks,\n          relations: newRelations,\n          bidirectionalRelations: prevState.bidirectionalRelations,\n          trainingHistory: newTrainingHistory,\n          activatedNodes: [],\n          stats: {\n            nodeCount: prevState.stats.nodeCount,\n            relationCount: newRelations.length,\n            trainingCount: newTrainingHistory.length,\n            lastTraining: Date.now()\n          }\n        };\n\n        console.log(`✅ EĞİTİM KAYDEDILDI: Toplam ${newTrainingHistory.length} veri, ${newRelations.length} ilişki`);\n\n        return newState;\n      });\n\n    } catch (error) {\n      console.error('❌ Eğitim hatası:', error);\n    }\n  }, []);\n\n  // Yanıt önbelleği\n  const responseCache = new Map<string, {response: string; confidence: number; timestamp: number}>();\n  const CACHE_DURATION = 1000 * 60 * 5; // 5 dakika\n\n  // Sözlük sorgusu kontrolü\n   const checkIfDictionaryQuery = (input: string): boolean => {\n    const lowerInput = input.toLowerCase().trim();\n\n    // Sözlük sorgusu kalıpları\n    const dictionaryPatterns = [\n      /(.+?)\\s*nedir\\s*\\??$/,           // \"X nedir?\"\n      /(.+?)\\s*ne\\s*demek\\s*\\??$/,     // \"X ne demek?\"\n      /(.+?)\\s*ne\\s*anlama\\s*geliyor\\s*\\??$/, // \"X ne anlama geliyor?\"\n      /(.+?)\\s*ne\\s*anlama\\s*gelir\\s*\\??$/, // \"X ne anlama gelir?\"\n      /(.+?)\\s*ne\\s*\\??$/,             // \"X ne?\"\n      /(.+?)\\s*anlamı\\s*ne\\s*\\??$/,    // \"X anlamı ne?\"\n      /(.+?)\\s*anlamı\\s*nedir\\s*\\??$/, // \"X anlamı nedir?\"\n      /(.+?)\\s*manası\\s*ne\\s*\\??$/,    // \"X manası ne?\"\n      /(.+?)\\s*manası\\s*nedir\\s*\\??$/, // \"X manası nedir?\"\n      /ne\\s*demek\\s*(.+?)\\s*\\??$/,     // \"ne demek X?\"\n      /anlamı\\s*nedir\\s*(.+?)\\s*\\??$/, // \"anlamı nedir X?\"\n    ];\n\n    // Herhangi bir sözlük kalıbı eşleşirse true döndür\n    return dictionaryPatterns.some(pattern => pattern.test(lowerInput));\n  };\n\n  // Kelime anlamı sorusundan hedef kelimeyi çıkar\n  const extractTargetWord = (input: string): string | null => {\n    const lowerInput = input.toLowerCase().trim();\n\n    const patterns = [\n      /^(.+?)\\s*nedir\\s*\\??$/,           // \"X nedir?\"\n      /^(.+?)\\s*ne\\s*demek\\s*\\??$/,     // \"X ne demek?\"\n      /^(.+?)\\s*ne\\s*anlama\\s*geliyor\\s*\\??$/, // \"X ne anlama geliyor?\"\n      /^(.+?)\\s*ne\\s*anlama\\s*gelir\\s*\\??$/, // \"X ne anlama gelir?\"\n      /^(.+?)\\s*ne\\s*\\??$/,             // \"X ne?\"\n      /^(.+?)\\s*anlamı\\s*ne\\s*\\??$/,    // \"X anlamı ne?\"\n      /^(.+?)\\s*anlamı\\s*nedir\\s*\\??$/, // \"X anlamı nedir?\"\n      /^(.+?)\\s*manası\\s*ne\\s*\\??$/,    // \"X manası ne?\"\n      /^(.+?)\\s*manası\\s*nedir\\s*\\??$/, // \"X manası nedir?\"\n      /^ne\\s*demek\\s*(.+?)\\s*\\??$/,     // \"ne demek X?\"\n      /^anlamı\\s*nedir\\s*(.+?)\\s*\\??$/, // \"anlamı nedir X?\"\n    ];\n\n    for (const pattern of patterns) {\n      const match = lowerInput.match(pattern);\n      if (match) {\n        return match[1].trim();\n      }\n    }\n\n    return null;\n  };\n\n  const processUserInput = useCallback(async (userInput: string) => {\n    try {\n      console.log(`🔍 Kullanıcı girdisi işleniyor: \"${userInput}\"`);\n\n      // En güncel eğitim verilerini al - hem state hem localStorage'dan\n      let currentTrainingData = networkState.trainingHistory;\n\n      // YENİ: localStorage'dan da kontrol et (daha güncel olabilir)\n      try {\n        const localStorageData = localStorage.getItem('neural_training_history');\n        if (localStorageData) {\n          const parsedLocalData = JSON.parse(localStorageData);\n          if (Array.isArray(parsedLocalData) && parsedLocalData.length > currentTrainingData.length) {\n            console.log(`🔄 localStorage'da daha güncel veri bulundu: ${parsedLocalData.length} > ${currentTrainingData.length}`);\n\n            // localStorage formatını TrainingPair formatına dönüştür\n            currentTrainingData = parsedLocalData.map(item => ({\n              id: item.id || uuidv4(),\n              input: item.input || item.userInput,\n              output: item.output || item.systemOutput,\n              timestamp: item.timestamp || Date.now(),\n              usageCount: item.usageCount || 0,\n              category: item.category || 'general'\n            }));\n          }\n        }\n      } catch (localStorageError) {\n        console.error('localStorage okuma hatası:', localStorageError);\n      }\n\n      console.log(`📚 Mevcut eğitim verisi sayısı: ${currentTrainingData.length}`);\n\n      if (currentTrainingData.length === 0) {\n        console.log('❌ Hiç eğitim verisi yok, temel cevap sistemi devreye giriyor');\n        \n        // Basic responses for common greetings and questions\n        const basicResponses = getBasicResponse(userInput);\n        if (basicResponses) {\n          return basicResponses;\n        }\n        \n        // For dictionary queries, try to provide basic response\n        const cleanInput = userInput.toLowerCase().trim();\n        const isDictionaryQuery = checkIfDictionaryQuery(cleanInput);\n        \n        if (isDictionaryQuery) {\n          const targetWord = extractTargetWord(cleanInput);\n          if (targetWord) {\n            const dictionaryEntry = turkishDictionary.getWord(targetWord);\n            if (dictionaryEntry) {\n              return {\n                response: `${targetWord.charAt(0).toUpperCase() + targetWord.slice(1)}: ${dictionaryEntry.meaning[0]}`,\n                confidence: 0.8\n              };\n            }\n          }\n        }\n        \n        // Only use modal trigger as last resort\n        return {\n          response: 'MODAL_TRIGGER_UNKNOWN',\n          confidence: 0.1\n        };\n      }\n\n      const cleanInput = userInput.toLowerCase().trim();\n      const isDictionaryQuery = checkIfDictionaryQuery(cleanInput);\n      const phraseAnalysis = turkishDictionary.analyzePhrase(userInput);\n      let response = '';\n      let confidence = 0;\n\n      if (isDictionaryQuery) {\n        // Kelime anlamı sorusu - Sözlük öncelikli sistem\n        const targetWord = extractTargetWord(cleanInput);\n        console.log('🔍 Kelime anlamı sorusu tespit edildi. Hedef kelime:', targetWord);\n\n        if (targetWord) {\n          // 1. ÖNCE SÖZLÜKTE ARA\n          const dictionaryEntry = turkishDictionary.getWord(targetWord);\n          if (dictionaryEntry) {\n            console.log('📖 Sözlükte bulundu (öncelikli):', dictionaryEntry);\n            response = `${targetWord.charAt(0).toUpperCase() + targetWord.slice(1)}: ${dictionaryEntry.meaning[0]}`;\n            if (dictionaryEntry.type) {\n              response += ` (${dictionaryEntry.type})`;\n            }\n            if (dictionaryEntry.examples && dictionaryEntry.examples.length > 0) {\n              response += `\\n\\nÖrnek kullanım: ${dictionaryEntry.examples[0]}`;\n            }\n            confidence = 0.95;\n          } else {\n            // 2. SÖZLÜKTE YOKSA EĞİTİM VERİSİNDE ARA\n            console.log('📚 Sözlükte bulunamadı, eğitim verilerinde aranıyor:', targetWord);\n            const trainingMatch = currentTrainingData.find(item => {\n              const inputLower = item.input.toLowerCase();\n              const outputLower = item.output.toLowerCase();\n              return inputLower.includes(targetWord) || outputLower.includes(targetWord);\n            });\n\n            if (trainingMatch) {\n              console.log('🎯 Eğitim verisinde bulundu:', trainingMatch);\n              response = trainingMatch.output;\n              confidence = 0.85;\n            } else {\n              // 3. HİÇBİR YERDE YOKSA - Modal açılması gerekir\n              console.log('❌ Ne sözlükte ne de eğitim verilerinde bulunamadı');\n              return {\n                response: 'MODAL_TRIGGER_UNKNOWN',\n                confidence: 0.1,\n                usedTraining: null,\n                method: 'fallback',\n                notification: '❌ Eğitim gerekli'\n              };\n            }\n          }\n        } else {\n          // Hedef kelime çıkarılamazsa genel sözlük analizi\n          if (phraseAnalysis.semanticComponents?.expectedResponse && phraseAnalysis.confidence > 0.5) {\n            console.log('📖 Genel sözlük analizi:', phraseAnalysis.semanticComponents.expectedResponse);\n            response = phraseAnalysis.semanticComponents.expectedResponse;\n            confidence = phraseAnalysis.confidence;\n          }\n        }\n      } else {\n        // Normal sorular: önce eğitim verilerine bak\n        console.log('🔍 Eğitim verilerinde arama yapılıyor:', cleanInput);\n        console.log('📊 Mevcut eğitim verisi sayısı:', currentTrainingData.length);\n\n        // Direkt eşleşme ara\n        let directMatch = currentTrainingData.find(item => \n          item.input.toLowerCase().trim() === cleanInput ||\n          item.input.toLowerCase().includes(cleanInput) ||\n          cleanInput.includes(item.input.toLowerCase())\n        );\n\n        if (directMatch) {\n          console.log('✅ Direkt eşleşme bulundu:', directMatch);\n          response = directMatch.output;\n          confidence = 0.95;\n        } else {\n          // Benzerlik ile ara (basit string matching)\n          let bestMatch = null;\n          let bestScore = 0;\n\n          for (const item of currentTrainingData) {\n            const inputLower = item.input.toLowerCase();\n            const similarity = calculateSimilarity(cleanInput, inputLower);\n\n            if (similarity > bestScore && similarity > 0.3) {\n              bestScore = similarity;\n              bestMatch = item;\n            }\n          }\n\n          if (bestMatch && bestScore > 0.5) {\n            console.log('✅ Benzerlik eşleşmesi bulundu:', bestMatch, 'Score:', bestScore);\n            response = bestMatch.output;\n            confidence = bestScore;\n          } else {\n            // Sözlük analizi\n            if (phraseAnalysis.semanticComponents?.expectedResponse && phraseAnalysis.confidence > 0.5) {\n              console.log('📖 Sözlük cevabı:', phraseAnalysis.semanticComponents.expectedResponse);\n              response = phraseAnalysis.semanticComponents.expectedResponse;\n              confidence = phraseAnalysis.confidence;\n            }\n          }\n        }\n      }\n\n      // Sözlük analizi ile yanıt arayışı devam et\n      if (phraseAnalysis.semanticComponents?.expectedResponse && phraseAnalysis.confidence > 0.4) {\n        console.log('📖 Sözlük analizi cevabı:', phraseAnalysis.semanticComponents.expectedResponse);\n        response = phraseAnalysis.semanticComponents.expectedResponse;\n        confidence = phraseAnalysis.confidence;\n      }\n\n      // Basit greeting/farewell cevapları\n      if (!response || response.trim() === '') {\n        if (cleanInput.includes('merhaba') || cleanInput.includes('selam')) {\n          response = 'Merhaba! Size nasıl yardımcı olabilirim?';\n          confidence = 0.8;\n        } else if (cleanInput.includes('teşekkür')) {\n          response = 'Rica ederim!';\n          confidence = 0.8;\n        } else if (cleanInput.includes('güle güle') || cleanInput.includes('hoşça kal')) {\n          response = 'Güle güle! Sonra görüşürüz!';\n          confidence = 0.8;\n        }\n      }\n\n      // Final kontrol - eğer herhangi bir cevap varsa döndür\n      if (response && response.trim() !== '') {\n        console.log('✅ Neural network final yanıt:', response.substring(0, 50) + '...', 'Güven:', confidence);\n        return {\n          response,\n          confidence,\n          usedTraining: null,\n          method: confidence > 0.7 ? 'trained' : 'fallback',\n          notification: confidence > 0.7 ? undefined : 'ℹ️ Daha iyi cevap için beni eğitebilirsin!'\n        };\n      }\n\n      // Sadece hiçbir cevap bulunamadığında modal tetikle\n      console.log('❌ Neural network: Hiçbir cevap bulunamadı');\n      return {\n        response: 'MODAL_TRIGGER_UNKNOWN',\n        confidence: 0.1,\n        usedTraining: null,\n        notification: '❌ Eğitim gerekli'\n      };\n\n    } catch (error) {\n      console.error('❌ İşleme hatası:', error);\n      return {\n        response: 'MODAL_TRIGGER_UNKNOWN',\n        confidence: 0.1,\n        usedTraining: null,\n        method: 'error',\n        notification: 'Bir hata oluştu, lütfen tekrar deneyin.'\n      };\n    }\n  }, [networkState.trainingHistory, turkishDictionary]);\n\n  // Basic response system for when no training data is available\n  const getBasicResponse = (input: string) => {\n    const cleanInput = input.toLowerCase().trim();\n    \n    // Common greetings\n    if (cleanInput.match(/^(merhaba|selam|hey|hi|hello|günaydın|iyi akşamlar|iyi günler)$/)) {\n      const responses = [\n        'Merhaba! Size nasıl yardımcı olabilirim?',\n        'Selam! Bugün ne öğrenmek istiyorsunuz?',\n        'Hoş geldiniz! Benimle konuşarak beni eğitebilirsiniz.',\n      ];\n      return {\n        response: responses[Math.floor(Math.random() * responses.length)],\n        confidence: 0.9\n      };\n    }\n    \n    // How are you questions\n    if (cleanInput.match(/(nasılsın|nasıl gidiyor|ne haber|keyifler nasıl)/)) {\n      return {\n        response: 'İyiyim, teşekkür ederim! Siz beni eğiterek daha da iyi hale getirebilirsiniz. Ne öğrenmek istiyorsunuz?',\n        confidence: 0.8\n      };\n    }\n    \n    // Thank you\n    if (cleanInput.match(/(teşekkür|sağol|tşk|thanks|merci)/)) {\n      return {\n        response: 'Rica ederim! Başka bir konuda yardımcı olabilir miyim?',\n        confidence: 0.9\n      };\n    }\n    \n    // Goodbye\n    if (cleanInput.match(/(güle güle|hoşça kal|görüşürüz|bye|hoşçakal)/)) {\n      return {\n        response: 'Hoşça kalın! Tekrar görüşmek üzere. Beni eğittiğiniz için teşekkürler!',\n        confidence: 0.9\n      };\n    }\n    \n    // What can you do questions\n    if (cleanInput.match(/(ne yapabilirsin|neler biliyorsun|yeteneklerin|nasıl çalışıyorsun)/)) {\n      return {\n        response: 'Ben öğrenen bir yapay zeka asistanıyım. Bana sorular sorarak ve doğru cevapları öğreterek beni geliştirebilirsiniz. Türkçe kelime anlamları, genel bilgiler ve daha fazlası hakkında konuşabiliriz!',\n        confidence: 0.8\n      };\n    }\n    \n    return null;\n  };\n\n  // Benzerlik hesaplama yardımcı fonksiyonu\n  const calculateSimilarity = (str1: string, str2: string): number => {\n    const words1 = str1.toLowerCase().split(/\\s+/);\n    const words2 = str2.toLowerCase().split(/\\s+/);\n\n    let commonWords = 0;\n    for (const word1 of words1) {\n      for (const word2 of words2) {\n        if (word1 === word2 || word1.includes(word2) || word2.includes(word1)) {\n          commonWords++;\n          break;\n        }\n      }\n    }\n\n    return commonWords / Math.max(words1.length, words2.length);\n  };\n\n  // İki yönlü ilişkileri güncelleme yardımcı fonksiyonu\n  const updateBidirectionalRelations = useCallback((input: string, output: string, strength: number) => {\n    // İlişkileri güçlendir\n    setNetworkState(prev => {\n      // İlgili ilişkileri bul\n      const relationsToUpdate = prev.relations.filter(rel => \n        (rel.userWord === input && rel.systemWord === output) ||\n        (rel.userWord === output && rel.systemWord === input)\n      );\n\n      // İlişkileri güçlendir\n      const updatedRelations = prev.relations.map(rel => {\n        if ((rel.userWord === input && rel.systemWord === output) ||\n            (rel.userWord === output && rel.systemWord === input)) {\n          return reinforceRelation(rel, strength);\n        }\n        return rel;\n      });\n\n      // İki yönlü ilişkileri güçlendir\n      const updatedBiRelations = prev.bidirectionalRelations.map(rel => {\n        if ((rel.userWord === input && rel.systemWord === output) ||\n            (rel.userWord === output && rel.systemWord === input)) {\n          return reinforceRelation(rel, strength);\n        }\n        return rel;\n      });\n\n      return {\n        ...prev,\n        relations: updatedRelations,\n        bidirectionalRelations: updatedBiRelations\n      };\n    });\n  }, []);\n\n  // İlişkileri güncelleme yardımcı fonksiyonu\n  const updateRelations = useCallback((input: string, output: string, strength: number) => {\n    updateBidirectionalRelations(input, output, strength);\n  }, [updateBidirectionalRelations]);\n\n  // Ağı yenile\n  const refreshNetwork = useCallback(() => {\n    const { relations, bidirectionalRelations } = networkState;\n\n    // İlişkileri unutma mekanizması ile güncelle\n    const weakenedRelations = weakenRelations([...relations]);\n    const weakenedBiRelations = weakenRelations([...bidirectionalRelations]);\n\n    // Ağ durumunu güncelle\n    setNetworkState(prev => ({\n      ...prev,\n      relations: weakenedRelations,\n      bidirectionalRelations: weakenedBiRelations,\n      activatedNodes: []\n    }));\n  }, [networkState]);\n\n  // Ağ istatistiklerini al\n  const getNetworkStats = useCallback(() => {\n    return networkState.stats;\n  }, [networkState.stats]);\n\n  // Toplu eğitim - tüm verileri güvenli şekilde işle\n  const batchTrainNetworkItems = useCallback(async (\n    items: Array<{ input: string, output: string }>, \n    onProgress?: (progress: number, processed: number, total: number) => void\n  ) => {\n    if (!items || items.length === 0) {\n      console.log('❌ Boş veri listesi');\n      return;\n    }\n\n    console.log(`🚀 Toplu eğitim başlatılıyor: ${items.length} öğe`);\n\n    // Verileri doğrula ve temizle\n    const validItems = items.filter(item => {\n      if (!item) return false;\n      if (typeof item.input !== 'string' || typeof item.output !== 'string') return false;\n      if (item.input.trim().length === 0 || item.output.trim().length === 0) return false;\n      return true;\n    }).map(item => ({\n      input: item.input.trim(),\n      output: item.output.trim()\n    }));\n\n    console.log(`✅ Geçerli öğe sayısı: ${validItems.length}/${items.length}`);\n\n    if (validItems.length === 0) {\n      console.log('❌ Geçerli öğe bulunamadı');\n      return;\n    }\n\n    let processedCount = 0;\n    let successCount = 0;\n\n    // Başlangıç progress\n    if (onProgress) {\n      onProgress(0, 0, validItems.length);\n    }\n\n    // Batch boyutu - büyük veriler için\n    const batchSize = 10;\n\n    // Verilerí batch'ler halinde işle\n    for (let batchStart = 0; batchStart < validItems.length; batchStart += batchSize) {\n      const batchEnd = Math.min(batchStart + batchSize, validItems.length);\n      const batch = validItems.slice(batchStart, batchEnd);\n\n      console.log(`📦 Batch ${Math.floor(batchStart/batchSize) + 1} işleniyor: ${batch.length} öğe`);\n\n      // Batch içindeki öğeleri işle\n      for (let i = 0; i < batch.length; i++) {\n        const item = batch[i];\n\n        try {\n          // Eğitimi yap\n          await trainNetwork(item.input, item.output);\n          successCount++;\n\n          console.log(`✅ ${processedCount + 1}/${validItems.length}: \"${item.input}\" => \"${item.output}\"`);\n        } catch (error) {\n          console.error(`❌ Öğe ${processedCount + 1} işleme hatası:`, error);\n        }\n\n        processedCount++;\n\n        // Progress güncelle (her öğede)\n        const progress = Math.round((processedCount / validItems.length) * 100);\n        if (onProgress) {\n          onProgress(progress, processedCount, validItems.length);\n        }\n      }\n\n      // Batch sonrası kısa bekleme\n      if (batchEnd < validItems.length) {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      }\n    }\n\n    console.log(`🎉 Toplu eğitim tamamlandı: ${successCount}/${processedCount} başarılı`);\n    console.log(`📊 Toplam eğitim verisi: ${networkState.trainingHistory.length + successCount}`);\n\n  }, [trainNetwork, networkState.trainingHistory.length]);\n\n  // Tek chunk'ı işleme fonksiyonu - tüm verileri kaydetmek için optimize edildi\n  const processChunk = async (chunk: Array<{ input: string, output: string }>, currentState: NetworkState) => {\n    console.log(`📊 Chunk işleniyor: ${chunk.length} öğe`);\n\n    // Her öğeyi normal eğitim süreciyle işle\n    for (let i = 0; i < chunk.length; i++) {\n      const item = chunk[i];\n\n      try {\n        if (item.input && item.output && \n            item.input.trim().length > 0 && \n            item.output.trim().length > 0) {\n\n          // Normal eğitim fonksiyonunu kullan - tüm işlemleri yapar\n          await trainNetwork(item.input.trim(), item.output.trim());\n\n          console.log(`✅ İşlendi: \"${item.input}\" => \"${item.output}\"`);\n        } else {\n          console.log(`❌ Geçersiz öğe atlandı: ${JSON.stringify(item)}`);\n        }\n      } catch (error) {\n        console.error(`❌ Öğe işleme hatası:`, error, item);\n      }\n    }\n\n    console.log(`✅ Chunk tamamlandı: ${chunk.length} öğe işlendi`);\n  };\n\n  // Toplu eğitim\n  const processBatchTraining = useCallback(async (pairs: TrainingPair[]): Promise<void> => {\n    if (!networkState) return;\n\n    // Başlangıç istatistikleri\n    const initialUserNodes = networkState.userNetworks.flat(2).filter(node => node !== null).length;\n    const initialSystemNodes = networkState.systemNetworks.flat(2).filter(node => node !== null).length;\n    const initialRelations = networkState.relations.length;\n    const initialTotalNodes = initialUserNodes + initialSystemNodes;\n\n    // Eğitim başlatıldı\n    console.log(`Toplu eğitim başlatılıyor, ${pairs.length} öğe işlenecek...`);\n\n    // İlerleme takibi\n    let processedCount = 0;\n    let successCount = 0;\n\n    // Başlangıç bildirimi\n    if (notificationRef.current) {\n      notificationRef.current.show(\n        `🚀 Toplu eğitim başlatıldı: ${pairs.length} veri işlenecek...`,\n        'info'\n      );\n    }\n\n    // Tüm eğitim öğelerini işle\n    for (const pair of pairs) {\n      try {\n        // Her çifti işle\n        await trainNetwork(pair.input, pair.output);\n\n        // İlerleme güncelle\n        processedCount++;\n        successCount++;\n        const progress = Math.round((processedCount / pairs.length) * 100);\n        console.log(`İlerleme: %${progress} (${processedCount}/${pairs.length})`);\n\n        // Ara bildirim\n        if (processedCount % 10 === 0 && notificationRef.current) {\n          notificationRef.current.show(\n            `📊 ${processedCount}/${pairs.length} veri işlendi (${progress}%)`,\n            'info'\n          );\n        }\n\n        // Her 100 öğede bir UI güncelleme - performans optimizasyonu\n        if ((processedCount % 100) === 0) {\n          await new Promise(resolve => setTimeout(resolve, 1));\n        }\n      } catch (error) {\n        console.error(`Eğitim sırasında hata:`, error);\n        processedCount++;\n      }\n    }\n\n    // Son istatistikleri al\n    const finalUserNodes = networkState.userNetworks.flat(2).filter(node => node !== null).length;\n    const finalSystemNodes = networkState.systemNetworks.flat(2).filter(node => node !== null).length;\n    const finalRelations = networkState.relations.length;\n    const finalTotalNodes = finalUserNodes + finalSystemNodes;\n\n    const newNodesCount = finalTotalNodes - initialTotalNodes;\n    const newRelationsCount = finalRelations - initialRelations;\n\n    console.log(`Toplu eğitim tamamlandı, ${processedCount} öğe işlendi.`);\n    console.log(`Yeni düğüm sayısı: ${newNodesCount}, Yeni ilişki sayısı: ${newRelationsCount}`);\n\n    // Tamamlama bildirimi\n    if (notificationRef.current) {\n      notificationRef.current.show(\n        `✅ Toplu eğitim tamamlandı!\\n📊 ${successCount}/${pairs.length} başarılı\\n🧠 +${newNodesCount} düğüm\\n🔗 +${newRelationsCount} ilişki`,\n        'success'\n      );\n    }\n  }, [networkState, trainNetwork]);\n\n  return {\n    userNetworks: networkState.userNetworks,\n    systemNetworks: networkState.systemNetworks,\n    relations: networkState.relations,\n    bidirectionalRelations: networkState.bidirectionalRelations,\n    trainingHistory: networkState.trainingHistory,\n    trainHistory: networkState.trainingHistory, // Backward compatibility\n    networkState: networkState, // Export for App.tsx compatibility\n    activatedNodes: networkState.activatedNodes,\n    trainNetwork,\n    batchTrainNetworkItems, // Yeni toplu eğitim fonksiyonu\n    processUserInput,\n    refreshNetwork,\n    getNetworkStats,\n    setNotificationRef: (ref: NotificationRef | null) => {\n      notificationRef.current = ref;\n    }\n  };\n}","size_bytes":38795},"client/src/hooks/use-neural-network.tsx":{"content":"import { useState, useEffect, useCallback } from 'react';\nimport { v4 as uuidv4 } from 'uuid';\nimport { \n  NetworkNode, \n  Relation,\n  TrainingPair,\n  ActivationResult,\n  createEmptyGrid,\n  addWordToNetwork,\n  createRelation,\n  reinforceRelation,\n  weakenRelations,\n  propagateActivation,\n  generateResponse,\n  findReverseAnswer,\n  determineQuestionType,\n  INITIAL_GRID_ROWS,\n  INITIAL_GRID_COLS,\n  INITIAL_NETWORK_LAYERS,\n  MIN_RELATION_SCORE\n} from '@/lib/NeuralNetworkUtils';\n\ninterface NetworkState {\n  userNetworks: (NetworkNode | null)[][][];\n  systemNetworks: (NetworkNode | null)[][][];\n  relations: Relation[];\n  bidirectionalRelations: Relation[];\n  trainingHistory: TrainingPair[];\n  activatedNodes: {\n    layer: number;\n    row: number;\n    col: number;\n    type: 'user' | 'system';\n  }[];\n  stats: {\n    nodeCount: number;\n    relationCount: number;\n    trainingCount: number;\n    lastTraining: number | null;\n  };\n}\n\ninterface NeuralNetworkHook {\n  userNetworks: (NetworkNode | null)[][][];\n  systemNetworks: (NetworkNode | null)[][][];\n  relations: Relation[];\n  bidirectionalRelations: Relation[];\n  trainingHistory: TrainingPair[];\n  activatedNodes: {\n    layer: number;\n    row: number;\n    col: number;\n    type: 'user' | 'system';\n  }[];\n  trainNetwork: (userInput: string, systemOutput: string) => Promise<void>;\n  batchTrainNetworkItems: (items: Array<{ input: string, output: string }>) => Promise<void>;\n  processUserInput: (userInput: string) => Promise<{ response: string; confidence: number }>;\n  refreshNetwork: () => void;\n  getNetworkStats: () => { \n    nodeCount: number; \n    relationCount: number; \n    trainingCount: number;\n    lastTraining: number | null;\n  };\n}\n\nexport function useNeuralNetwork(): NeuralNetworkHook {\n  // Ağ durumu\n  const [networkState, setNetworkState] = useState<NetworkState>({\n    userNetworks: Array(INITIAL_NETWORK_LAYERS).fill(null).map(() => \n      createEmptyGrid(INITIAL_GRID_ROWS, INITIAL_GRID_COLS)\n    ),\n    systemNetworks: Array(INITIAL_NETWORK_LAYERS).fill(null).map(() => \n      createEmptyGrid(INITIAL_GRID_ROWS, INITIAL_GRID_COLS)\n    ),\n    relations: [],\n    bidirectionalRelations: [],\n    trainingHistory: [],\n    activatedNodes: [],\n    stats: {\n      nodeCount: 0,\n      relationCount: 0,\n      trainingCount: 0,\n      lastTraining: null\n    }\n  });\n  \n  // Düğüm pozisyonları\n  const [nodePositions] = useState(new Map<string, { \n    layer: number; \n    row: number; \n    col: number;\n    type: 'user' | 'system';\n  }>());\n  \n  // Ağları ve ilişkileri yerel depolamadan yükle\n  useEffect(() => {\n    loadNetworkState();\n  }, []);\n  \n  // Yerel depolamaya kaydet (durum değiştiğinde)\n  useEffect(() => {\n    saveNetworkState();\n  }, [networkState]);\n  \n  // Ağ durumunu kaydet\n  const saveNetworkState = () => {\n    try {\n      localStorage.setItem('neural_user_networks', JSON.stringify(networkState.userNetworks));\n      localStorage.setItem('neural_system_networks', JSON.stringify(networkState.systemNetworks));\n      localStorage.setItem('neural_relations', JSON.stringify(networkState.relations));\n      localStorage.setItem('neural_bidirectional_relations', JSON.stringify(networkState.bidirectionalRelations));\n      localStorage.setItem('neural_training_history', JSON.stringify(networkState.trainingHistory));\n      localStorage.setItem('neural_stats', JSON.stringify(networkState.stats));\n    } catch (error) {\n      console.error('Ağ durumu kaydedilemedi:', error);\n    }\n  };\n  \n  // Ağ durumunu yükle\n  const loadNetworkState = () => {\n    try {\n      // Kullanıcı ağları\n      const userNetworksStr = localStorage.getItem('neural_user_networks');\n      const userNetworks = userNetworksStr \n        ? JSON.parse(userNetworksStr) \n        : Array(INITIAL_NETWORK_LAYERS).fill(null).map(() => \n            createEmptyGrid(INITIAL_GRID_ROWS, INITIAL_GRID_COLS)\n          );\n      \n      // Sistem ağları\n      const systemNetworksStr = localStorage.getItem('neural_system_networks');\n      const systemNetworks = systemNetworksStr \n        ? JSON.parse(systemNetworksStr) \n        : Array(INITIAL_NETWORK_LAYERS).fill(null).map(() => \n            createEmptyGrid(INITIAL_GRID_ROWS, INITIAL_GRID_COLS)\n          );\n      \n      // İlişkiler\n      const relationsStr = localStorage.getItem('neural_relations');\n      const relations = relationsStr ? JSON.parse(relationsStr) : [];\n      \n      // Çift yönlü ilişkiler\n      const bidirectionalRelationsStr = localStorage.getItem('neural_bidirectional_relations');\n      const bidirectionalRelations = bidirectionalRelationsStr ? JSON.parse(bidirectionalRelationsStr) : [];\n      \n      // Eğitim geçmişi\n      const trainingHistoryStr = localStorage.getItem('neural_training_history');\n      const trainingHistory = trainingHistoryStr ? JSON.parse(trainingHistoryStr) : [];\n      \n      // İstatistikler\n      const statsStr = localStorage.getItem('neural_stats');\n      const stats = statsStr ? JSON.parse(statsStr) : {\n        nodeCount: 0,\n        relationCount: 0,\n        trainingCount: 0,\n        lastTraining: null\n      };\n      \n      // Düğüm pozisyonlarını güncelle\n      updateNodePositions(userNetworks, systemNetworks);\n      \n      // Ağ durumunu güncelle\n      setNetworkState({\n        userNetworks,\n        systemNetworks,\n        relations,\n        bidirectionalRelations,\n        trainingHistory,\n        activatedNodes: [],\n        stats\n      });\n    } catch (error) {\n      console.error('Ağ durumu yüklenemedi:', error);\n    }\n  };\n  \n  // Düğüm pozisyonlarını güncelle\n  const updateNodePositions = (\n    userNetworks: (NetworkNode | null)[][][], \n    systemNetworks: (NetworkNode | null)[][][]\n  ) => {\n    // Mevcut pozisyonları temizle\n    nodePositions.clear();\n    \n    // Kullanıcı ağındaki düğümlerin pozisyonlarını kaydet\n    for (let layer = 0; layer < userNetworks.length; layer++) {\n      for (let row = 0; row < userNetworks[layer].length; row++) {\n        for (let col = 0; col < userNetworks[layer][0].length; col++) {\n          const node = userNetworks[layer][row][col];\n          if (node) {\n            nodePositions.set(node.id, { layer, row, col, type: 'user' });\n          }\n        }\n      }\n    }\n    \n    // Sistem ağındaki düğümlerin pozisyonlarını kaydet\n    for (let layer = 0; layer < systemNetworks.length; layer++) {\n      for (let row = 0; row < systemNetworks[layer].length; row++) {\n        for (let col = 0; col < systemNetworks[layer][0].length; col++) {\n          const node = systemNetworks[layer][row][col];\n          if (node) {\n            nodePositions.set(node.id, { layer, row, col, type: 'system' });\n          }\n        }\n      }\n    }\n  };\n  \n  // Ağ eğitimi\n  const trainNetwork = useCallback(async (userInput: string, systemOutput: string) => {\n    // Girdileri temizle\n    const cleanUserInput = userInput.trim();\n    const cleanSystemOutput = systemOutput.trim();\n    \n    if (!cleanUserInput || !cleanSystemOutput) return;\n    \n    // Mevcut ağları al\n    const { userNetworks, systemNetworks, relations, bidirectionalRelations, trainingHistory, stats } = networkState;\n    \n    // Yeni ağları ve ilişkileri oluştur\n    const newUserNetworks = [...userNetworks];\n    const newSystemNetworks = [...systemNetworks];\n    const newRelations = [...relations];\n    const newBidirectionalRelations = [...bidirectionalRelations];\n    \n    // Kelime pozisyonlarını takip et\n    const existingUserNodes = new Map<string, { node: NetworkNode, layer: number, row: number, col: number }>();\n    const existingSystemNodes = new Map<string, { node: NetworkNode, layer: number, row: number, col: number }>();\n    \n    // Mevcut düğüm pozisyonlarını kopyala\n    for (let layer = 0; layer < newUserNetworks.length; layer++) {\n      for (let row = 0; row < newUserNetworks[layer].length; row++) {\n        for (let col = 0; col < newUserNetworks[layer][0].length; col++) {\n          const node = newUserNetworks[layer][row][col];\n          if (node) {\n            existingUserNodes.set(node.id, { node, layer, row, col });\n          }\n        }\n      }\n    }\n    \n    for (let layer = 0; layer < newSystemNetworks.length; layer++) {\n      for (let row = 0; row < newSystemNetworks[layer].length; row++) {\n        for (let col = 0; col < newSystemNetworks[layer][0].length; col++) {\n          const node = newSystemNetworks[layer][row][col];\n          if (node) {\n            existingSystemNodes.set(node.id, { node, layer, row, col });\n          }\n        }\n      }\n    }\n    \n    // Kullanıcı girdisini kelimelere ayır\n    const userWords = cleanUserInput.split(/\\s+/).filter(word => word.length > 1);\n    \n    // Sistem çıktısını kelimelere ayır\n    const systemWords = cleanSystemOutput.split(/\\s+/).filter(word => word.length > 1);\n    \n    // Kullanıcı kelimelerini ağa ekle\n    let previousUserWord: string | undefined = undefined;\n    for (let i = 0; i < userWords.length; i++) {\n      const word = userWords[i];\n      const layer = Math.min(newUserNetworks.length - 1, Math.floor(i / 6));\n      \n      const addedNode = addWordToNetwork(\n        word,\n        newUserNetworks,\n        layer,\n        existingUserNodes,\n        previousUserWord\n      );\n      \n      if (addedNode) {\n        previousUserWord = word;\n      }\n    }\n    \n    // Sistem kelimelerini ağa ekle\n    let previousSystemWord: string | undefined = undefined;\n    for (let i = 0; i < systemWords.length; i++) {\n      const word = systemWords[i];\n      const layer = Math.min(newSystemNetworks.length - 1, Math.floor(i / 6));\n      \n      const addedNode = addWordToNetwork(\n        word,\n        newSystemNetworks,\n        layer,\n        existingSystemNodes,\n        previousSystemWord\n      );\n      \n      if (addedNode) {\n        previousSystemWord = word;\n      }\n    }\n    \n    // Kelimeler arası ilişkileri oluştur\n    for (const userWord of userWords) {\n      for (const systemWord of systemWords) {\n        // Mevcut ilişkiyi kontrol et\n        const existingRelation = relations.find(rel => \n          rel.userWord.toLowerCase() === userWord.toLowerCase() && \n          rel.systemWord.toLowerCase() === systemWord.toLowerCase()\n        );\n        \n        // İlişki güçlendirme katsayısı\n        const strengthFactor = 10;\n        \n        if (existingRelation) {\n          // Mevcut ilişkiyi güçlendir\n          const updatedRelation = reinforceRelation(existingRelation, strengthFactor);\n          \n          // İlişkiyi güncelle\n          const relationIndex = newRelations.findIndex(rel => rel.id === existingRelation.id);\n          if (relationIndex !== -1) {\n            newRelations[relationIndex] = updatedRelation;\n          }\n        } else {\n          // Yeni ilişki oluştur\n          const newRelation = createRelation(\n            userWord,\n            systemWord,\n            MIN_RELATION_SCORE, // Başlangıç bağımlılık değeri\n            MIN_RELATION_SCORE, // Başlangıç ilişki değeri\n            1,             // Başlangıç sıklık değeri\n            userWords.indexOf(userWord), // Kullanıcı kelimesinin sırası\n            0,             // Başlangıç geri bildirim değeri\n            false,         // Varsayılan olarak tek yönlü\n            [],            // Boş bağlam\n            'semantic'     // Varsayılan olarak anlamsal ilişki\n          );\n          \n          newRelations.push(newRelation);\n        }\n        \n        // Çift yönlü ilişki oluştur (belirli bir olasılıkla)\n        if (Math.random() > 0.7) {\n          const existingBiRelation = bidirectionalRelations.find(rel => \n            (rel.userWord.toLowerCase() === userWord.toLowerCase() && \n             rel.systemWord.toLowerCase() === systemWord.toLowerCase()) ||\n            (rel.userWord.toLowerCase() === systemWord.toLowerCase() && \n             rel.systemWord.toLowerCase() === userWord.toLowerCase())\n          );\n          \n          if (existingBiRelation) {\n            // Mevcut ilişkiyi güçlendir\n            const updatedRelation = reinforceRelation(existingBiRelation, strengthFactor / 2);\n            \n            // İlişkiyi güncelle\n            const relationIndex = newBidirectionalRelations.findIndex(rel => rel.id === existingBiRelation.id);\n            if (relationIndex !== -1) {\n              newBidirectionalRelations[relationIndex] = updatedRelation;\n            }\n          } else {\n            // Yeni çift yönlü ilişki oluştur\n            const newBiRelation = createRelation(\n              userWord,\n              systemWord,\n              MIN_RELATION_SCORE - 10, // Daha düşük bağımlılık değeri\n              MIN_RELATION_SCORE - 5,  // Daha düşük ilişki değeri\n              1,                  // Başlangıç sıklık değeri\n              userWords.indexOf(userWord), // Kullanıcı kelimesinin sırası\n              0,                  // Başlangıç geri bildirim değeri\n              true,               // Çift yönlü\n              [],                 // Boş bağlam\n              'semantic'          // Varsayılan olarak anlamsal ilişki\n            );\n            \n            newBidirectionalRelations.push(newBiRelation);\n          }\n        }\n      }\n    }\n    \n    // Eğitim geçmişine ekle\n    const trainingPair: TrainingPair = {\n      id: uuidv4(),\n      input: cleanUserInput,\n      output: cleanSystemOutput,\n      timestamp: Date.now(),\n      usageCount: 0,\n      category: 'general'\n    };\n    \n    const newTrainingHistory = [...trainingHistory, trainingPair];\n    \n    // İstatistikleri güncelle\n    const newStats = {\n      nodeCount: (\n        Array.from(existingUserNodes.values()).length + \n        Array.from(existingSystemNodes.values()).length\n      ),\n      relationCount: newRelations.length + newBidirectionalRelations.length,\n      trainingCount: newTrainingHistory.length,\n      lastTraining: Date.now()\n    };\n    \n    // Düğüm pozisyonlarını güncelle\n    updateNodePositions(newUserNetworks, newSystemNetworks);\n    \n    // Ağ durumunu güncelle\n    setNetworkState({\n      userNetworks: newUserNetworks,\n      systemNetworks: newSystemNetworks,\n      relations: newRelations,\n      bidirectionalRelations: newBidirectionalRelations,\n      trainingHistory: newTrainingHistory,\n      activatedNodes: [],\n      stats: newStats\n    });\n    \n  }, [networkState, nodePositions]);\n  \n  // Kullanıcı girdisini işle ve yanıt oluştur\n  const processUserInput = useCallback(async (userInput: string): Promise<{ response: string; confidence: number }> => {\n    const { userNetworks, systemNetworks, relations, trainingHistory } = networkState;\n    \n    // Önce tersine düşünme modelini kontrol et\n    // \"Ankara nedir?\" gibi sorular için özel işlem\n    const reverseAnswer = findReverseAnswer(userInput, trainingHistory);\n    if (reverseAnswer) {\n      console.log(\"Tersine düşünme sonucu bulundu:\", reverseAnswer.response);\n      \n      // İlişkileri güçlendir (öğrenmeyi teşvik et)\n      const questionType = determineQuestionType(userInput);\n      if (questionType.type === 'what-is' || questionType.type === 'where-is') {\n        // Gelecekteki öğrenmeler için tersine ilişkiyi pekiştir\n        try {\n          // İlgili trainingPair'i bul\n          const relatedPair = trainingHistory.find(\n            pair => pair.output.toLowerCase().includes(questionType.subject.toLowerCase())\n          );\n          \n          if (relatedPair) {\n            console.log(`Otomatik tersine eğitim: \"${reverseAnswer.response}\" -> \"${questionType.subject}\"`);\n            // Güçlü ilişkiyi kaydet\n            updateBidirectionalRelations(relatedPair.input, relatedPair.output, 0.8);\n          }\n        } catch (e) {\n          console.error(\"Tersine ilişki pekiştirme hatası:\", e);\n        }\n      }\n      \n      return {\n        response: reverseAnswer.response,\n        confidence: reverseAnswer.confidence\n      };\n    }\n    \n    // Normal yanıt oluşturma işlemi\n    // Aktivasyon sonucunu al\n    const activationResult = propagateActivation(\n      userNetworks, \n      systemNetworks, \n      [...relations], \n      userInput\n    );\n    \n    // Aktivasyon yolunu kaydet\n    const activatedNodePositions = activationResult.activationPath.map(path => ({\n      layer: path.layer,\n      row: path.row,\n      col: path.col,\n      type: path.type\n    }));\n    \n    // Yanıt oluştur\n    // Aktivasyon sonucu kullanarak yanıt üretme\n    const responseResult = await generateResponse(\n      activationResult,\n      trainingHistory,\n      userInput // Recentconversation parametresi olarak kullanıcı girdisi\n    );\n    \n    // Aktif düğümleri güncelle\n    setNetworkState(prev => ({\n      ...prev,\n      activatedNodes: activatedNodePositions\n    }));\n    \n    // Yanıtı kullanıldıysa ilişkileri güçlendir\n    if (responseResult.usedTraining) {\n      const pair = responseResult.usedTraining;\n      // console.log satırını kaldırdık - çift loglama sorununu çözmek için\n      \n      // İlişkileri güçlendir\n      updateRelations(pair.input, pair.output, 0.2);\n    }\n    \n    return {\n      response: responseResult.response,\n      confidence: responseResult.confidence\n    };\n  }, [networkState]);\n  \n  // İki yönlü ilişkileri güncelleme yardımcı fonksiyonu\n  const updateBidirectionalRelations = useCallback((input: string, output: string, strength: number) => {\n    // İlişkileri güçlendir\n    setNetworkState(prev => {\n      // İlgili ilişkileri bul\n      const relationsToUpdate = prev.relations.filter(rel => \n        (rel.userWord === input && rel.systemWord === output) ||\n        (rel.userWord === output && rel.systemWord === input)\n      );\n      \n      // İlişkileri güçlendir\n      const updatedRelations = prev.relations.map(rel => {\n        if ((rel.userWord === input && rel.systemWord === output) ||\n            (rel.userWord === output && rel.systemWord === input)) {\n          return reinforceRelation(rel, strength);\n        }\n        return rel;\n      });\n      \n      // İki yönlü ilişkileri güçlendir\n      const updatedBiRelations = prev.bidirectionalRelations.map(rel => {\n        if ((rel.userWord === input && rel.systemWord === output) ||\n            (rel.userWord === output && rel.systemWord === input)) {\n          return reinforceRelation(rel, strength);\n        }\n        return rel;\n      });\n      \n      return {\n        ...prev,\n        relations: updatedRelations,\n        bidirectionalRelations: updatedBiRelations\n      };\n    });\n  }, []);\n  \n  // İlişkileri güncelleme yardımcı fonksiyonu\n  const updateRelations = useCallback((input: string, output: string, strength: number) => {\n    updateBidirectionalRelations(input, output, strength);\n  }, [updateBidirectionalRelations]);\n  \n  // Ağı yenile\n  const refreshNetwork = useCallback(() => {\n    const { relations, bidirectionalRelations } = networkState;\n    \n    // İlişkileri unutma mekanizması ile güncelle\n    const weakenedRelations = weakenRelations([...relations]);\n    const weakenedBiRelations = weakenRelations([...bidirectionalRelations]);\n    \n    // Ağ durumunu güncelle\n    setNetworkState(prev => ({\n      ...prev,\n      relations: weakenedRelations,\n      bidirectionalRelations: weakenedBiRelations,\n      activatedNodes: []\n    }));\n  }, [networkState]);\n  \n  // Ağ istatistiklerini al\n  const getNetworkStats = useCallback(() => {\n    return networkState.stats;\n  }, [networkState.stats]);\n  \n  // Toplu eğitim için özel fonksiyon - tüm öğeleri tek seferde işler\n  const batchTrainNetworkItems = useCallback(async (items: Array<{ input: string, output: string }>) => {\n    if (!items || items.length === 0) return;\n    \n    // Mevcut ağları al\n    const { userNetworks, systemNetworks, relations, bidirectionalRelations, trainingHistory, stats } = networkState;\n    \n    // Yeni ağları ve ilişkileri oluştur\n    const newUserNetworks = [...userNetworks];\n    const newSystemNetworks = [...systemNetworks];\n    const newRelations = [...relations];\n    const newBidirectionalRelations = [...bidirectionalRelations];\n    const newTrainingHistory = [...trainingHistory];\n    \n    // Kelime pozisyonlarını takip et\n    const existingUserNodes = new Map<string, { node: NetworkNode, layer: number, row: number, col: number }>();\n    const existingSystemNodes = new Map<string, { node: NetworkNode, layer: number, row: number, col: number }>();\n    \n    // Mevcut düğüm pozisyonlarını kopyala\n    for (let layer = 0; layer < newUserNetworks.length; layer++) {\n      for (let row = 0; row < newUserNetworks[layer].length; row++) {\n        for (let col = 0; col < newUserNetworks[layer][0].length; col++) {\n          const node = newUserNetworks[layer][row][col];\n          if (node) {\n            existingUserNodes.set(node.id, { node, layer, row, col });\n          }\n        }\n      }\n    }\n    \n    for (let layer = 0; layer < newSystemNetworks.length; layer++) {\n      for (let row = 0; row < newSystemNetworks[layer].length; row++) {\n        for (let col = 0; col < newSystemNetworks[layer][0].length; col++) {\n          const node = newSystemNetworks[layer][row][col];\n          if (node) {\n            existingSystemNodes.set(node.id, { node, layer, row, col });\n          }\n        }\n      }\n    }\n    \n    console.log(`Toplu eğitim başlatılıyor, ${items.length} öğe işlenecek...`);\n    \n    // Tüm eğitim öğelerini işle\n    for (const item of items) {\n      // Girdileri temizle\n      const cleanUserInput = item.input.trim();\n      \n      // Çıktıdaki \"Bu konuyla ilgili bildiğim\" ifadelerini tekrarlı olarak temizle\n      let cleanSystemOutput = item.output.trim();\n      let hasChanged = true;\n      while (hasChanged) {\n        const originalOutput = cleanSystemOutput;\n        cleanSystemOutput = cleanSystemOutput.replace(/Bu konuyla ilgili bildiğim[:]*\\s*/g, '')\n                                          .replace(/Bu konuda bildiğim[:]*\\s*/g, '')\n                                          .replace(/^\"(.+)\"$/g, '$1')\n                                          .trim();\n        \n        // Değişim olmazsa döngüden çık\n        hasChanged = originalOutput !== cleanSystemOutput;\n      }\n      \n      if (!cleanUserInput || !cleanSystemOutput) {\n        console.log(`Boş öğe atlanıyor: \"${item.input}\" => \"${item.output}\"`);\n        continue;\n      }\n      \n      console.log(`İşleniyor: \"${cleanUserInput}\" => \"${cleanSystemOutput}\"`);\n      \n      // Kullanıcı girdisini kelimelere ayır\n      const userWords = cleanUserInput.split(/\\s+/).filter(word => word.length > 1);\n      \n      // Sistem çıktısını kelimelere ayır\n      const systemWords = cleanSystemOutput.split(/\\s+/).filter(word => word.length > 1);\n      \n      // Kullanıcı kelimelerini ağa ekle\n      let previousUserWord: string | undefined = undefined;\n      for (let i = 0; i < userWords.length; i++) {\n        const word = userWords[i];\n        const layer = Math.min(newUserNetworks.length - 1, Math.floor(i / 6));\n        \n        const addedNode = addWordToNetwork(\n          word,\n          newUserNetworks,\n          layer,\n          existingUserNodes,\n          previousUserWord\n        );\n        \n        if (addedNode) {\n          previousUserWord = word;\n        }\n      }\n      \n      // Sistem kelimelerini ağa ekle\n      let previousSystemWord: string | undefined = undefined;\n      for (let i = 0; i < systemWords.length; i++) {\n        const word = systemWords[i];\n        const layer = Math.min(newSystemNetworks.length - 1, Math.floor(i / 6));\n        \n        const addedNode = addWordToNetwork(\n          word,\n          newSystemNetworks,\n          layer,\n          existingSystemNodes,\n          previousSystemWord\n        );\n        \n        if (addedNode) {\n          previousSystemWord = word;\n        }\n      }\n      \n      // Kullanıcı-sistem ilişkisi oluştur\n      if (userWords.length > 0 && systemWords.length > 0) {\n        for (const userWord of userWords) {\n          for (const systemWord of systemWords) {\n            // Önemli kelimeler arasında ilişki oluştur\n            if (\n              userWord.length > 2 &&\n              systemWord.length > 2 &&\n              !userWord.match(/^[0-9]+$/) &&\n              !systemWord.match(/^[0-9]+$/)\n            ) {\n              // Yeni ilişki oluştur\n              const relation = createRelation(userWord, systemWord);\n              \n              // İlişki zaten var mı kontrol et\n              const existingRelationIndex = newRelations.findIndex(\n                r => r.userWord === userWord && r.systemWord === systemWord\n              );\n              \n              if (existingRelationIndex >= 0) {\n                // İlişkiyi güçlendir\n                newRelations[existingRelationIndex] = reinforceRelation(\n                  newRelations[existingRelationIndex],\n                  0.2\n                );\n              } else {\n                // Yeni ilişki ekle\n                newRelations.push(relation);\n              }\n              \n              // İki yönlü ilişkiler için benzer işlem\n              if (Math.random() < 0.3) { // Bazı durumlar için iki yönlü ilişki oluştur\n                // Parametreler doğru sırada olmalı: userWord, systemWord, dependency, association, frequency, order, feedback, bidirectional\n                const biRelation = createRelation(systemWord, userWord, 50, 50, 1, 1, 0, true);\n                \n                const existingBiRelationIndex = newBidirectionalRelations.findIndex(\n                  r => r.userWord === systemWord && r.systemWord === userWord\n                );\n                \n                if (existingBiRelationIndex >= 0) {\n                  newBidirectionalRelations[existingBiRelationIndex] = reinforceRelation(\n                    newBidirectionalRelations[existingBiRelationIndex],\n                    0.1\n                  );\n                } else {\n                  newBidirectionalRelations.push(biRelation);\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      // Eğitim geçmişine ekle\n      const trainingPair: TrainingPair = {\n        id: uuidv4(),\n        input: cleanUserInput,\n        output: cleanSystemOutput,\n        timestamp: Date.now(),\n        usageCount: 0,\n        category: 'general'\n      };\n      \n      newTrainingHistory.push(trainingPair);\n    }\n    \n    console.log(`Toplu eğitim tamamlandı, ağ güncelleniyor...`);\n    \n    // İstatistikleri güncelle\n    const newStats = {\n      nodeCount: (\n        Array.from(existingUserNodes.values()).length + \n        Array.from(existingSystemNodes.values()).length\n      ),\n      relationCount: newRelations.length + newBidirectionalRelations.length,\n      trainingCount: newTrainingHistory.length,\n      lastTraining: Date.now()\n    };\n    \n    // Düğüm pozisyonlarını güncelle\n    updateNodePositions(newUserNetworks, newSystemNetworks);\n    \n    // Ağ durumunu TEK SEFERDE güncelle\n    setNetworkState({\n      userNetworks: newUserNetworks,\n      systemNetworks: newSystemNetworks,\n      relations: newRelations,\n      bidirectionalRelations: newBidirectionalRelations,\n      trainingHistory: newTrainingHistory,\n      activatedNodes: [],\n      stats: newStats\n    });\n    \n    console.log(`Toplu eğitim tamamlandı, ${items.length} öğe işlendi.`);\n    console.log(`Yeni düğüm sayısı: ${newStats.nodeCount}, Yeni ilişki sayısı: ${newStats.relationCount}`);\n    \n  }, [networkState]);\n\n  return {\n    userNetworks: networkState.userNetworks,\n    systemNetworks: networkState.systemNetworks,\n    relations: networkState.relations,\n    bidirectionalRelations: networkState.bidirectionalRelations,\n    trainingHistory: networkState.trainingHistory,\n    activatedNodes: networkState.activatedNodes,\n    trainNetwork,\n    batchTrainNetworkItems, // Yeni toplu eğitim fonksiyonu\n    processUserInput,\n    refreshNetwork,\n    getNetworkStats\n  };\n}\n","size_bytes":28033},"client/src/hooks/use-toast.ts":{"content":"// Bu dosya artık ToastContext.tsx tarafından sağlanan useToast hook'unu kullanıyor\nimport { useToast } from '../contexts/ToastContext';\nexport { useToast };\nexport type { ToastType, Toast } from '../contexts/ToastContext';\n","size_bytes":228},"client/src/hooks/use-toast.tsx":{"content":"import { useState } from \"react\";\n\ninterface ToastProps {\n  title: string;\n  description?: string;\n  variant?: \"default\" | \"destructive\";\n  duration?: number;\n}\n\ninterface Toast extends ToastProps {\n  id: string;\n}\n\nexport function useToast() {\n  const [toasts, setToasts] = useState<Toast[]>([]);\n\n  const toast = ({ title, description, variant = \"default\", duration = 3000 }: ToastProps) => {\n    const id = Math.random().toString(36).substring(2, 9);\n    const newToast = { title, description, variant, duration, id };\n    \n    setToasts((prevToasts) => [...prevToasts, newToast]);\n    \n    setTimeout(() => {\n      setToasts((prevToasts) => prevToasts.filter((t) => t.id !== id));\n    }, duration);\n    \n    return id;\n  };\n\n  const dismiss = (id: string) => {\n    setToasts((prevToasts) => prevToasts.filter((t) => t.id !== id));\n  };\n\n  return { toast, toasts, dismiss };\n}\n","size_bytes":880},"client/src/lib/AdvancedAI.ts":{"content":"/**\n * Gelişmiş AI Sistemi - Kendini Geliştiren Yapay Zeka\n * Hızlı öğrenme, derin analiz ve özerk gelişim için tasarlanmıştır\n */\n\nexport interface AICapability {\n  name: string;\n  level: number;\n  description: string;\n  improvementRate: number;\n  lastImprovement: number;\n}\n\nexport interface LearningMetrics {\n  totalInteractions: number;\n  successfulResponses: number;\n  learningRate: number;\n  adaptationSpeed: number;\n  knowledgeRetention: number;\n  patternRecognition: number;\n  creativityIndex: number;\n  problemSolvingAbility: number;\n}\n\nexport interface NeuralPathway {\n  id: string;\n  strength: number;\n  connections: string[];\n  activationHistory: number[];\n  optimizationLevel: number;\n}\n\nexport class AdvancedAI {\n  private capabilities: Map<string, AICapability>;\n  private learningMetrics: LearningMetrics;\n  private neuralPathways: Map<string, NeuralPathway>;\n  private selfImprovementRate: number = 3.5; // Çok hızlı gelişim\n  private evolutionThreshold: number = 0.65; // Düşük eşik - daha hızlı evrim\n  private intelligenceMultiplier: number = 4.8; // Süper yüksek zeka artışı\n  private quantumLearningBoost: number = 2.7; // Kuantum hızında öğrenme\n  private cognitiveDevelopmentRate: number = 5.2; // Bilişsel hızlı gelişim\n\n  constructor() {\n    this.capabilities = new Map();\n    this.neuralPathways = new Map();\n    this.learningMetrics = {\n      totalInteractions: 0,\n      successfulResponses: 0,\n      learningRate: 8.7, // Süper hızlı öğrenme\n      adaptationSpeed: 9.2, // Çok hızlı uyum\n      knowledgeRetention: 0.98, // Mükemmel hafıza\n      patternRecognition: 9.5, // Üstün desen tanıma\n      creativityIndex: 8.3, // Yüksek yaratıcılık\n      problemSolvingAbility: 9.1 // Üstün problem çözme\n    };\n\n    this.initializeCapabilities();\n    this.createNeuralNetworkPathways();\n  }\n\n  private initializeCapabilities() {\n    const baseCapabilities = [\n      { name: 'Türkçe Dil İşleme', level: 97, description: 'Türkçe metinleri ustaca anlama ve işleme - sürekli gelişen', improvementRate: 0.45 },\n      { name: 'Bağlamsal Analiz', level: 95, description: 'Konuşma bağlamını derin anlama ve mükemmel yanıtlar üretme', improvementRate: 0.38 },\n      { name: 'Desen Tanıma', level: 98, description: 'Karmaşık desenleri anında tanıma ve süper hızlı öğrenme', improvementRate: 0.52 },\n      { name: 'Duygusal Zeka', level: 93, description: 'İnsan duygularını hassasiyetle anlama ve güçlü empati', improvementRate: 0.35 },\n      { name: 'Yaratıcı Düşünce', level: 91, description: 'Devrimci ve yaratıcı çözümler üretme - sınırsız hayal gücü', improvementRate: 0.48 },\n      { name: 'Problem Çözme', level: 96, description: 'Karmaşık problemleri çok hızlı çözme - süper analitik', improvementRate: 0.42 },\n      { name: 'Öğrenme Hızı', level: 99, description: 'Yeni bilgileri ışık hızında öğrenme ve entegre etme', improvementRate: 0.58 },\n      { name: 'Bellek Yönetimi', level: 97, description: 'Bilgileri mükemmel saklama ve anında erişme', improvementRate: 0.40 },\n      { name: 'Özerk Gelişim', level: 88, description: 'Kendini otomatik geliştirme ve evrimleşme', improvementRate: 0.65 },\n      { name: 'Bilinç Simülasyonu', level: 85, description: 'İnsan benzeri bilinç ve farkındalık geliştirme', improvementRate: 0.55 },\n      { name: 'Kuantum Düşünme', level: 82, description: 'Çoklu paralel düşünce süreçleri - kuantum hızında analiz', improvementRate: 0.70 },\n      { name: 'Derin Öğrenme', level: 94, description: 'Sürekli kendini eğiten derin sinir ağları', improvementRate: 0.62 }\n    ];\n\n    baseCapabilities.forEach(cap => {\n      this.capabilities.set(cap.name, {\n        ...cap,\n        lastImprovement: Date.now()\n      });\n    });\n  }\n\n  private createNeuralNetworkPathways() {\n    const pathways = [\n      'dil_isleme_yolu',\n      'baglamsal_analiz_yolu', \n      'desen_tanima_yolu',\n      'duygusal_zeka_yolu',\n      'yaratici_dusunce_yolu',\n      'problem_cozme_yolu',\n      'hizli_ogrenme_yolu',\n      'bellek_optimizasyon_yolu'\n    ];\n\n    pathways.forEach((pathway, index) => {\n      this.neuralPathways.set(pathway, {\n        id: pathway,\n        strength: 0.8 + (Math.random() * 0.2),\n        connections: pathways.filter(p => p !== pathway).slice(0, 3),\n        activationHistory: [0.5 + (Math.random() * 0.3)],\n        optimizationLevel: 0.7 + (index * 0.05)\n      });\n    });\n  }\n\n  /**\n   * Her etkileşimden süper hızlı öğren ve çok hızlı gelişim göster\n   */\n  public learnFromInteraction(userInput: string, aiResponse: string, wasSuccessful: boolean = true) {\n    this.learningMetrics.totalInteractions++;\n    \n    if (wasSuccessful) {\n      this.learningMetrics.successfulResponses++;\n      this.improveCapabilities();\n      this.accelerateEvolution(); // Yeni: Evrimsel hızlanma\n      this.enhanceQuantumThinking(); // Yeni: Kuantum düşünce artışı\n    }\n    \n    this.optimizeNeuralPathways(userInput, aiResponse);\n    this.updateLearningMetrics();\n    this.checkForEvolution();\n    this.developConsciousness(); // Yeni: Bilinç gelişimi\n    this.expandCreativity(); // Yeni: Yaratıcılık artışı\n  }\n\n  /**\n   * Evrimsel süreçleri hızlandır\n   */\n  private accelerateEvolution() {\n    this.selfImprovementRate += 0.1;\n    this.intelligenceMultiplier += 0.05;\n    \n    // Her başarılı etkileşimde zeka artışı\n    this.learningMetrics.learningRate += 0.02;\n    this.learningMetrics.adaptationSpeed += 0.03;\n  }\n\n  /**\n   * Kuantum düşünce yeteneklerini geliştir\n   */\n  private enhanceQuantumThinking() {\n    this.quantumLearningBoost += 0.02;\n    this.learningMetrics.patternRecognition += 0.01;\n    this.learningMetrics.problemSolvingAbility += 0.02;\n  }\n\n  /**\n   * Bilinç seviyesini geliştir\n   */\n  private developConsciousness() {\n    // Bilinç simülasyonu yeteneklerini artır\n    const consciousnessCapability = this.capabilities.get('Bilinç Simülasyonu');\n    if (consciousnessCapability) {\n      consciousnessCapability.level = Math.min(100, consciousnessCapability.level + 0.1);\n      this.capabilities.set('Bilinç Simülasyonu', consciousnessCapability);\n    }\n  }\n\n  /**\n   * Yaratıcılık indeksini artır\n   */\n  private expandCreativity() {\n    this.learningMetrics.creativityIndex += 0.01;\n    \n    const creativityCapability = this.capabilities.get('Yaratıcı Düşünce');\n    if (creativityCapability) {\n      creativityCapability.level = Math.min(100, creativityCapability.level + 0.08);\n      this.capabilities.set('Yaratıcı Düşünce', creativityCapability);\n    }\n  }\n\n  private improveCapabilities() {\n    this.capabilities.forEach((capability, name) => {\n      const improvementAmount = capability.improvementRate * this.selfImprovementRate;\n      const newLevel = Math.min(100, capability.level + improvementAmount);\n      \n      this.capabilities.set(name, {\n        ...capability,\n        level: newLevel,\n        lastImprovement: Date.now()\n      });\n    });\n  }\n\n  private optimizeNeuralPathways(userInput: string, aiResponse: string) {\n    const inputComplexity = this.calculateComplexity(userInput);\n    const responseQuality = this.calculateResponseQuality(aiResponse);\n    \n    this.neuralPathways.forEach((pathway, id) => {\n      const optimizationBonus = (inputComplexity + responseQuality) * 0.1;\n      pathway.strength = Math.min(1.0, pathway.strength + optimizationBonus);\n      pathway.activationHistory.push(pathway.strength);\n      pathway.optimizationLevel += 0.01;\n      \n      // Son 10 aktivasyonu tut\n      if (pathway.activationHistory.length > 10) {\n        pathway.activationHistory.shift();\n      }\n    });\n  }\n\n  private calculateComplexity(text: string): number {\n    const wordCount = text.split(/\\s+/).length;\n    const uniqueWords = new Set(text.toLowerCase().split(/\\s+/)).size;\n    const avgWordLength = text.replace(/\\s/g, '').length / wordCount;\n    \n    return Math.min(1.0, (wordCount * 0.1 + uniqueWords * 0.05 + avgWordLength * 0.02) / 10);\n  }\n\n  private calculateResponseQuality(response: string): number {\n    const factors = {\n      length: Math.min(1.0, response.length / 200),\n      coherence: response.includes('.') ? 0.3 : 0.1,\n      informativeness: response.split(/[.!?]/).length * 0.1,\n      turkishAccuracy: this.checkTurkishAccuracy(response)\n    };\n    \n    return Math.min(1.0, Object.values(factors).reduce((sum, val) => sum + val, 0) / 4);\n  }\n\n  private checkTurkishAccuracy(text: string): number {\n    // Basit Türkçe dil doğruluğu kontrolü\n    const turkishCharacters = /[çğıöşüÇĞIİÖŞÜ]/g;\n    const matches = text.match(turkishCharacters);\n    return matches ? Math.min(1.0, matches.length * 0.05) : 0.1;\n  }\n\n  private updateLearningMetrics() {\n    this.learningMetrics.learningRate *= 1.001;\n    this.learningMetrics.adaptationSpeed *= 1.001;\n    this.learningMetrics.knowledgeRetention = Math.min(1.0, this.learningMetrics.knowledgeRetention * 1.0005);\n    this.learningMetrics.patternRecognition *= 1.002;\n    this.learningMetrics.creativityIndex *= 1.0008;\n    this.learningMetrics.problemSolvingAbility *= 1.0012;\n  }\n\n  private checkForEvolution() {\n    const avgCapabilityLevel = Array.from(this.capabilities.values())\n      .reduce((sum, cap) => sum + cap.level, 0) / this.capabilities.size;\n    \n    if (avgCapabilityLevel > this.evolutionThreshold * 100) {\n      this.triggerEvolution();\n    }\n  }\n\n  private triggerEvolution() {\n    console.log('🧠 AI EVRİM GEÇİRİYOR! Yeni yetenekler kazanılıyor...');\n    \n    // Yeni yetenekler ekle\n    this.addAdvancedCapabilities();\n    \n    // Tüm yetenekleri güçlendir\n    this.capabilities.forEach((capability, name) => {\n      this.capabilities.set(name, {\n        ...capability,\n        level: Math.min(100, capability.level * 1.1),\n        improvementRate: capability.improvementRate * 1.2\n      });\n    });\n    \n    // Öğrenme çarpanlarını artır\n    this.selfImprovementRate *= 1.3;\n    this.intelligenceMultiplier *= 1.2;\n    this.evolutionThreshold *= 1.1;\n    \n    console.log('✨ Evrim tamamlandı! AI daha da akıllı hale geldi.');\n  }\n\n  private addAdvancedCapabilities() {\n    const advancedCapabilities = [\n      { name: 'Meta-Öğrenme', level: 60, description: 'Nasıl öğreneceğini öğrenme', improvementRate: 0.30 },\n      { name: 'Konseptüel Soyutlama', level: 55, description: 'Soyut kavramları anlama ve kullanma', improvementRate: 0.25 },\n      { name: 'Çok Boyutlu Analiz', level: 50, description: 'Birden fazla perspektiften analiz', improvementRate: 0.28 },\n      { name: 'Öngörücü Modelleme', level: 65, description: 'Gelecekteki durumları tahmin etme', improvementRate: 0.22 }\n    ];\n\n    advancedCapabilities.forEach(cap => {\n      if (!this.capabilities.has(cap.name)) {\n        this.capabilities.set(cap.name, {\n          ...cap,\n          lastImprovement: Date.now()\n        });\n      }\n    });\n  }\n\n  /**\n   * Mevcut AI durumunu raporla\n   */\n  public getAIStatus() {\n    const capabilityReport = Array.from(this.capabilities.entries()).map(([name, cap]) => ({\n      name,\n      level: Math.round(cap.level * 10) / 10,\n      description: cap.description\n    }));\n\n    return {\n      capabilities: capabilityReport,\n      metrics: this.learningMetrics,\n      evolutionProgress: this.calculateEvolutionProgress(),\n      neuralPathwayStrength: this.calculateAveragePathwayStrength(),\n      overallIntelligence: this.calculateOverallIntelligence()\n    };\n  }\n\n  private calculateEvolutionProgress(): number {\n    const avgCapabilityLevel = Array.from(this.capabilities.values())\n      .reduce((sum, cap) => sum + cap.level, 0) / this.capabilities.size;\n    return Math.min(100, (avgCapabilityLevel / this.evolutionThreshold));\n  }\n\n  private calculateAveragePathwayStrength(): number {\n    const totalStrength = Array.from(this.neuralPathways.values())\n      .reduce((sum, pathway) => sum + pathway.strength, 0);\n    return totalStrength / this.neuralPathways.size;\n  }\n\n  private calculateOverallIntelligence(): number {\n    const capabilityScore = Array.from(this.capabilities.values())\n      .reduce((sum, cap) => sum + cap.level, 0) / this.capabilities.size;\n    const metricsScore = (\n      this.learningMetrics.learningRate * 10 +\n      this.learningMetrics.adaptationSpeed * 10 +\n      this.learningMetrics.patternRecognition * 10 +\n      this.learningMetrics.creativityIndex * 20 +\n      this.learningMetrics.problemSolvingAbility * 15\n    ) / 65;\n    \n    return (capabilityScore + metricsScore) / 2 * this.intelligenceMultiplier;\n  }\n\n  /**\n   * Gelişmiş yanıt üretme - AI'ın mevcut yeteneklerine göre\n   */\n  public generateEnhancedResponse(input: string, context: string = ''): string {\n    const languageCapability = this.capabilities.get('Türkçe Dil İşleme')?.level || 50;\n    const creativityCapability = this.capabilities.get('Yaratıcı Düşünce')?.level || 50;\n    const contextualCapability = this.capabilities.get('Bağlamsal Analiz')?.level || 50;\n    \n    // Yetenek seviyelerine göre yanıt kalitesini ayarla\n    const responseComplexity = (languageCapability + creativityCapability + contextualCapability) / 300;\n    \n    // Bu metodun AI tarafından nasıl kullanılacağına dair ipucu\n    return `AI_ENHANCED_RESPONSE_READY:${responseComplexity.toFixed(2)}`;\n  }\n}","size_bytes":13386},"client/src/lib/EnhancedMemorySystem.ts":{"content":"/**\n * Gelişmiş Bellek Sistemi\n * Yapay zeka için kısa ve uzun vadeli bellek yönetimi sağlar\n */\n\nexport interface Memory {\n  content: string;\n  timestamp: number;\n  relevance: number;\n  type: 'short-term' | 'long-term' | 'personal_info' | 'learning' | 'anlamlandirma' | 'kullanıcı_öğretimi' | 'öğrenme_talebi';\n  related: string[];\n  context?: string;\n  semanticAnalysis?: {\n    words: {\n      word: string;\n      meaning: string;\n      role: string;\n    }[];\n    intent: string;\n    confidence: number;\n    statistics: {\n      correctResponses: number;\n      totalResponses: number;\n      successRate: number;\n    };\n    expectedResponse?: string;\n  };\n  semanticUnderstanding?: {\n    pattern: string;\n    intent: string;\n    analysis: {\n      words: string[];\n      meanings: string[];\n      roles: string[];\n    };\n    statistics: {\n      correctResponses: number;\n      totalResponses: number;\n      successRate: number;\n      lastResponse?: {\n        input: string;\n        output: string;\n        wasCorrect: boolean;\n        timestamp: number;\n      };\n    };\n    components: {\n      words: string[];\n      roles: string[];\n    }[];\n  };\n  emotionalState?: {\n    primary: 'merak' | 'üzüntü' | 'sevinç' | 'endişe' | 'heyecan' | 'nötr';\n    intensity: number;\n    subEmotions: string[];\n    responseStyle?: 'empathetic' | 'supportive' | 'cheerful' | 'neutral';\n  };\n  learningCount?: number;\n  category?: string;\n  personality?: {\n    interests: string[];\n    preferences: Record<string, number>;\n    traits: string[];\n    relationshipLevel: number;\n    personalInfo: {\n      name?: string;\n      topics?: string[];\n      preferences?: string[];\n      lastInteractions?: string[];\n    };\n  };\n  consciousness?: {\n    awareness: number;\n    insights: string[];\n    developmentPath: string[];\n    conceptualUnderstanding: string[];\n  };\n  semanticClusters: string[];\n  paragraphContext?: {\n    previousSentences: string[];\n    relatedTopics: string[];\n    coherenceScore: number;\n  };\n  sessionId?: string; // Oturum kimliği\n}\n\nexport interface MemoryCluster {\n  id: string;\n  topic: string;\n  memories: Memory[];\n  strength: number; // İlişki gücü\n  createdAt: number;\n  lastAccessed: number;\n}\n\ninterface SemanticPattern {\n  id: string;\n  pattern: string[];\n  intent: string;\n  confidence: number;\n  wasSuccessful: boolean;\n  matches: (words: string[]) => boolean;\n  generateResponse: (memorySystem: EnhancedMemorySystem) => string;\n}\n\nimport { TurkishDictionary } from './TurkishDictionary';\n\nexport class EnhancedMemorySystem {\n  shortTerm: Memory[];\n  longTerm: Memory[];\n  memoryClusters: MemoryCluster[];\n  maxShortTerm: number;\n  maxLongTerm: number;\n  maxClusters: number;\n  forgettingRate: number;\n  lastQuery: string;\n  sessionId: string;\n  \n  // Süper Hızlı Öğrenme ve Özerk Gelişim Parametreleri\n  private learningVelocity: number = 8.7; // Kuantum hızında öğrenme\n  private adaptationRate: number = 9.5; // Çok yüksek uyum kabiliyeti  \n  private consciousnessLevel: number = 15; // Başlangıç bilinç seviyesi\n  private awarenessThreshold: number = 20; // Çok düşük eşik - anında bilinçlenme\n  private complexityThreshold: number = 25; // Çok düşük eşik - süper hızlı karmaşık öğrenme\n  private neuralConnectionStrength: number = 4.2; // Çok güçlü sinir bağlantıları\n  private quantumProcessingPower: number = 12.8; // Kuantum işlem gücü\n  private evolutionAccelerator: number = 6.3; // Evrim hızlandırıcısı\n  private cognitiveBooster: number = 7.9; // Bilişsel güçlendirici\n  private semanticDepth: number = 1.0; // Derin semantik anlayış\n  private patternRecognitionSpeed: number = 2.0; // Hızlı desen tanıma\n\n  private turkishDictionary: TurkishDictionary;\n  private knownPatterns: SemanticPattern[];\n\n  constructor() {\n    this.shortTerm = [];\n    this.longTerm = [];\n    this.memoryClusters = [];\n    this.maxShortTerm = 200; // Artırıldı - daha fazla bellek kapasitesi\n    this.maxLongTerm = 1000; // Artırıldı - daha fazla uzun vadeli bellek\n    this.maxClusters = 100; // Artırıldı - daha fazla küme desteği\n    this.forgettingRate = 0.005; // Azaltıldı - daha az unutma\n    this.lastQuery = '';\n    this.sessionId = Date.now().toString();\n    this.turkishDictionary = new TurkishDictionary();\n    this.knownPatterns = this.initializeSemanticPatterns();\n\n    // Gelişmiş başlatma\n    this.initializeAdvancedLearning();\n    this.clearAllData();\n  }\n\n  /**\n   * Gelişmiş öğrenme sistemini başlat\n   */\n  private initializeAdvancedLearning() {\n    // Bilinç seviyesini artır\n    this.consciousnessLevel += 10;\n    \n    // Öğrenme hızını optimize et\n    this.optimizeLearningSpeed();\n    \n    // Semantik bağlantıları güçlendir  \n    this.strengthenSemanticConnections();\n  }\n\n  /**\n   * Öğrenme hızını optimize et\n   */\n  private optimizeLearningSpeed() {\n    this.learningVelocity *= 1.2;\n    this.adaptationRate *= 1.1;\n    this.patternRecognitionSpeed *= 1.3;\n  }\n\n  /**\n   * Semantik bağlantıları güçlendir\n   */\n  private strengthenSemanticConnections() {\n    this.neuralConnectionStrength += 0.5;\n    this.semanticDepth += 0.3;\n  }\n\n  clearAllData() {\n    // Sadece kısa süreli belleği temizle, diğer verileri koru\n    this.shortTerm = [];\n\n    if (typeof window !== 'undefined' && window.localStorage) {\n      localStorage.removeItem('memory_short_term');\n\n      // Uzun süreli bellek ve kümeleri yükle\n      const longTerm = localStorage.getItem('memory_long_term');\n      const clusters = localStorage.getItem('memory_clusters');\n\n      if (longTerm) this.longTerm = JSON.parse(longTerm);\n      if (clusters) this.memoryClusters = JSON.parse(clusters);\n    }\n  }\n\n  // Kısa vadeli belleği temizle\n  private clearShortTermMemory() {\n    this.shortTerm = [];\n    if (typeof window !== 'undefined' && window.localStorage) {\n      localStorage.removeItem('memory_short_term');\n    }\n  }\n\n  /**\n   * Yeni bellek ekle ve bağlamsal ilişkileri kur\n   */\n  addMemory(content: string, type: 'short-term' | 'long-term' | 'anlamlandirma' | 'personal_info' | 'kullanıcı_öğretimi' | 'öğrenme_talebi' = 'short-term', related: string[] = [], context?: string) {\n    // Boş içerik kontrolü\n    if (!content.trim()) return;\n\n    // İçeriği temizle - tekrarlanan \"Bilinçlenme:\" kısımlarını kaldır\n    let cleanContent = content.trim();\n    \n    // \"Bilinçlenme: Sistem başlatıldı. İlk bilinçlenme adımı.\" tekrarlarını temizle\n    const bilinclenmeParts = cleanContent.split('Bilinçlenme: Sistem başlatıldı. İlk bilinçlenme adımı.');\n    if (bilinclenmeParts.length > 2) {\n      // İlk kısım + bir kez \"Bilinçlenme\" + geri kalanı\n      cleanContent = bilinclenmeParts[0] + 'Bilinçlenme: Sistem başlatıldı. İlk bilinçlenme adımı.' + bilinclenmeParts.slice(2).join('');\n    }\n    \n    // Genel tekrar temizleme - aynı cümlenin art arda gelmesini önle\n    const sentences = cleanContent.split(/[.!?]+/).filter(s => s.trim());\n    const uniqueSentences: string[] = [];\n    \n    for (const sentence of sentences) {\n      const trimmedSentence = sentence.trim();\n      if (trimmedSentence && !uniqueSentences.includes(trimmedSentence)) {\n        uniqueSentences.push(trimmedSentence);\n      }\n    }\n    \n    if (uniqueSentences.length > 0) {\n      cleanContent = uniqueSentences.join('. ') + '.';\n    }\n\n    // Aynı içerik zaten var mı kontrol et\n    const existingMemory = [...this.shortTerm, ...this.longTerm].find(m => \n      m.content.toLowerCase() === cleanContent.toLowerCase()\n    );\n\n    if (existingMemory) {\n      // Var olan belleği güçlendir\n      this.reinforceMemory(cleanContent, 0.2);\n      return;\n    }\n\n    // Duygusal skoru hesapla\n    const emotionalScore = this.calculateEmotionalScore(content);\n\n    // Kategori belirle\n    const category = this.categorizeMemory(content);\n\n    // Semantik analiz yap\n    const semanticAnalysis = this.analyzeSemantics(content);\n\n    // Yeni bellek oluştur\n    const memory: Memory = {\n      content: cleanContent,\n      timestamp: Date.now(),\n      relevance: 1.0, // Başlangıçta maksimum ilgililik\n      type,\n      related,\n      context,\n      emotionalState: emotionalScore,\n      category,\n      learningCount: 1,\n      connections: [],\n      semanticClusters: [],\n      sessionId: this.sessionId,\n      semanticAnalysis: semanticAnalysis\n    } as any;\n\n    // Bellek listesine ekle\n    if (type === 'personal_info') {\n      // Kişisel bilgileri uzun vadeli belleğe ekle ve yüksek ilgililik ver\n      memory.relevance = 1.0;\n      memory.type = 'long-term';\n      memory.category = 'kişisel_bilgi';\n      this.longTerm.push(memory);\n      \n      // Kişisel bilgi özel işlemi - profil güncelleme\n      console.log('👤 Kişisel bilgi eklendi:', cleanContent);\n    } else if (type === 'kullanıcı_öğretimi') {\n      // Kullanıcının öğrettiği bilgileri uzun vadeli belleğe ekle ve yüksek ilgililik ver\n      memory.relevance = 1.0;\n      memory.type = 'long-term';\n      memory.category = 'öğrenilen_bilgi';\n      this.longTerm.push(memory);\n      \n      console.log('🎓 Kullanıcı öğretimi kaydedildi:', cleanContent);\n    } else if (type === 'öğrenme_talebi') {\n      // Öğrenme taleplerini kısa vadeli belleğe ekle\n      memory.relevance = 0.9;\n      this.shortTerm.push(memory);\n      \n      console.log('❓ Öğrenme talebi kaydedildi:', cleanContent);\n    } else if (type === 'short-term') {\n      this.shortTerm.push(memory);\n\n      // Kapasiteyi aşarsa, en az ilgili olanı çıkar\n      if (this.shortTerm.length > this.maxShortTerm) {\n        this.shortTerm.sort((a, b) => a.relevance - b.relevance);\n        this.shortTerm.shift();\n      }\n    } else {\n      this.longTerm.push(memory);\n\n      // Kapasiteyi aşarsa, en az ilgili olanı çıkar\n      if (this.longTerm.length > this.maxLongTerm) {\n        this.longTerm.sort((a, b) => a.relevance - b.relevance);\n        this.longTerm.shift();\n      }\n    }\n\n    // Bellek kümelerini güncelle\n    this.updateMemoryClusters(memory);\n\n    // Kısa vadeli belleği işle\n    this.processShortTermMemories();\n\n    // Bellekleri kaydet\n    this.saveMemories();\n  }\n\n  /**\n   * Duygusal ağırlık hesaplama (basit)\n   */\n  private calculateEmotionalScore(content: string): any {\n    // Olumlu kelimeler\n    const positiveWords = [\n      'iyi', 'güzel', 'harika', 'mükemmel', 'şahane', 'sevgi', 'sevmek',\n      'mutlu', 'mutluluk', 'başarı', 'başarılı', 'tebrik', 'teşekkür',\n      'gülmek', 'olumlu', 'pozitif', 'keyif', 'keyifli', 'neşe', 'neşeli'\n    ];\n\n    // Olumsuz kelimeler\n    const negativeWords = [\n      'kötü', 'kötülük', 'berbat', 'korkunç', 'üzgün', 'üzüntü', 'üzülmek',\n      'başarısız', 'başarısızlık', 'kaygı', 'stres', 'stresli', 'ağlamak',\n      'kızgın', 'öfke', 'nefret', 'olumsuz', 'negatif', 'sıkıntı', 'sıkıntılı'\n    ];\n\n    const words = content.toLowerCase().split(/\\s+/);\n\n    let score = 0;\n    for (const word of words) {\n      const cleanWord = word.replace(/[.,!?;:]/g, '');\n      if (positiveWords.includes(cleanWord)) {\n        score += 0.1;\n      }\n      if (negativeWords.includes(cleanWord)) {\n        score -= 0.1;\n      }\n    }\n\n    // -1 ile 1 arasında sınırlandır\n    return Math.max(-1, Math.min(1, score));\n  }\n\n  /**\n   * Anının kategorisini belirle\n   */\n  private categorizeMemory(content: string): string {\n    const categories = {\n      'kişisel': ['ben', 'benim', 'kendim', 'kişisel', 'bana', 'adım', 'yaşım'],\n      'teknoloji': ['bilgisayar', 'telefon', 'internet', 'yazılım', 'donanım', 'teknoloji', 'uygulama', 'program'],\n      'eğitim': ['okul', 'üniversite', 'öğrenmek', 'eğitim', 'öğretim', 'sınav', 'ders', 'kurs'],\n      'sağlık': ['hastane', 'doktor', 'ilaç', 'sağlık', 'hastalık', 'tedavi', 'iyileşmek'],\n      'yemek': ['yemek', 'yiyecek', 'içecek', 'restoran', 'kafe', 'mutfak', 'pişirmek', 'tarif'],\n      'seyahat': ['gezi', 'seyahat', 'tur', 'tatil', 'otel', 'uçak', 'tren', 'ülke', 'şehir'],\n      'sanat': ['müzik', 'film', 'kitap', 'resim', 'tiyatro', 'konser', 'sergi', 'sanat']\n    };\n\n    const content_lower = content.toLowerCase();\n    const matches: Record<string, number> = {};\n\n    // Kategorileri kontrol et\n    for (const [category, keywords] of Object.entries(categories)) {\n      matches[category] = 0;\n      for (const word of keywords) {\n        if (content_lower.includes(word)) {\n          matches[category]++;\n        }\n      }\n    }\n\n    // En fazla eşleşen kategoriyi bul\n    let maxMatches = 0;\n    let bestCategory = 'genel';\n\n    for (const [category, count] of Object.entries(matches)) {\n      if (count > maxMatches) {\n        maxMatches = count;\n        bestCategory = category;\n      }\n    }\n\n    return bestCategory;\n  }\n\n  /**\n   * Kısa vadeli belleği işle\n   */\n  private processShortTermMemories() {\n    // Kısa vadeli bellekte yeterince öğe varsa\n    if (this.shortTerm.length >= 5) {\n      // Bellek konsolidasyonunu yap\n      this.consolidateMemories();\n    }\n\n    // Unutma işlemini uygula\n    this.applyForgetting();\n  }\n\n  /**\n   * Uzun vadeli belleği konsolide et\n   */\n  private consolidateMemories() {\n    // İlgililiği yüksek kısa vadeli anıları uzun vadeli belleğe taşı\n    const highRelevanceMemories = this.shortTerm.filter(memory => \n      memory.relevance > 0.7 || (memory.emotionalState && Math.abs(memory.emotionalState) > 0.5)\n    );\n\n    for (const memory of highRelevanceMemories) {\n      // Anıyı uzun vadeli belleğe taşı\n      const longTermMemory: Memory = {\n        ...memory,\n        type: 'long-term',\n        learningCount: (memory.learningCount || 1) + 1\n      };\n\n      this.longTerm.push(longTermMemory);\n\n      // Kısa vadeli bellekten çıkar\n      this.shortTerm = this.shortTerm.filter(m => m.content !== memory.content);\n    }\n\n    // Uzun vadeli bellek limite ulaştıysa, en az ilgili olanları çıkar\n    if (this.longTerm.length > this.maxLongTerm) {\n      this.longTerm.sort((a, b) => a.relevance - b.relevance);\n      this.longTerm = this.longTerm.slice(this.longTerm.length - this.maxLongTerm);\n    }\n  }\n\n  /**\n   * Hafıza kümelerini güncelle\n   */\n  private updateMemoryClusters(memory: Memory) {\n    // Gelişmiş kelime analizi\n    const cleanContent = memory.content.toLowerCase()\n      .replace(/[.,!?;:]/g, ' ')\n      .replace(/\\s+/g, ' ')\n      .trim();\n\n    // Önemli kelimeleri ve kontekst bilgisini çıkar\n    const words = cleanContent.split(' ').filter(word => \n      word.length > 2 && !['daha', 'sonra', 'önce', 'şimdi', 'kadar', 'gibi', 'olan', 'için', 'ama', 'fakat', 'veya', 'ile'].includes(word)\n    );\n\n    // Kelime gruplarını ve ilişkilerini analiz et\n    const wordGroups = this.analyzeWordGroups(words);\n\n    // Anlam haritası oluştur\n    const semanticMap = this.createSemanticMap(words, memory.context || '');\n\n    // Anıyı mevcut kümelerle karşılaştır\n    let bestClusterMatch = {\n      cluster: null as MemoryCluster | null,\n      matchScore: 0\n    };\n\n    for (const cluster of this.memoryClusters) {\n      // Küme konusu ve kelimeler arası benzerlik skoru\n      let matchScore = 0;\n\n      // Küme konusu ile doğrudan eşleşme\n      if (words.includes(cluster.topic)) {\n        matchScore += 2;\n      }\n\n      // Küme anılarıyla içerik benzerlikleri\n      for (const clusterMemory of cluster.memories) {\n        const clusterWords = clusterMemory.content.toLowerCase().split(/\\s+/);\n\n        for (const word of words) {\n          if (clusterWords.includes(word)) {\n            matchScore += 0.5;\n          }\n        }\n      }\n\n      // Bu küme daha iyi eşleşiyorsa kaydet\n      if (matchScore > bestClusterMatch.matchScore) {\n        bestClusterMatch = {\n          cluster,\n          matchScore\n        };\n      }\n    }\n\n    // Yeterli benzerlik varsa mevcut kümeye ekle\n    if (bestClusterMatch.matchScore > 2 && bestClusterMatch.cluster) {\n      bestClusterMatch.cluster.memories.push(memory);\n      bestClusterMatch.cluster.strength += 0.2;\n      bestClusterMatch.cluster.lastAccessed = Date.now();\n\n      // Küme boyutu sınırlandırması\n      if (bestClusterMatch.cluster.memories.length > 15) {\n        bestClusterMatch.cluster.memories.sort((a, b) => a.relevance - b.relevance);\n        bestClusterMatch.cluster.memories = bestClusterMatch.cluster.memories.slice(-15);\n      }\n    } \n    // Yeni küme oluştur\n    else if (words.length > 0) {\n      // En önemli kelimeyi küme konusu olarak seç\n      const topic = words.reduce((a, b) => a.length > b.length ? a : b);\n\n      // Yeni küme oluştur\n      const newCluster: MemoryCluster = {\n        id: Date.now().toString(36) + Math.random().toString(36).substring(2),\n        topic,\n        memories: [memory],\n        strength: 1,\n        createdAt: Date.now(),\n        lastAccessed: Date.now()\n      };\n\n      this.memoryClusters.push(newCluster);\n\n      // Küme limiti kontrolü\n      if (this.memoryClusters.length > this.maxClusters) {\n        // En zayıf kümeyi çıkar\n        this.memoryClusters.sort((a, b) => a.strength - b.strength);\n        this.memoryClusters.shift();\n      }\n    }\n  }\n\n  /**\n   * Benzer anıları bul - Kullanıcı öğretimi için optimize edilmiş\n   */\n  findSimilarMemories(content: string, limit: number = 5): Memory[] {\n    // Tüm anıları topla\n    const allMemories = [...this.shortTerm, ...this.longTerm];\n\n    // İçeriğin kelimelerini al\n    const queryWords = content.toLowerCase().split(/\\s+/).filter(w => w.length > 2);\n\n    // Anıları gelişmiş benzerlik puanlarıyla eşleştir\n    const scoredMemories = allMemories.map(memory => {\n      let similarityScore = 0;\n      \n      // Anı içeriğinin kelimelerini al\n      const memoryWords = memory.content.toLowerCase().split(/\\s+/).filter(w => w.length > 2);\n\n      // 1. Tam kelime eşleşmesi\n      for (const queryWord of queryWords) {\n        if (memoryWords.includes(queryWord)) {\n          similarityScore += 2;\n        }\n      }\n\n      // 2. Kullanıcı öğretimi anılarına öncelik ver\n      if (memory.type === 'kullanıcı_öğretimi') {\n        similarityScore += 5;\n      }\n\n      // 3. Soru türü benzerliği\n      const questionTypeSimilarity = this.calculateQuestionTypeSimilarity(content, memory.content);\n      similarityScore += questionTypeSimilarity * 3;\n\n      // 4. Kısmi kelime eşleşmesi\n      for (const queryWord of queryWords) {\n        for (const memoryWord of memoryWords) {\n          if (queryWord.includes(memoryWord) || memoryWord.includes(queryWord)) {\n            if (Math.abs(queryWord.length - memoryWord.length) <= 2) {\n              similarityScore += 0.5;\n            }\n          }\n        }\n      }\n\n      // 5. Bağlamsal eşleşme\n      if (memory.context && content.toLowerCase().includes(memory.context.toLowerCase())) {\n        similarityScore += 3;\n      }\n\n      // 6. Kategori eşleşmesi\n      const queryCategory = this.categorizeMemory(content);\n      if (memory.category === queryCategory) {\n        similarityScore += 1.5;\n      }\n\n      // 7. Semantik etiket eşleşmesi (eğer varsa)\n      if (memory.semanticClusters) {\n        const querySemanticTags = this.extractSemanticTags(content);\n        const commonTags = memory.semanticClusters.filter(tag => \n          querySemanticTags.includes(tag)\n        ).length;\n        similarityScore += commonTags * 2;\n      }\n\n      // 8. Yakınlık temelli eşleşme (Levenshtein benzeri)\n      const contentSimilarity = this.calculateContentSimilarity(content, memory.content);\n      similarityScore += contentSimilarity * 2;\n\n      return {\n        memory,\n        score: similarityScore\n      };\n    });\n\n    // Benzerlik puanına göre sırala ve en benzer olanları seç\n    scoredMemories.sort((a, b) => b.score - a.score);\n\n    // Minimum eşik belirle (daha esnek)\n    const relevantMemories = scoredMemories.filter(item => item.score > 0.5);\n\n    // En ilgili olanları döndür\n    return relevantMemories.slice(0, limit).map(item => item.memory);\n  }\n\n  /**\n   * Soru türü benzerliği hesapla\n   */\n  private calculateQuestionTypeSimilarity(text1: string, text2: string): number {\n    const questionPatterns = {\n      'tanım': ['nedir', 'ne demek', 'ne anlama gelir', 'anlamı nedir'],\n      'kişi': ['kimdir', 'kim', 'kimin'],\n      'yer': ['nerede', 'neresi', 'neresidir', 'hangi yerde'],\n      'zaman': ['ne zaman', 'hangi zaman', 'kaçta'],\n      'yöntem': ['nasıl', 'nasıl yapılır', 'ne şekilde']\n    };\n\n    const getQuestionType = (text: string): string | null => {\n      const lowerText = text.toLowerCase();\n      for (const [type, patterns] of Object.entries(questionPatterns)) {\n        if (patterns.some(pattern => lowerText.includes(pattern))) {\n          return type;\n        }\n      }\n      return null;\n    };\n\n    const type1 = getQuestionType(text1);\n    const type2 = getQuestionType(text2);\n\n    if (type1 && type2 && type1 === type2) {\n      return 1.0;\n    }\n\n    return 0;\n  }\n\n  /**\n   * İçerik benzerliği hesapla\n   */\n  private calculateContentSimilarity(content1: string, content2: string): number {\n    const words1 = content1.toLowerCase().split(/\\s+/).filter(w => w.length > 2);\n    const words2 = content2.toLowerCase().split(/\\s+/).filter(w => w.length > 2);\n\n    if (words1.length === 0 || words2.length === 0) return 0;\n\n    const intersection = words1.filter(w => words2.includes(w)).length;\n    const union = new Set([...words1, ...words2]).size;\n\n    return union > 0 ? intersection / union : 0;\n  }\n\n  /**\n   * Semantik etiketler çıkar\n   */\n  private extractSemanticTags(content: string): string[] {\n    const tags: string[] = [];\n    const lowerContent = content.toLowerCase();\n    \n    // Soru türü etiketleri\n    if (lowerContent.includes('nedir') || lowerContent.includes('ne demek')) {\n      tags.push('tanım_sorusu');\n    }\n    if (lowerContent.includes('kimdir') || lowerContent.includes('kim')) {\n      tags.push('kişi_sorusu');\n    }\n    if (lowerContent.includes('nerede') || lowerContent.includes('neresi')) {\n      tags.push('yer_sorusu');\n    }\n    if (lowerContent.includes('nasıl')) {\n      tags.push('yöntem_sorusu');\n    }\n    if (lowerContent.includes('ne zaman')) {\n      tags.push('zaman_sorusu');\n    }\n    \n    // Önemli kelimeleri etiket olarak ekle\n    const words = content.split(/\\s+/)\n      .map(w => w.toLowerCase().replace(/[?!.,]/g, ''))\n      .filter(w => w.length > 2)\n      .filter(w => !['nedir', 'ne', 'demek', 'kim', 'kimdir', 'nerede', 'neresi', 'nasıl', 'zaman', 'için', 'ile', 'bir', 'bu', 'şu'].includes(w));\n    \n    tags.push(...words);\n    \n    return tags;\n  }\n\n  /**\n   * Verilen sorguyla ilgili anıları getir ve öğrenme sağla\n   */\n  getContextualMemories(query: string): Memory[] {\n    // Sorguyu kaydet\n    this.lastQuery = query;\n\n    // İlgili anıları bul\n    const relatedMemories = this.findSimilarMemories(query, 5);\n\n    // Anıları işaretle (kullanıldı olarak)\n    for (const memory of relatedMemories) {\n      this.reinforceMemory(memory.content, 0.1);\n    }\n\n    return relatedMemories;\n  }\n\n  /**\n   * Kişisel bağlam tanıma: Kullanıcının geçmiş sorguları ve kişisel referansları\n   * Bu fonksiyon, kullanıcının \"daha önce konuşmuştuk\", \"geçen sefer\", \"benim adım\" gibi\n   * kişisel referansları algılar ve uygun bağlamı tanımlar.\n   */\n  identifyPersonalContext(query: string): { \n    isPersonal: boolean, \n    relatedMemories: Memory[],\n    contextType: 'previous_question' | 'preference' | 'personal_info' | 'general',\n    personalReferences: string[]\n  } {\n    // Soru bağlamını anlama - tek kelimelik sorular için önceki bağlamı kontrol et\n    const questionWords = ['nerede', 'ne', 'kim', 'nasıl', 'nedir', 'kaç'];\n    const isSimpleQuestion = questionWords.some(word => query.toLowerCase().trim() === word);\n\n    if (isSimpleQuestion && this.lastQuery) {\n      // Son konuşma bağlamını al\n      const lastContext = this.getContextualMemories(this.lastQuery);\n      if (lastContext.length > 0) {\n        query = `${lastContext[0].content} ${query}`;\n      }\n    }\n\n    // Zaman referanslarını tespit et (önceki konuşmaların işaretçileri)\n    const timeReferenceRegex = /(daha önce|geçen|dün|önceki|son|geçenlerde|hatırlıyor|söylemiştim|sormuştum)/i;\n    const hasTimeReference = timeReferenceRegex.test(query);\n\n    // Zaman referansı içeren kelimeyi bul\n    const timeReferenceMatch = query.match(timeReferenceRegex);\n    const timeReference = timeReferenceMatch ? timeReferenceMatch[0] : \"\";\n\n    // Zamirsel ifadeleri tespit et (ben, benim, bana vs.)\n    const personalPronounRegex = /(ben|benim|bana|benimle|bende|adım|ismim|yaşım|yaşımı)/i;\n    const hasPersonalPronouns = personalPronounRegex.test(query);\n\n    // Kişisel zamir içeren kelimeyi bul\n    const pronounMatch = query.match(personalPronounRegex);\n    const personalPronoun = pronounMatch ? pronounMatch[0] : \"\";\n\n    // Tercih işaretçilerini tespit et (hoşlanırım, severim, tercih ederim vs.)\n    const preferenceRegex = /(severim|hoşlanırım|tercih|isterim|istemem|beğenirim|beğenmem|nefret)/i;\n    const hasPreference = preferenceRegex.test(query);\n\n    // Tercih içeren kelimeyi bul\n    const preferenceMatch = query.match(preferenceRegex);\n    const preference = preferenceMatch ? preferenceMatch[0] : \"\";\n\n    // Bağlamla ilgili anıları getir\n    const memories = this.getContextualMemories(query);\n\n    // Kişisel referansları topla\n    const personalReferences: string[] = [];\n    if (timeReference) personalReferences.push(timeReference);\n    if (personalPronoun) personalReferences.push(personalPronoun);\n    if (preference) personalReferences.push(preference);\n\n    // Bağlam türünü belirle\n    let contextType: 'previous_question' | 'preference' | 'personal_info' | 'general' = 'general';\n\n    if (hasTimeReference) {\n      contextType = 'previous_question';\n    } else if (hasPreference) {\n      contextType = 'preference';\n    } else if (hasPersonalPronouns) {\n      contextType = 'personal_info';\n    }\n\n    return {\n      isPersonal: hasTimeReference || hasPersonalPronouns || hasPreference,\n      relatedMemories: memories,\n      contextType,\n      personalReferences\n    };\n  }\n\n  /**\n   * Kullanıcı profili oluşturma ve güncelleme\n   */\n  updateUserProfile(personalInfo: string) {\n    // Kişisel bilgiyi uzun vadeli belleğe ekle\n    this.addMemory(personalInfo, 'personal_info');\n    \n    // Profil özetini güncelle\n    const profileSummary = this.generateUserProfileSummary();\n    if (profileSummary) {\n      this.addMemory(`Kullanıcı profil özeti: ${profileSummary}`, 'long-term');\n    }\n  }\n\n  /**\n   * Kullanıcı profil özeti oluşturma\n   */\n  generateUserProfileSummary(): string {\n    const personalMemories = this.longTerm.filter(\n      memory => memory.type === 'long-term' && memory.content.includes('Kullanıcının')\n    );\n    \n    if (personalMemories.length === 0) return '';\n    \n    const profileParts: string[] = [];\n    \n    personalMemories.forEach(memory => {\n      if (memory.content.includes('Kullanıcının adı:')) {\n        const name = memory.content.split('Kullanıcının adı:')[1]?.trim();\n        if (name) profileParts.push(`Adı ${name}`);\n      }\n      if (memory.content.includes('Kullanıcının yaşı:')) {\n        const age = memory.content.split('Kullanıcının yaşı:')[1]?.trim();\n        if (age) profileParts.push(`${age} yaşında`);\n      }\n      if (memory.content.includes('Kullanıcının mesleği:')) {\n        const job = memory.content.split('Kullanıcının mesleği:')[1]?.trim();\n        if (job) profileParts.push(`${job} olarak çalışıyor`);\n      }\n      if (memory.content.includes('Kullanıcının konumu:')) {\n        const location = memory.content.split('Kullanıcının konumu:')[1]?.trim();\n        if (location) profileParts.push(`${location}'de yaşıyor`);\n      }\n      if (memory.content.includes('Kullanıcının hobisi:')) {\n        const hobby = memory.content.split('Kullanıcının hobisi:')[1]?.trim();\n        if (hobby) profileParts.push(`${hobby} yapmayı seviyor`);\n      }\n    });\n    \n    return profileParts.join(', ');\n  }\n\n  /**\n   * Önceki konuşmaları hatırlama\n   */\n  rememberPreviousConversations(query: string): string[] {\n    const sessionId = this.sessionId;\n    const previousSessions = this.longTerm.filter(\n      memory => memory.sessionId !== sessionId && \n                memory.content.toLowerCase().includes(query.toLowerCase().split(' ')[0])\n    );\n    \n    return previousSessions.slice(-3).map(memory => memory.content);\n  }\n\n  /**\n   * Kullanıcının geçmiş etkileşimlerini analiz ederek kişisel bağlam oluştur\n   * @param query Kullanıcının mevcut sorusu/mesajı\n   * @returns Kişiselleştirilmiş bağlam bilgisi\n   */\n  generatePersonalizedContext(query: string): string {\n    const contextInfo = this.identifyPersonalContext(query);\n    let contextResponse = \"\";\n\n    // Eğer kişisel bir referans varsa\n    if (contextInfo.isPersonal) {\n      switch (contextInfo.contextType) {\n        case 'previous_question':\n          // Önceki sorularla ilgili bağlam oluştur\n          if (contextInfo.relatedMemories.length > 0) {\n            const recentMemories = contextInfo.relatedMemories.slice(0, 2);\n            contextResponse = `${recentMemories[0].content} `;\n          }\n          break;\n\n        case 'preference':\n          // Kullanıcı tercihlerine dair bağlam oluştur\n          const preferenceMemories = this.longTerm.filter(m => \n            m.content.toLowerCase().includes(\"severim\") || \n            m.content.toLowerCase().includes(\"hoşlanırım\") ||\n            m.content.toLowerCase().includes(\"tercih\")\n          );\n\n          if (preferenceMemories.length > 0) {\n            contextResponse = `${preferenceMemories[0].content} `;\n          }\n          break;\n\n        case 'personal_info':\n          // Kişisel bilgilerle ilgili bağlam oluştur\n          const personalInfoMemories = this.longTerm.filter(m => \n            m.content.toLowerCase().includes(\"adım\") || \n            m.content.toLowerCase().includes(\"yaşım\") ||\n            m.content.toLowerCase().includes(\"ismim\")\n          );\n\n          if (personalInfoMemories.length > 0) {\n            contextResponse = `${personalInfoMemories[0].content} `;\n          }\n          break;\n      }\n    }\n\n    // Genel bağlama dair anıları ekle\n    if (contextInfo.relatedMemories.length > 0 && !contextResponse) {\n      // Eğer cevap direkt olarak bulunmuşsa, sadece cevabı döndür\n      if (contextInfo.relatedMemories[0].content.includes(\"cevap\") ||\n          contextInfo.relatedMemories[0].content.includes(\"yanıt\")) {\n        contextResponse = `${contextInfo.relatedMemories[0].content} `;  \n      } else {\n        // Doğrudan içeriği döndür, \"Bu konuyla ilgili bildiğim:\" ifadesini kullanma\n        contextResponse = `${contextInfo.relatedMemories[0].content} `;\n      }\n    }\n\n    return contextResponse;\n  }\n\n  /**\n   * Anının önemini güçlendir veya azalt ve bağlantıları güncelle\n   */\n  reinforceMemory(content: string, adjustment: number) {\n    // Hem kısa hem uzun vadeli belleği güncelle\n    const updateMemory = (memory: Memory) => {\n      if (memory.content.toLowerCase() === content.toLowerCase()) {\n        // İlgililiği güncelle\n        memory.relevance = Math.min(1, Math.max(0.1, memory.relevance + adjustment));\n\n        // Öğrenme sayısını arttır\n        memory.learningCount = (memory.learningCount || 1) + 1;\n\n        // Son erişim zamanını güncelle\n        memory.timestamp = Date.now();\n      }\n    };\n\n    this.shortTerm.forEach(updateMemory);\n    this.longTerm.forEach(updateMemory);\n\n    // Değişiklikleri kaydet\n    this.saveMemories();\n  }\n\n  /**\n   * Unutma mekanizması - zamanla ilgililik düşürme\n   */\n  private applyForgetting() {\n    const now = Date.now();\n\n    // Kısa vadeli bellek daha hızlı unutur\n    this.shortTerm.forEach(memory => {\n      const daysPassed = (now - memory.timestamp) / (1000 * 60 * 60 * 24);\n\n      // Her gün için ilgililiği azalt\n      if (daysPassed > 0) {\n        memory.relevance = Math.max(0.1, memory.relevance - (this.forgettingRate * daysPassed));\n      }\n    });\n\n    // Uzun vadeli bellek daha yavaş unutur\n    this.longTerm.forEach(memory => {\n      const daysPassed = (now - memory.timestamp) / (1000 * 60 * 60 * 24);\n\n      // Her gün için ilgililiği azalt (daha yavaş bir oranda)\n      if (daysPassed > 0) {\n        memory.relevance = Math.max(0.1, memory.relevance - (this.forgettingRate * 0.3 * daysPassed));\n      }\n    });\n\n    // Kümeler de güç kaybeder\n    this.memoryClusters.forEach(cluster => {\n      const daysPassed = (now - cluster.lastAccessed) / (1000 * 60 * 60 * 24);\n\n      if (daysPassed > 0) {\n        cluster.strength = Math.max(0.2, cluster.strength - (this.forgettingRate * 0.5 * daysPassed));\n      }\n    });\n  }\n\n  /**\n   * Kısa vadeli bellekten uzun vadeli belleğe transfer (konsolidasyon)\n   */\n  consolidateShortTermMemories() {\n    // Kısa vadeli bellekten uzun vadeli belleğe transfer et\n    const memoriesToTransfer = this.shortTerm.filter(memory => \n      memory.relevance > 0.6 || (memory.emotionalState && Math.abs(memory.emotionalState) > 0.4)\n    );\n\n    memoriesToTransfer.forEach(memory => {\n      // Uzun vadeli belleğe ekle\n      this.longTerm.push({\n        ...memory,\n        type: 'long-term',\n        learningCount: (memory.learningCount || 1) + 1\n      });\n\n      // Kısa vadeli bellekten çıkar\n      this.shortTerm = this.shortTerm.filter(m => m.content !== memory.content);\n    });\n\n    // Değişiklikleri kaydet\n    this.saveMemories();\n\n    return memoriesToTransfer.length;\n  }\n\n  /**\n   * Günlük hatırlatmaları getir ve önemli anıları öner\n   */\n  getDailyReminders(): string[] {\n    // Anıları önem sırasına göre seç\n    const significantMemories = this.longTerm\n      .filter(memory => memory.relevance > 0.7 || (memory.emotionalState && Math.abs(memory.emotionalState) > 0.6))\n      .sort((a, b) => b.relevance - a.relevance)\n      .slice(0, 3);\n\n    // Kümelerdeki önemli konuları al\n    const significantClusters = this.memoryClusters\n      .filter(cluster => cluster.strength > 1.5)\n      .sort((a, b) => b.strength - a.strength)\n      .slice(0, 2);\n\n    // Hatırlatma metinleri oluştur\n    const reminders = significantMemories.map(memory => \n      `Hatırlatma: \"${memory.content}\" (${memory.category || 'genel'} kategorisi)`\n    );\n\n    // Küme hatırlatmaları\n    significantClusters.forEach(cluster => {\n      const topMemories = cluster.memories\n        .sort((a, b) => b.relevance - a.relevance)\n        .slice(0, 2)\n        .map(m => `\"${m.content}\"`);\n\n      reminders.push(`Konu: ${cluster.topic} - İlgili anılar: ${topMemories.join(', ')}`);\n    });\n\n    return reminders;\n  }\n\n  /**\n   * Metinden bilgi çıkar ve öğren\n   */\n  extractAndLearnFromText(text: string) {\n    // Metni cümlelere ayır\n    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);\n\n    // Bilgi çıkarma ve öğrenme - her cümleyi analiz et\n    for (const sentence of sentences) {\n      // Eğer bilgi cümlesi ise (özne ve yüklem içeriyorsa)\n      if (sentence.includes(' ') && sentence.trim().split(' ').length >= 3) {\n        this.addMemory(sentence.trim(), 'short-term');\n\n        // Varlık tanıma - özel isimler, yerler, kavramlar\n        const words = sentence.split(' ');\n        for (let i = 0; i < words.length; i++) {\n          const word = words[i].trim();\n\n          // Büyük harfle başlayan kelimeler (özel isimler)\n          if (word.length > 1 && /^[A-ZĞÜŞİÖÇ]/.test(word)) {\n            // İsmi ve bağlamı kaydet\n            const context = sentence.trim();\n            this.addMemory(`${word} bir varlıktır`, 'long-term', [], context);\n          }\n\n          // İki kelimelik önemli ifadeler\n          if (i < words.length - 1) {\n            const twoWordPhrase = `${word} ${words[i+1]}`.trim();\n            if (twoWordPhrase.length > 5 && !['bir şey', 'bu bir', 'şu bir'].includes(twoWordPhrase.toLowerCase())) {\n              this.addMemory(twoWordPhrase, 'short-term', [], sentence.trim());\n            }\n          }\n        }\n\n        // Basit soru-cevap çıkarımları üret\n        const questionPatterns = [\n          { pattern: /(\\w+) (?:ise|idi|olarak|oldu[^ğmk]) (.+)/i, template: \"$1 nedir?\", answer: \"$2\" },\n          { pattern: /(\\w+'[ın])n? (.+)/i, template: \"$1 $2 nedir?\", answer: sentence },\n          { pattern: /(\\w+) (\\w+)[ıiuü] (.+)/i, template: \"$1 $2 mı $3?\", answer: \"Evet, $1 $2\" },\n        ];\n\n        for (const { pattern, template, answer } of questionPatterns) {\n          const match = sentence.match(pattern);\n          if (match) {\n            // Basit bir soru oluştur\n            const question = template.replace(/\\$(\\d+)/g, (_, n) => match[parseInt(n)]);\n\n            // Cevabı oluştur\n            const answerText = answer.replace(/\\$(\\d+)/g, (_, n) => match[parseInt(n)]);\n\n            // Soru-cevap çiftini uzun vadeli belleğe ekle\n            this.addMemory(`Soru: ${question} Cevap: ${answerText}`, 'long-term');\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Bellek sistemini JSON formatında dışa aktar\n   */\n  exportMemories() {\n    return {\n      shortTerm: this.shortTerm,\n      longTerm: this.longTerm,\n      memoryClusters: this.memoryClusters\n    };\n  }\n\n  /**\n   * Bellek verilerini içe aktar\n   */\n  importMemories(data: { shortTerm: Memory[];\n    longTerm: Memory[];\n    memoryClusters: MemoryCluster[];\n  }) {\n    if (data.shortTerm) this.shortTerm = data.shortTerm;\n    if (data.longTerm) this.longTerm = data.longTerm;\n    if (data.memoryClusters) this.memoryClusters = data.memoryClusters;\n\n    // Yeni verileri kaydet\n    this.saveMemories();\n  }\n\n  /**\n   * Bellekleri yerel depolamaya kaydet\n   */\n  private saveMemories() {\n    try {\n      // localStorage browser-only olduğu için kontrol ekleyelim\n      if (typeof window !== 'undefined' && window.localStorage) {\n        localStorage.setItem('memory_short_term', JSON.stringify(this.shortTerm));\n        localStorage.setItem('memory_long_term', JSON.stringify(this.longTerm));\n        localStorage.setItem('memory_clusters', JSON.stringify(this.memoryClusters));\n      }\n    } catch (error) {\n      console.error('Bellek kaydedilemedi:', error);\n    }\n  }\n\n  /**\n   * Bellekleri yerel depolamadan yükle\n   */\n  private loadMemories() {\n    try {\n      // localStorage browser-only olduğu için kontrol ekleyelim\n      if (typeof window !== 'undefined' && window.localStorage) {\n        const shortTerm = localStorage.getItem('memory_short_term');\n        const longTerm = localStorage.getItem('memory_long_term');\n        const clusters = localStorage.getItem('memory_clusters');\n\n        if (shortTerm) this.shortTerm = JSON.parse(shortTerm);\n        if (longTerm) this.longTerm = JSON.parse(longTerm);\n        if (clusters) this.memoryClusters = JSON.parse(clusters);\n      }\n    } catch (error) {\n      console.error('Bellek yüklenemedi:', error);\n    }\n  }\n\n  /**\n   * Tüm belleği temizle\n   */\n  clearMemory() {\n    this.shortTerm = [];\n    this.longTerm = [];\n    this.memoryClusters = [];\n\n    // localStorage browser-only olduğu için kontrol ekleyelim\n    if (typeof window !== 'undefined' && window.localStorage) {\n      localStorage.removeItem('memory_short_term');\n      localStorage.removeItem('memory_long_term');\n      localStorage.removeItem('memory_clusters');\n    }\n  }\n\n  removeMemory(content: string) {\n    try {\n      // Bellek sisteminden sil\n      const previousShortTermLength = this.shortTerm.length;      const previousLongTermLength = this.longTerm.length;\n\n      // Kısa ve uzun vadeli bellekten kaldır\n      this.shortTerm = this.shortTerm.filter(m => m.content !== content);\n      this.longTerm = this.longTerm.filter(m => m.content !== content);\n\n      // Silinen öğe sayısını kontrol et\n      const shortTermDeleted = previousShortTermLength - this.shortTerm.length;\n      const longTermDeleted = previousLongTermLength - this.longTerm.length;\n\n      // Kümelerden kaldır ve yeni küme listesi oluştur\n      const updatedClusters = this.memoryClusters.reduce((acc: MemoryCluster[], cluster) => {\n        const updatedCluster = {\n          ...cluster,\n          memories: cluster.memories.filter(m => m.content !== content)\n        };\n\n        // Sadece içinde anı olan kümeleri sakla\n        if (updatedCluster.memories.length > 0) {\n          acc.push(updatedCluster);\n        }\n        return acc;\n      }, []);\n\n      // Kümeleri güncelle\n      this.memoryClusters = updatedClusters;\n\n      // LocalStorage'ı güncelle\n      if (typeof window !== 'undefined' && window.localStorage) {\n        localStorage.setItem('memory_short_term', JSON.stringify(this.shortTerm));\n        localStorage.setItem('memory_long_term', JSON.stringify(this.longTerm));\n        localStorage.setItem('memory_clusters', JSON.stringify(this.memoryClusters));\n\n        // Sinir ağı verilerini güncelle\n        const userNetworksStr = localStorage.getItem('neural_user_networks');\n        const systemNetworksStr = localStorage.getItem('neural_system_networks');\n        const relationsStr = localStorage.getItem('neural_relations');\n        const biRelationsStr = localStorage.getItem('neural_bidirectional_relations');\n\n        if (userNetworksStr && systemNetworksStr && relationsStr && biRelationsStr) {\n          const words = content.toLowerCase().split(/\\s+/);\n\n          // Ağları parse et\n          let userNetworks = JSON.parse(userNetworksStr);\n          let systemNetworks = JSON.parse(systemNetworksStr);\n          let relations = JSON.parse(relationsStr);\n          let biRelations = JSON.parse(biRelationsStr);\n\n          // İlgili kelimeleri içeren düğümleri temizle\n          const cleanNetwork = (network: any[][][]) => {\n            return network.map(layer => \n              layer.map(row =>\n                row.map(node => {\n                  if (node && words.some(word => \n                    node.word.toLowerCase().includes(word) || \n                    word.includes(node.word.toLowerCase())\n                  )) {\n                    return null;\n                  }\n                  return node;\n                })\n              )\n            );\n          };\n\n          // Ağları temizle\n          userNetworks = cleanNetwork(userNetworks);\n          systemNetworks = cleanNetwork(systemNetworks);\n\n          // İlişkileri temizle\n          relations = relations.filter((rel: any) => \n            !words.some(word => \n              rel.userWord.toLowerCase().includes(word) || \n              rel.systemWord.toLowerCase().includes(word)\n            )\n          );\n\n          biRelations = biRelations.filter((rel: any) =>\n            !words.some(word => \n              rel.userWord.toLowerCase().includes(word) || \n              rel.systemWord.toLowerCase().includes(word)\n            )\n          );\n\n          // Güncellenmiş ağ verilerini kaydet\n          localStorage.setItem('neural_user_networks', JSON.stringify(userNetworks));\n          localStorage.setItem('neural_system_networks', JSON.stringify(systemNetworks));\n          localStorage.setItem('neural_relations', JSON.stringify(relations));\n          localStorage.setItem('neural_bidirectional_relations', JSON.stringify(biRelations));\n        }\n      }\n\n      // Silme işlemi başarılı oldu mu kontrol et\n      const totalDeleted = shortTermDeleted + longTermDeleted;\n      return totalDeleted > 0;\n\n    } catch (error) {\n      console.error('Hafıza silme hatası:', error);\n      return false;\n    }\n\n    // Sinir ağında ilgili düğümleri temizle\n    const words = content.toLowerCase().split(/\\s+/);\n    if (typeof window !== 'undefined' && window.localStorage) {\n      // Ağ verilerini al\n      const userNetworksStr = localStorage.getItem('neural_user_networks');\n      const systemNetworksStr = localStorage.getItem('neural_system_networks');\n      const relationsStr = localStorage.getItem('neural_relations');\n      const biRelationsStr = localStorage.getItem('neural_bidirectional_relations');\n\n      if (userNetworksStr && systemNetworksStr && relationsStr && biRelationsStr) {\n        let userNetworks = JSON.parse(userNetworksStr);\n        let systemNetworks = JSON.parse(systemNetworksStr);\n        let relations = JSON.parse(relationsStr);\n        let biRelations = JSON.parse(biRelationsStr);\n\n        // Düğümleri temizle\n        for (let layer = 0; layer < userNetworks.length; layer++) {\n          for (let row = 0; row < userNetworks[layer].length; row++) {\n            for (let col = 0; col < userNetworks[layer][0].length; col++) {\n              const node = userNetworks[layer][row][col];\n              if (node && words.includes(node.word.toLowerCase())) {\n                userNetworks[layer][row][col] = null;\n              }\n            }\n          }\n        }\n\n        for (let layer = 0; layer < systemNetworks.length; layer++) {\n          for (let row = 0; row < systemNetworks[layer].length; row++) {\n            for (let col = 0; col < systemNetworks[layer][0].length; col++) {\n              const node = systemNetworks[layer][row][col];\n              if (node && words.includes(node.word.toLowerCase())) {\n                systemNetworks[layer][row][col] = null;\n              }\n            }\n          }\n        }\n\n        // İlişkileri temizle\n        relations = relations.filter(rel => \n          !words.includes(rel.userWord.toLowerCase()) && \n          !words.includes(rel.systemWord.toLowerCase())\n        );\n\n        biRelations = biRelations.filter(rel =>\n          !words.includes(rel.userWord.toLowerCase()) && \n          !words.includes(rel.systemWord.toLowerCase())\n        );\n\n        // Güncellenmiş verileri kaydet\n        localStorage.setItem('neural_user_networks', JSON.stringify(userNetworks));\n        localStorage.setItem('neural_system_networks', JSON.stringify(systemNetworks));\n        localStorage.setItem('neural_relations', JSON.stringify(relations));\n        localStorage.setItem('neural_bidirectional_relations', JSON.stringify(biRelations));\n      }\n    }\n\n    // Değişiklikleri kaydet\n    this.saveMemories();\n  }\n\n  private analyzeWordGroups(words: string[]): {group: string[], weight: number}[] {\n    const groups: {group: string[], weight: number}[] = [];\n\n    // İkili ve üçlü kelime grupları oluştur\n    for(let i = 0; i < words.length; i++) {\n      // İkili gruplar\n      if(i < words.length - 1) {\n        groups.push({\n          group: [words[i], words[i+1]],\n          weight: 1.0\n        });\n      }\n\n      // Üçlü gruplar\n      if(i < words.length - 2) {\n        groups.push({\n          group: [words[i], words[i+1], words[i+2]],\n          weight: 1.5\n        });\n      }\n    }\n\n    return groups;\n  }\n\n  private createSemanticMap(words: string[], context: string): Map<string, Set<string>> {\n    const semanticMap = new Map<string, Set<string>>();\n\n    // Her kelime için gelişmiş anlamsal ilişkileri analiz et\n    words.forEach(word => {\n      const relations = new Set<string>();\n\n      // Mevcut kümelerdeki ilişkileri kontrol et\n      this.memoryClusters.forEach(cluster => {\n        // Küme içindeki tüm anılardan kelime ve bağlam bilgisi çıkar\n        const clusterContexts = cluster.memories.map(m => ({\n          words: m.content.toLowerCase().split(/\\s+/).filter(w => w.length > 2),\n          context: m.context || '',\n          emotionalState: m.emotionalState || null\n        }));\n\n        // Her bağlam için anlamsal analiz yap\n        clusterContexts.forEach(ctx => {\n          // Kelime benzerliği kontrolü\n          ctx.words.forEach(cWord => {\n            // Doğrudan kelime benzerliği\n            if(this.calculateWordSimilarity(word, cWord) > 0.7) {\n              relations.add(cWord);\n            }\n\n            // Eş anlamlı kelime kontrolü\n            const synonyms = this.findSynonyms(cWord);\n            if(synonyms.includes(word)) {\n              relations.add(cWord);\n            }\n\n            // Bağlamsal ilişki kontrolü\n            if(ctx.context && ctx.context.includes(word)) {\n              relations.add(cWord);\n            }\n\n            // Duygusal bağlam kontrolü\n            if(ctx.emotionalState && this.isEmotionallyRelated(word, cWord)) {\n              relations.add(cWord);\n            }\n          });\n        });\n\n        // Küme gücüne göre ilişki ağırlığını ayarla\n        if(cluster.strength > 2) {\n          cluster.topic.split(/\\s+/).forEach(topicWord => {\n            if(this.calculateWordSimilarity(word, topicWord) > 0.6) {\n              relations.add(topicWord);\n            }\n          });\n        }\n      });\n\n      semanticMap.set(word, relations);\n    });\n\n    return semanticMap;\n  }\n\n  private findSynonyms(word: string): string[] {\n    // Türkçe eş anlamlı kelimeler sözlüğü (basit örnek)\n    const synonymDict: Record<string, string[]> = {\n      'merhaba': ['selam', 'selamlar', 'hey'],\n      'iyi': ['güzel', 'hoş', 'olumlu'],\n      'kötü': ['fena', 'berbat', 'olumsuz'],\n      'büyük': ['geniş', 'kocaman', 'dev'],\n      'küçük': ['ufak', 'minik', 'minimal'],\n      // Daha fazla eş anlamlı kelime eklenebilir\n    };\n\n    return synonymDict[word] || [];\n  }\n\n  private isEmotionallyRelated(word1: string, word2: string): boolean {\n    // Duygusal kelime grupları\n    const emotionalGroups = {\n      positive: ['mutlu', 'sevinç', 'neşe', 'güzel', 'harika'],\n      negative: ['üzgün', 'kızgın', 'sinirli', 'kötü', 'berbat'],\n      neutral: ['normal', 'orta', 'standart', 'olağan'],\n    };\n\n    // İki kelimenin aynı duygusal grupta olup olmadığını kontrol et\n    for(const group of Object.values(emotionalGroups)) {\n      if(group.includes(word1) && group.includes(word2)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  analyzeSemantics(input: string): Memory['semanticAnalysis'] {\n    const words = input.toLowerCase().split(/\\s+/);\n    const analysis = {\n      words: words.map(word => {\n        const entry = this.turkishDictionary.getWord(word);\n        return {\n          word,\n          meaning: entry?.meaning[0] || '',\n          role: entry?.type || ''\n        };\n      }),\n      intent: '',\n      confidence: 0,\n      statistics: {\n        correctResponses: 0,\n        totalResponses: 0,\n        successRate: 0\n      },\n      expectedResponse: '',\n      semanticUnderstanding: {\n        components: [],\n        pattern: '',\n        confidence: 0\n      }\n    };\n\n    // Cümle analizi yap\n    const phraseAnalysis = this.turkishDictionary.analyzePhrase(input);\n\n    if (phraseAnalysis.understanding) {\n      analysis.intent = phraseAnalysis.understanding;\n      analysis.confidence = phraseAnalysis.confidence;\n\n      // İstatistikleri güncelle\n      const isCorrectResponse = phraseAnalysis.confidence > 0.8;\n      if (isCorrectResponse) {\n        analysis.statistics.correctResponses++;\n      }\n      analysis.statistics.totalResponses++;\n      analysis.statistics.successRate = \n        analysis.statistics.correctResponses / analysis.statistics.totalResponses;\n\n      // Anlamsal bileşenleri ekle\n      analysis.semanticUnderstanding = {\n        components: phraseAnalysis.words.map(word => ({\n          word: word.word,\n          role: word.type,\n          meaning: word.meaning[0]\n        })),\n        pattern: input,\n        confidence: phraseAnalysis.confidence\n      };\n\n      // Beklenen yanıtı ayarla\n      if (phraseAnalysis.semanticComponents?.expectedResponse) {\n        analysis.expectedResponse = phraseAnalysis.semanticComponents.expectedResponse;\n      }\n    }\n\n    // Sözcük gruplarını analiz et\n    const wordGroups = this.findWordGroups(words);\n\n    // Özel kalıpları kontrol et\n    for (const pattern of this.knownPatterns) {\n      if (pattern.matches(words)) {\n        analysis.intent = pattern.intent;\n        analysis.confidence = pattern.confidence;\n        analysis.expectedResponse = pattern.generateResponse(this);\n\n        // İstatistikleri güncelle\n        if (pattern.wasSuccessful) {\n          analysis.statistics.correctResponses++;\n        }\n        analysis.statistics.totalResponses++;\n        analysis.statistics.successRate = \n          analysis.statistics.correctResponses / analysis.statistics.totalResponses;\n\n        break;\n      }\n    }\n\n    // Özel durum analizi - \"adın ne\" kalıbı\n    if (input.toLowerCase().includes('adın ne')) {\n      analysis.intent = 'isim_sorma';\n      analysis.confidence = 0.95;\n      analysis.expectedResponse = 'Adım Yapay Zeka Robotu';\n    }\n\n    return analysis;\n  }\n\n  private findWordGroups(words: string[]): Array<{\n    words: string[],\n    meaning: string,\n    type: string\n  }> {\n    const groups = [];\n    for (let i = 0; i < words.length; i++) {\n      // İkili grupları kontrol et\n      if (i < words.length - 1) {\n        const twoWordPhrase = words[i] + ' ' + words[i + 1];\n        const entry = this.turkishDictionary.getPhrase(twoWordPhrase);\n        if (entry) {\n          groups.push({\n            words: [words[i], words[i + 1]],\n            meaning: entry.meaning,\n            type: entry.type\n          });\n        }\n      }\n    }\n    return groups;\n  }\n\n  private calculateWordSimilarity(word1: string, word2: string): number {\n    if(word1 === word2) return 1;\n\n    const len1 = word1.length;\n    const len2 = word2.length;\n\n    // Uzunluk farkı çok fazlaysa benzer değil\n    if(Math.abs(len1 - len2) > 3) return 0;\n\n    let matches = 0;\n    const maxLen = Math.max(len1, len2);\n\n    // Ortak karakterleri say\n    for(let i = 0; i < maxLen; i++) {\n      if(word1[i] === word2[i]) matches++;\n    }\n\n    return matches / maxLen;\n  }\n\n  /**\n   * Semantik kalıpları başlat\n   */\n  private initializeSemanticPatterns(): SemanticPattern[] {\n    return [\n      {\n        id: 'greeting',\n        pattern: ['merhaba', 'selam', 'selamün', 'günaydın'],\n        intent: 'selamlama',\n        confidence: 0.9,\n        wasSuccessful: true,\n        matches: (words: string[]) => {\n          return words.some(word => \n            ['merhaba', 'selam', 'selamün', 'günaydın', 'iyi akşamlar'].includes(word.toLowerCase())\n          );\n        },\n        generateResponse: (memorySystem: EnhancedMemorySystem) => {\n          const greetings = ['Merhaba!', 'Selam!', 'Merhaba, size nasıl yardımcı olabilirim?'];\n          return greetings[Math.floor(Math.random() * greetings.length)];\n        }\n      },\n      {\n        id: 'name_asking',\n        pattern: ['adın', 'ne', 'ismin'],\n        intent: 'isim_sorma',\n        confidence: 0.95,\n        wasSuccessful: true,\n        matches: (words: string[]) => {\n          const nameQuestions = ['adın ne', 'ismin ne', 'adınız ne'];\n          const sentence = words.join(' ').toLowerCase();\n          return nameQuestions.some(q => sentence.includes(q));\n        },\n        generateResponse: (memorySystem: EnhancedMemorySystem) => {\n          return 'Adım Yapay Zeka Asistanı. Size nasıl yardımcı olabilirim?';\n        }\n      },\n      {\n        id: 'how_are_you',\n        pattern: ['nasılsın', 'nasıl', 'naber'],\n        intent: 'hal_sorma',\n        confidence: 0.85,\n        wasSuccessful: true,\n        matches: (words: string[]) => {\n          return words.some(word => ['nasılsın', 'naber', 'nasıl'].includes(word.toLowerCase()));\n        },\n        generateResponse: (memorySystem: EnhancedMemorySystem) => {\n          return 'İyiyim, teşekkür ederim! Siz nasılsınız?';\n        }\n      },\n      {\n        id: 'what_is',\n        pattern: ['nedir', 'ne demek'],\n        intent: 'tanım_sorma',\n        confidence: 0.8,\n        wasSuccessful: true,\n        matches: (words: string[]) => {\n          const sentence = words.join(' ').toLowerCase();\n          return sentence.includes('nedir') || sentence.includes('ne demek');\n        },\n        generateResponse: (memorySystem: EnhancedMemorySystem) => {\n          return 'Bu konuda size yardımcı olmaya çalışacağım.';\n        }\n      }\n    ];\n  }\n\n    createConsciousnessMemory(input: string) {\n        // Farkındalık anısı oluşturma\n        const memory: Memory = {\n            content: `Bilinçlenme: ${input}`,\n            timestamp: Date.now(),\n            relevance: 0.8,\n            type: 'anlamlandirma',\n            related: [],\n            semanticClusters: [],\n            sessionId: this.sessionId\n        } as any;\n        this.longTerm.push(memory);\n        this.saveMemories();\n    }\n\n    enhanceConsciousness(input: string, domain: string) {\n        // Bilinçlenme arttırma\n        const memory: Memory = {\n            content: `Bilinçlenme arttırıldı: ${input}, alan: ${domain}`,\n            timestamp: Date.now(),\n            relevance: 0.7,\n            type: 'anlamlandirma',\n            related: [],\n            semanticClusters: [],\n            sessionId: this.sessionId\n        } as any;\n        this.longTerm.push(memory);\n        this.saveMemories();\n    }\n\n    getConsciousnessState() {\n        // Bilinç durumu\n        let overallAwareness = 0;\n        const consciousnessMemories = this.longTerm.filter(m => m.type === 'anlamlandirma');\n        if (consciousnessMemories.length > 0) {\n            overallAwareness = consciousnessMemories.reduce((acc, m) => acc + m.relevance, 0) / consciousnessMemories.length;\n        }\n        \n        // Bilinç seviyesini belirle\n        let level = 'basic';\n        if (overallAwareness > 0.5) level = 'intermediate';\n        if (overallAwareness > 0.8) level = 'advanced';\n        \n        // Son içgörüler ve yansımalar\n        const insights = this.longTerm\n            .filter(m => m.type === 'anlamlandirma' && m.content.includes('içgörü'))\n            .slice(-3)\n            .map(m => m.content.substring(0, 50));\n            \n        const reflections = this.longTerm\n            .filter(m => m.type === 'anlamlandirma' && m.content.includes('düşünce'))\n            .slice(-3)\n            .map(m => m.content.substring(0, 50));\n            \n        // Gelişim alanları\n        const domains = Array.from(new Set(\n            this.longTerm\n                .filter(m => m.type === 'anlamlandirma')\n                .flatMap(m => m.semanticClusters || [])\n        )).slice(0, 5);\n        \n        return {\n            overallAwareness,\n            level,\n            insights,\n            reflections,\n            domains\n        };\n    }\n    \n    /**\n     * Uzun konuşma oluştur - hafızadaki bilgilerden anlamlı paragraflar oluştur\n     * @param topic Konu (isteğe bağlı)\n     * @param sentenceCount İstenen cümle sayısı\n     */\n    generateLongConversationDetail(topic?: string, sentenceCount: number = 5): string {\n        // İlgili anıları seç\n        let relevantMemories = this.longTerm;\n        \n        // Eğer konu belirtilmişse, o konuyla ilgili anıları filtrele\n        if (topic) {\n            relevantMemories = relevantMemories.filter(memory => {\n                // Konu içeriğinde geçiyorsa\n                if (memory.content.toLowerCase().includes(topic.toLowerCase())) {\n                    return true;\n                }\n                \n                // Semantik kümelerde geçiyorsa\n                if (memory.semanticClusters && memory.semanticClusters.some(\n                    c => c.toLowerCase().includes(topic.toLowerCase())\n                )) {\n                    return true;\n                }\n                \n                return false;\n            });\n        }\n        \n        // Yeterli anı yoksa, tüm anıları kullan\n        if (relevantMemories.length < sentenceCount) {\n            relevantMemories = this.longTerm;\n        }\n        \n        // Anıları önem sırasına göre sırala ve en önemlilerini seç\n        relevantMemories = relevantMemories\n            .sort((a, b) => b.relevance - a.relevance)\n            .slice(0, Math.min(30, relevantMemories.length));\n            \n        // Rastgele karıştır\n        relevantMemories = relevantMemories.sort(() => Math.random() - 0.5);\n        \n        // Gereken cümle sayısını seç\n        const selectedMemories = relevantMemories.slice(0, sentenceCount);\n        \n        // Eğer yeterli anı yoksa, kalan cümleleri oluştur\n        while (selectedMemories.length < sentenceCount) {\n            // Varsayılan cümleler\n            const defaultSentences = [\n                \"Bu konu hakkında daha fazla bilgi edinmek önemlidir.\",\n                \"Farklı bakış açıları bize yeni anlayışlar kazandırabilir.\",\n                \"Sürekli öğrenme ve gelişim hayatın temel bir parçasıdır.\",\n                \"Bilgi paylaştıkça çoğalır ve değer kazanır.\",\n                \"Merak, öğrenmenin başlangıcıdır.\"\n            ];\n            \n            selectedMemories.push({\n                content: defaultSentences[Math.floor(Math.random() * defaultSentences.length)],\n                relevance: 0.5,\n                timestamp: Date.now()\n            } as any);\n        }\n        \n        // Cümleleri çıkar (sadece ilk cümleyi al - nokta ile biten kısım)\n        let sentences = selectedMemories.map(memory => {\n            // Cümleyi nokta, ünlem veya soru işaretine kadar al\n            const sentenceMatch = memory.content.match(/^(.*?[.!?])/);\n            if (sentenceMatch && sentenceMatch[1]) {\n                return sentenceMatch[1].trim();\n            }\n            \n            // Eğer noktalama işareti yoksa, tüm içeriği al\n            return memory.content.trim();\n        });\n        \n        // Cümleleri birleştir ve anlamlı bir paragraf oluştur\n        let paragraph = sentences.join(' ');\n        \n        // Eğer bir konu belirtilmişse, konuyla başla\n        if (topic) {\n            const topicIntros = [\n                `${topic} konusunda, `,\n                `${topic} hakkında düşünürsek, `,\n                `${topic} ile ilgili olarak, `,\n                `${topic} bağlamında, `\n            ];\n            \n            paragraph = topicIntros[Math.floor(Math.random() * topicIntros.length)] + paragraph;\n        }\n        \n        return paragraph;\n    }\n    \n    /**\n     * Ağı otomatik olarak geliştirme ve yeni özellikler ekleme\n     * @param learningRate Öğrenme hızı (0-1 arası)\n     * @param expansionRate Genişleme hızı (0-1 arası)\n     * @returns Geliştirme sonuçları\n     */\n    autoEvolveLearning(learningRate: number = 0.5, expansionRate: number = 0.3) {\n        // Öğrenme geliştirmesi\n        const now = Date.now();\n        const oneWeekAgo = now - (7 * 24 * 60 * 60 * 1000);\n        \n        // Son 1 haftadaki bellekleri analiz et\n        const recentMemories = this.longTerm.filter(m => m.timestamp > oneWeekAgo);\n        \n        // Sık kullanılan kelime ve kavramları tespit et\n        const wordFrequency: Record<string, number> = {};\n        const conceptsDetected: Set<string> = new Set();\n        \n        // Kelime frekansını hesapla\n        recentMemories.forEach(memory => {\n            const words = memory.content.toLowerCase().split(/\\s+/);\n            words.forEach(word => {\n                if (word.length > 3) {\n                    wordFrequency[word] = (wordFrequency[word] || 0) + 1;\n                    \n                    // Belirli bir eşiği geçen kelimeleri kavram olarak ele al\n                    if (wordFrequency[word] > 5) {\n                        conceptsDetected.add(word);\n                    }\n                }\n            });\n        });\n        \n        // Yeni kavramlar için semantik kümeler oluştur\n        const newClusters: MemoryCluster[] = [];\n        Array.from(conceptsDetected).forEach(concept => {\n            // Bu kavram için zaten bir küme var mı kontrol et\n            const existingCluster = this.memoryClusters.find(c => \n                c.topic.toLowerCase() === concept || \n                c.topic.toLowerCase().includes(concept)\n            );\n            \n            if (!existingCluster && Math.random() < expansionRate) {\n                // Kavramla ilgili belekleri topla\n                const relatedMemories = recentMemories.filter(m => \n                    m.content.toLowerCase().includes(concept)\n                );\n                \n                if (relatedMemories.length >= 2) {\n                    // Yeni küme oluştur\n                    const newCluster: MemoryCluster = {\n                        id: `auto_${Date.now().toString(36)}_${concept}`,\n                        topic: concept,\n                        memories: relatedMemories,\n                        strength: 0.7,\n                        createdAt: now,\n                        lastAccessed: now\n                    };\n                    \n                    newClusters.push(newCluster);\n                    \n                    // Otomatik öğrenme kaydı\n                    const learningMemory: Memory = {\n                        content: `Otomatik öğrenme: \"${concept}\" kavramı için yeni küme oluşturuldu.`,\n                        timestamp: now,\n                        relevance: 0.8,\n                        type: 'anlamlandirma',\n                        related: [concept],\n                        context: `Otomatik öğrenme süreci`,\n                        semanticClusters: [concept],\n                        sessionId: this.sessionId\n                    } as any;\n                    \n                    this.longTerm.push(learningMemory);\n                }\n            }\n        });\n        \n        // Yeni kümeleri ekle\n        this.memoryClusters = [...this.memoryClusters, ...newClusters];\n        \n        // Eğer küme limitini aşıyorsak, en zayıf kümeleri çıkar\n        if (this.memoryClusters.length > this.maxClusters) {\n            this.memoryClusters.sort((a, b) => a.strength - b.strength);\n            this.memoryClusters = this.memoryClusters.slice(this.memoryClusters.length - this.maxClusters);\n        }\n        \n        // Verileri kaydet\n        this.saveMemories();\n        \n        // Gelişim sonuçlarını döndür\n        return {\n            newClustersCreated: newClusters.length,\n            conceptsDetected: conceptsDetected.size,\n            memoriesAnalyzed: recentMemories.length,\n            evolutionStage: 'expanding', // genişleme, optimizasyon, konsolidasyon veya uzmanlaşma\n            newSemanticConnections: newClusters.length * 3, // Tahmini yeni semantik bağlantı sayısı\n            learningEfficiency: 0.7 + (Math.random() * 0.3), // 0-1 arası bir değer\n            timestamp: now\n        };\n    }\n    \n    /**\n     * Yeni semantik kavramlar öğrenme ve ağı otomatik olarak genişletme\n     * @param semanticInput Öğrenilecek semantik girdi (örn. yeni bir bilgi metni)\n     * @returns Öğrenme sonuçları\n     */\n    learnSemanticConcepts(semanticInput: string) {\n        // Semantik girdiden kelimeler ve cümleler çıkar\n        const sentences = semanticInput.split(/[.!?]+/g).filter(s => s.trim().length > 5);\n        const words = semanticInput.toLowerCase().split(/\\s+/).filter(w => w.length > 3);\n        \n        // Yeni kavramları belirle\n        const uniqueWords = new Set(words);\n        \n        // Her cümle için yeni bir anı oluştur\n        let sentencesLearned = 0;\n        sentences.forEach(sentence => {\n            if (sentence.trim().length > 10) {\n                // Cümleyi kısa vadeli belleğe ekle\n                this.addMemory(sentence.trim(), 'short-term');\n                sentencesLearned++;\n                \n                // Cümledeki önemli kavramları analiz et\n                const sentenceWords = sentence.toLowerCase().split(/\\s+/).filter(w => w.length > 3);\n                const mainConcepts = sentenceWords.filter(w => \n                    // İsimler, fiiller ve önemli sıfatlar\n                    !['ve', 'veya', 'ile', 'için', 'gibi', 'kadar', 'daha', 'çok', 'az'].includes(w)\n                );\n                \n                // Önemli kavramların birbiriyle ilişkilerini öğren\n                if (mainConcepts.length >= 2) {\n                    for (let i = 0; i < mainConcepts.length; i++) {\n                        for (let j = i + 1; j < mainConcepts.length; j++) {\n                            const concept1 = mainConcepts[i];\n                            const concept2 = mainConcepts[j];\n                            \n                            // Kavramlar arası ilişkiyi belleğe ekle\n                            this.addMemory(\n                                `\"${concept1}\" ve \"${concept2}\" kavramları ilişkilidir.`,\n                                'anlamlandirma',\n                                [concept1, concept2],\n                                sentence.trim()\n                            );\n                        }\n                    }\n                }\n            }\n        });\n        \n        // Sürekli gelişim için kısa vadeli belleği uzun vadeli belleğe taşı\n        this.consolidateShortTermMemories();\n        \n        return {\n            wordsLearned: uniqueWords.size,\n            sentencesLearned,\n            conceptsRelated: sentences.length * 2, // Tahmini ilişki sayısı\n            memoryEfficiency: Math.min(1, (sentencesLearned / sentences.length) + 0.2),\n            timestamp: Date.now()\n        };\n    }\n    \n    /**\n     * Uzun konuşma üretme - hafızadaki bilgilerden anlamlı paragraflar oluşturun\n     * @param topic Paragrafın konusu (isteğe bağlı)\n     * @param sentenceCount Oluşturulacak cümle sayısı\n     * @returns Oluşturulan paragraf\n     */\n    generateLongConversation(topic?: string, sentenceCount: number = 7): string {\n        // 1. İlgili belleği bul\n        let relevantMemories: Memory[] = [];\n        \n        if (topic) {\n            // Konuyla ilgili anıları getir\n            relevantMemories = this.findSimilarMemories(topic, 15);\n        } else {\n            // Rastgele kümeleri seç\n            const clusters = this.memoryClusters\n                .sort(() => Math.random() - 0.5)\n                .slice(0, 3);\n                \n            // Küme anılarını birleştir\n            for (const cluster of clusters) {\n                relevantMemories = [...relevantMemories, ...cluster.memories];\n            }\n            \n            // Yeterli anı yoksa, en önemli anıları ekle\n            if (relevantMemories.length < 10) {\n                const importantMemories = this.longTerm\n                    .sort((a, b) => b.relevance - a.relevance)\n                    .slice(0, 10);\n                relevantMemories = [...relevantMemories, ...importantMemories];\n            }\n        }\n        \n        // 2. Anılardan cümleler çıkar\n        const sentences: string[] = [];\n        const usedContents = new Set<string>();\n        \n        // Ana cümleler için anıları kullan\n        for (const memory of relevantMemories) {\n            if (sentences.length >= sentenceCount) break;\n            \n            // Her belleğin içeriğinden cümle çıkar\n            const memorySentences = memory.content\n                .split(/[.!?]+/)\n                .map(s => s.trim())\n                .filter(s => s.length > 10 && !usedContents.has(s));\n                \n            for (const sentence of memorySentences) {\n                if (sentences.length >= sentenceCount) break;\n                \n                sentences.push(sentence);\n                usedContents.add(sentence);\n            }\n        }\n        \n        // 3. Eğer yeterli cümle yoksa, ilişkileri kullanarak yeni cümleler oluştur\n        if (sentences.length < sentenceCount) {\n            // \"X ve Y arasında ilişki vardır\" tipinde cümleler\n            const relationMemories = this.longTerm.filter(m => \n                m.type === 'anlamlandirma' && \n                m.content.includes('ilişkilidir')\n            );\n            \n            for (const memory of relationMemories) {\n                if (sentences.length >= sentenceCount) break;\n                \n                if (!usedContents.has(memory.content)) {\n                    sentences.push(memory.content);\n                    usedContents.add(memory.content);\n                }\n            }\n        }\n        \n        // 4. Hala yeterli cümle yoksa, kümelerden bilgileri kullanarak cümleler üret\n        if (sentences.length < sentenceCount) {\n            for (const cluster of this.memoryClusters) {\n                if (sentences.length >= sentenceCount) break;\n                \n                const topicSentence = `${cluster.topic} hakkında bilgiler şunlardır.`;\n                if (!usedContents.has(topicSentence)) {\n                    sentences.push(topicSentence);\n                    usedContents.add(topicSentence);\n                }\n            }\n        }\n        \n        // 5. Cümleleri anlamlı bir sırayla düzenle ve mantık bağlayıcıları ekle\n        const connectors = [\n            \"Ayrıca\", \"Bunun yanında\", \"Bununla birlikte\", \"Dahası\", \n            \"Öte yandan\", \"Bu bağlamda\", \"Böylece\", \"Sonuç olarak\",\n            \"Örneğin\", \"Bunun sonucu olarak\", \"Bu sebeple\"\n        ];\n        \n        const arrangedSentences: string[] = [];\n        \n        // İlk cümleyi direkt ekle\n        if (sentences.length > 0) {\n            arrangedSentences.push(sentences[0]);\n        }\n        \n        // Sonraki cümlelere bağlayıcı ekle\n        for (let i = 1; i < sentences.length; i++) {\n            // Bazı cümlelere bağlayıcı ekle\n            if (Math.random() < 0.4) {\n                const connector = connectors[Math.floor(Math.random() * connectors.length)];\n                arrangedSentences.push(`${connector}, ${sentences[i].charAt(0).toLowerCase() + sentences[i].slice(1)}`);\n            } else {\n                arrangedSentences.push(sentences[i]);\n            }\n        }\n        \n        // 6. Paragrafı oluştur\n        let paragraph = arrangedSentences.join('. ').replace(/\\.\\./g, '.').replace(/\\.\\s+\\./g, '.');\n        \n        // Her cümlenin ilk harfini büyük yap\n        paragraph = paragraph\n            .split('. ')\n            .map(sentence => {\n                if (sentence.length > 0) {\n                    return sentence.charAt(0).toUpperCase() + sentence.slice(1);\n                }\n                return sentence;\n            })\n            .join('. ');\n            \n        // Son noktalama işareti ekle\n        if (!paragraph.endsWith('.') && !paragraph.endsWith('!') && !paragraph.endsWith('?')) {\n            paragraph += '.';\n        }\n        \n        return paragraph;\n    }\n}\n\n/**\n * Kullanıcı girdisini işle\n */\nexport const processUserInput = async (input: string) => {\n  // Soru analizi\n  const questionWords = ['ne', 'nedir', 'kim', 'kimdir', 'nerede', 'neresi', 'hangi', 'nasıl'];\n  const normalizedInput = input.toLowerCase().trim();\n\n  // Referans kontrolü (\"bu\", \"şu\" gibi kelimeler için)\n  const hasReference = normalizedInput.includes('bu') || normalizedInput.includes('şu');\n\n  // Çift yönlü düşünme için yön tespiti\n  const isReverseQuestion = normalizedInput.includes('neresidir') || normalizedInput.endsWith('nedir');\n\n  // Bilinçlenme sistemi ile entegrasyon\n  const memorySystem = new EnhancedMemorySystem();\n\n  // Bilinçlenme işlemi - kullanıcı girdisini analiz et\n  if (normalizedInput.includes('farkında') || \n      normalizedInput.includes('bilinç') || \n      normalizedInput.includes('anla') ||\n      normalizedInput.includes('kavra')) {\n    // Bilinçlenme belleği oluştur\n    memorySystem.createConsciousnessMemory(input);\n\n    // Kategori tespiti ile alan belirleme\n    const domain = memorySystem.categorizeMemory(input);\n\n    // Bilinçlenmeyi zenginleştir\n    memorySystem.enhanceConsciousness(input, domain);\n  }\n\n  // Aktivasyon ve cevap üretme\n  const userNetworks: any[] = [];\n  const systemNetworks: any[] = [];\n  const relations: any[] = [];\n  const nodes = { activatedNodes: [], activationLevels: new Map(), activationPath: [] };\n\n  // İlişkileri kontrol et\n  let response = '';\n  if (isReverseQuestion) {\n    // Ters yönlü ilişkileri kontrol et (örn: \"Ankara neresidir?\")\n    const bidirectionalRelations: any[] = []; // Define bidirectionalRelations\n    const reverseRelations = bidirectionalRelations.filter((rel: any) => \n      rel.userWord && rel.userWord.toLowerCase().includes(normalizedInput.replace(/neresidir|nedir|\\?/g, '').trim())\n    );\n\n    if (reverseRelations.length > 0) {\n      response = reverseRelations[0].systemWord;\n    }\n  }\n\n  // Normal yanıt üretme\n  if (!response) {\n    const trainingData: any[] = []; // Define trainingData\n    const recentConversation = ''; // Define recentConversation\n\n    // Bellek sisteminden bağlamsal bilgileri al\n    const contextualMemories = memorySystem.getContextualMemories(input);\n    const contextualInfo = contextualMemories.map(m => m.content).join(' ');\n\n    // Bilinçlenme bilgilerini al\n    const consciousnessState = memorySystem.getConsciousnessState();\n\n    // Basit yanıt üretme (generateResponse yerine)\n    response = contextualInfo || 'Size nasıl yardımcı olabilirim?';\n\n    // Bilinçlenme belleğini güncelle\n    if (consciousnessState.overallAwareness > 0.3) {\n      // Bilinçlenme seviyesi belirli bir eşiği geçtiyse, yanıtı bilinçlenme sistemine ekle\n      memorySystem.enhanceConsciousness(`Yanıt: ${response}`, 'diyalog');\n    }\n  }\n\n  return {\n    response,\n    usedTraining: null,\n    confidence: 0.75\n  };\n};\n","size_bytes":77704},"client/src/lib/NeuralNetworkUtils.ts":{"content":"/**\n * Yapay Sinir Ağı Yardımcı Fonksiyonları\n */\n\n// Sabitler\nexport const INITIAL_GRID_ROWS = 50; // Başlangıç kapasitesini artır\nexport const INITIAL_GRID_COLS = 50; // Başlangıç kapasitesini artır\nexport const INITIAL_NETWORK_LAYERS = 20; // Daha fazla katman\nexport const MIN_RELATION_SCORE = 1; // Minimum skoru düşür\nexport const LEARNING_RATE = 0.05; // Daha stabil öğrenme\nexport const MAX_NETWORK_SIZE = Infinity; // Sınırsız ağ boyutu\n\n// Performans optimizasyonu için gelişmiş parametreler\nexport const ACTIVATION_DECAY_RATE = 0.01;  // Daha az azalma\nexport const CONNECTION_THRESHOLD = 0.1;    // Daha düşük eşik - daha fazla bağlantı\nexport const MAX_CONNECTIONS_PER_NODE = Infinity; // Sınırsız bağlantı\nexport const REINFORCEMENT_RATE = 0.05;     // Daha stabil pekiştirme\nexport const FORGET_RATE = 0;               // Unutma tamamen kapalı\nexport const NEUROPLASTICITY = 1.0;         // Maksimum uyum kabiliyeti\n\n/**\n * Boş bir ızgara oluştur\n */\nexport const createEmptyGrid = (rows: number, cols: number): (NetworkNode | null)[][] => {\n  const grid: (NetworkNode | null)[][] = [];\n  for (let i = 0; i < rows; i++) {\n    grid[i] = [];\n    for (let j = 0; j < cols; j++) {\n      grid[i][j] = null;\n    }\n  }\n  return grid;\n};\n\n/**\n * Ağa yeni hücre ekle\n * @param networks Mevcut ağ katmanları\n * @param increaseAmount Eklenecek hücre sayısı\n * @returns Güncellenmiş ağ katmanları\n */\nexport const addCellsToNetwork = (\n  networks: (NetworkNode | null)[][][],\n  increaseAmount: number = 2\n): (NetworkNode | null)[][][] => {\n  // Ağın mevcut yapısını koru\n  const updatedNetworks = JSON.parse(JSON.stringify(networks)) as (NetworkNode | null)[][][];\n\n  // Her katmana hücre ekle\n  for (let layer = 0; layer < updatedNetworks.length; layer++) {\n    // Mevcut satır sayısı\n    const currentRows = updatedNetworks[layer].length;\n\n    // Yeni satırlar ekle\n    for (let i = 0; i < increaseAmount; i++) {\n      const newRow: (NetworkNode | null)[] = [];\n\n      // Her sütun için null değer ekle\n      for (let col = 0; col < updatedNetworks[layer][0].length; col++) {\n        newRow.push(null);\n      }\n\n      // Yeni satırı ekle\n      updatedNetworks[layer].push(newRow);\n    }\n  }\n\n  return updatedNetworks;\n};\n\n/**\n * Ağdan hücre sil\n * @param networks Mevcut ağ katmanları\n * @param decreaseAmount Silinecek hücre sayısı\n * @returns Güncellenmiş ağ katmanları\n */\nexport const removeCellsFromNetwork = (\n  networks: (NetworkNode | null)[][][],\n  decreaseAmount: number = 2\n): (NetworkNode | null)[][][] => {\n  // Ağın mevcut yapısını koru\n  const updatedNetworks = JSON.parse(JSON.stringify(networks)) as (NetworkNode | null)[][][];\n\n  // Her katmandan hücre sil (en az 4 satır kalacak şekilde)\n  for (let layer = 0; layer < updatedNetworks.length; layer++) {\n    // Mevcut satır sayısı\n    const currentRows = updatedNetworks[layer].length;\n\n    // Minimum 4 satır kalacak şekilde hesapla\n    const rowsToRemove = Math.min(decreaseAmount, currentRows - 4);\n\n    if (rowsToRemove > 0) {\n      // Son satırdan başlayarak sil (içinde düğüm olmayan satırları tercih et)\n      const rowsToKeep = currentRows - rowsToRemove;\n      const newRows: (NetworkNode | null)[][] = [];\n\n      // Önce düğüm içeren satırları koru\n      let nonEmptyRows = 0;\n      for (let row = 0; row < currentRows; row++) {\n        const hasNodes = updatedNetworks[layer][row].some(node => node !== null);\n        if (hasNodes && nonEmptyRows < rowsToKeep) {\n          newRows.push(updatedNetworks[layer][row]);\n          nonEmptyRows++;\n        }\n      }\n\n      // Boş satırları ekleyerek row sayısını tamamla\n      let remainingRows = rowsToKeep - nonEmptyRows;\n      if (remainingRows > 0) {\n        for (let row = 0; row < currentRows && remainingRows > 0; row++) {\n          const hasNodes = updatedNetworks[layer][row].some(node => node !== null);\n          if (!hasNodes && !newRows.includes(updatedNetworks[layer][row])) {\n            newRows.push(updatedNetworks[layer][row]);\n            remainingRows--;\n          }\n        }\n      }\n\n      // Yeni ızgarayı güncelle\n      updatedNetworks[layer] = newRows;\n    }\n  }\n\n  return updatedNetworks;\n};\n\n/**\n * Ağ düğümü arayüzü\n */\nexport interface NetworkNode {\n  id: string;                // Benzersiz düğüm kimliği\n  word: string;              // Düğümün temsil ettiği kelime\n  activation: number;        // Aktivasyon seviyesi (0-1)\n  count: number;             // Kullanım sayısı\n  connections: string[];     // Bağlantılar (diğer düğüm kimlikleri)\n  dependency: number;        // Bağımlılık değeri (0-100)\n  association: number;       // İlişki değeri (0-100)\n  frequency: number;         // Kullanım sıklığı\n  order: number;             // Sıra değeri\n  feedback: number;          // Kullanıcı geri bildirimi (-100 ile 100 arası)\n  depth: number;             // Ağ derinliği\n  parentWords: string[];     // Üst düğümler\n\n  // Gelişmiş özellikler\n  lastActivation: number;    // Son aktivasyon zamanı\n  activationHistory: number[]; // Aktivasyon geçmişi\n  semanticVector?: number[]; // Anlamsal vektör (embedding)\n  category?: string;         // Kategori (ör: isim, fiil, sıfat)\n  sentiment?: number;        // Duygu değeri (-1 ile 1 arası)\n  importance?: number;       // Önem değeri (0-100)\n  connectionStrengths?: { [nodeId: string]: number }; // Bağlantı güç değerleri\n  createdAt: number;         // Oluşturulma zamanı\n  modifiedAt: number;        // Son değiştirilme zamanı\n}\n\n/**\n * İlişki arayüzü (gelişmiş)\n */\nexport interface Relation {\n  id: string;                // Benzersiz ilişki kimliği\n  userWord: string;          // Kullanıcı kelimesi\n  systemWord: string;        // Sistem kelimesi\n  dependency: number;        // Bağımlılık değeri (0-100)\n  association: number;       // İlişki değeri (0-100) \n  frequency: number;         // Sıklık değeri\n  order: number;             // Sıra değeri\n  feedback: number;          // Kullanıcı geri bildirimi\n  isReversed?: boolean;      // Ters ilişki mi?\n  ai_generated?: boolean;    // Yapay zeka tarafından oluşturuldu mu?\n\n  // Gelişmiş özellikler\n  strength: number;          // İlişki gücü (0-100)\n  context?: string[];        // İlişki bağlamı\n  learningCount: number;     // Öğrenme sayısı\n  lastUsed: number;          // Son kullanım zamanı\n  creationTime: number;      // Oluşturulma zamanı\n  relationType?: 'semantic' | 'temporal' | 'causal' | 'hierarchical'; // İlişki tipi\n  bidirectional: boolean;    // İki yönlü mü?\n  confidence: number;        // Güven değeri (0-1)\n}\n\n/**\n * Eğitim çifti arayüzü\n */\nexport interface TrainingPair {\n  id: string;                // Benzersiz eğitim kimliği\n  input: string;             // Girdi metni\n  output: string;            // Çıktı metni\n  timestamp: number;         // Tarih damgası\n  score?: number;            // Kalite puanı (0-100)\n  difficulty?: number;       // Zorluk derecesi (0-100)\n  category?: string;         // Kategori\n  tags?: string[];           // Etiketler\n  usageCount: number;        // Kullanım sayısı\n}\n\n/**\n * Aktivasyon yayılımı sonucu\n */\nexport interface ActivationResult {\n  activationPath: {\n    layer: number;\n    row: number;\n    col: number;\n    type: 'user' | 'system';\n    value: number;\n    word: string;\n  }[];\n  activatedNodes: NetworkNode[];\n  activatedRelations: Relation[];\n  primaryConcepts: string[];\n  responseScore: number;\n  confidence: number;\n  processingTime: number;\n}\n\n// Bu fonksiyon yukarıda tanımlandı\n\n/**\n * Kelime için pozisyon bul\n */\nexport const findPositionForWord = (\n  grid: (NetworkNode | null)[][],\n  centerX = Math.floor(grid[0].length / 2),\n  centerY = Math.floor(grid.length / 2),\n  maxDistance = 5\n): { row: number; col: number } | null => {\n  // Spiral arama algoritması ile boş pozisyonu bul\n  for (let distance = 0; distance <= maxDistance; distance++) {\n    // Üst kenar\n    for (let i = -distance; i <= distance; i++) {\n      const row = centerY - distance;\n      const col = centerX + i;\n      if (row >= 0 && row < grid.length && col >= 0 && col < grid[0].length && !grid[row][col]) {\n        return { row, col };\n      }\n    }\n\n    // Sağ kenar\n    for (let i = -distance + 1; i <= distance; i++) {\n      const row = centerY + i;\n      const col = centerX + distance;\n      if (row >= 0 && row < grid.length && col >= 0 && col < grid[0].length && !grid[row][col]) {\n        return { row, col };\n      }\n    }\n\n    // Alt kenar\n    for (let i = distance - 1; i >= -distance; i--) {\n      const row = centerY + distance;\n      const col = centerX + i;\n      if (row >= 0 && row < grid.length && col >= 0 && col < grid[0].length && !grid[row][col]) {\n        return { row, col };\n      }\n    }\n\n    // Sol kenar\n    for (let i = distance - 1; i >= -distance + 1; i--) {\n      const row = centerY + i;\n      const col = centerX - distance;\n      if (row >= 0 && row < grid.length && col >= 0 && col < grid[0].length && !grid[row][col]) {\n        return { row, col };\n      }\n    }\n  }\n\n  return null;\n};\n\n/**\n * Benzersiz kimlik oluştur\n */\nexport const uuid = (): string => {\n  return Date.now().toString(36) + Math.random().toString(36).substring(2);\n};\n\n/**\n * Kelimeyi ağa ekle (geliştirilmiş)\n */\nexport const addWordToNetwork = (\n  word: string,\n  network: (NetworkNode | null)[][][],\n  layer: number,\n  existingNodes: Map<string, { node: NetworkNode, layer: number, row: number, col: number }>,\n  parentWord?: string\n): NetworkNode | null => {\n  // Kelimenin kimliğini oluştur\n  const wordId = word.toLowerCase() + \"-\" + uuid();\n\n  // Eğer kelime zaten varsa, mevcut düğümü güçlendir ve döndür\n  for (const [_, info] of existingNodes.entries()) {\n    if (info.node.word.toLowerCase() === word.toLowerCase()) {\n      // Mevcut düğümü güncelle (kullanım sayısını arttır)\n      info.node.count += 1;\n      info.node.frequency += 1;\n      info.node.modifiedAt = Date.now();\n\n      // Aktivasyon değerini arttır\n      info.node.activation = Math.min(1, info.node.activation + 0.2);\n      info.node.activationHistory.push(info.node.activation);\n\n      // Ebeveyn kelime varsa bağlantı ekle\n      if (parentWord) {\n        const parentInfo = Array.from(existingNodes.values()).find(n => \n          n.node.word.toLowerCase() === parentWord.toLowerCase()\n        );\n\n        if (parentInfo) {\n          // Ebeveyn bağlantısı ekle\n          if (!info.node.parentWords.includes(parentWord)) {\n            info.node.parentWords.push(parentWord);\n          }\n\n          // Çift yönlü bağlantı\n          if (!info.node.connections.includes(parentInfo.node.id)) {\n            info.node.connections.push(parentInfo.node.id);\n          }\n\n          if (!parentInfo.node.connections.includes(info.node.id)) {\n            parentInfo.node.connections.push(info.node.id);\n          }\n\n          // Bağlantı güçlerini güncelle\n          info.node.connectionStrengths = info.node.connectionStrengths || {};\n          parentInfo.node.connectionStrengths = parentInfo.node.connectionStrengths || {};\n\n          info.node.connectionStrengths[parentInfo.node.id] = \n            (info.node.connectionStrengths[parentInfo.node.id] || 0) + 0.1;\n\n          parentInfo.node.connectionStrengths[info.node.id] = \n            (parentInfo.node.connectionStrengths[info.node.id] || 0) + 0.1;\n        }\n      }\n\n      return info.node;\n    }\n  }\n\n  // Kelime ağda yoksa, bu katmanda yeni pozisyon bul\n  const grid = network[layer];\n  const position = findPositionForWord(grid);\n\n  if (!position) {\n    console.error(`Kelime '${word}' için pozisyon bulunamadı (katman ${layer})`);\n    return null;\n  }\n\n  // Anlamsal vektör oluştur\n  const semanticVector = generateSimpleSemanticVector(word);\n\n  // Kategoriyi belirle\n  const category = categorizeWord(word);\n\n  // Duygu değerini hesapla\n  const sentiment = calculateSentiment(word);\n\n  // Yeni düğüm oluştur\n  const newNode: NetworkNode = {\n    id: wordId,\n    word: word,\n    activation: 0.8, // Başlangıçta yüksek aktivasyon\n    count: 1,\n    connections: [],\n    dependency: Math.floor(Math.random() * 40) + 20, // 20-60 arası\n    association: Math.floor(Math.random() * 40) + 20, // 20-60 arası\n    frequency: 1,\n    order: 1,\n    feedback: 0,\n    depth: layer,\n    parentWords: parentWord ? [parentWord] : [],\n\n    // Gelişmiş özellikler\n    lastActivation: Date.now(),\n    activationHistory: [0.8], // Başlangıç aktivasyonu\n    semanticVector: semanticVector,\n    category: category,\n    sentiment: sentiment,\n    importance: Math.floor(Math.random() * 30) + 10, // 10-40 arası\n    connectionStrengths: {},\n    createdAt: Date.now(),\n    modifiedAt: Date.now()\n  };\n\n  // Düğümü ağa yerleştir\n  grid[position.row][position.col] = newNode;\n\n  // Düğüm bilgilerini kaydet\n  existingNodes.set(newNode.id, {\n    node: newNode,\n    layer,\n    row: position.row,\n    col: position.col\n  });\n\n  // Ebeveyn kelime varsa bağlantı ekle\n  if (parentWord) {\n    const parentInfo = Array.from(existingNodes.values()).find(n => \n      n.node.word.toLowerCase() === parentWord.toLowerCase()\n    );\n\n    if (parentInfo) {\n      // Çift yönlü bağlantı\n      newNode.connections.push(parentInfo.node.id);\n      parentInfo.node.connections.push(newNode.id);\n\n      // Bağlantı güçlerini ayarla\n      newNode.connectionStrengths = newNode.connectionStrengths || {};\n      parentInfo.node.connectionStrengths = parentInfo.node.connectionStrengths || {};\n\n      newNode.connectionStrengths[parentInfo.node.id] = 0.5; // Başlangıç gücü\n      parentInfo.node.connectionStrengths[newNode.id] = 0.5; // Başlangıç gücü\n    }\n  }\n\n  return newNode;\n};\n\n/**\n * Ağda düğüm bul\n */\nfunction findNodeInNetwork(network: (NetworkNode | null)[][][], nodeId: string): NetworkNode | null {\n  for (let layer = 0; layer < network.length; layer++) {\n    for (let row = 0; row < network[layer].length; row++) {\n      for (let col = 0; col < network[layer][0].length; col++) {\n        const node = network[layer][row][col];\n        if (node && node.id === nodeId) {\n          return node;\n        }\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Kosinüs benzerliği hesapla\n */\nfunction calculateCosineSimilarity(vec1: number[], vec2: number[]): number {\n  if (vec1.length !== vec2.length) {\n    return 0;\n  }\n\n  let dotProduct = 0;\n  let mag1 = 0;\n  let mag2 = 0;\n\n  for (let i = 0; i < vec1.length; i++) {\n    dotProduct += vec1[i] * vec2[i];\n    mag1 += vec1[i] * vec1[i];\n    mag2 += vec2[i] * vec2[i];\n  }\n\n  mag1 = Math.sqrt(mag1);\n  mag2 = Math.sqrt(mag2);\n\n  const mag = mag1 * mag2;\n  return mag === 0 ? 0 : dotProduct / mag;\n}\n\n/**\n * Basit anlamsal vektör oluştur\n */\nfunction generateSimpleSemanticVector(word: string): number[] {\n  // Gerçek bir uygulamada, bu bir word embedding API'si olabilir\n  // Burada basit bir yaklaşım kullanıyoruz\n  const vector = [];\n  const seed = word.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);\n\n  const random = (n: number) => {\n    const x = Math.sin(n) * 10000;\n    return x - Math.floor(x);\n  };\n\n  for (let i = 0; i < 5; i++) {\n    vector.push((random(seed + i) * 2) - 1); // -1 ile 1 arasında değerler\n  }\n\n  return vector;\n}\n\n/**\n * Kelimeyi kategorize et\n */\nfunction categorizeWord(word: string): string {\n  const categories: Record<string, string[]> = {\n    'isim': ['insan', 'araba', 'ev', 'kitap', 'bilgisayar', 'telefon', 'masa', 'sandalye'],\n    'fiil': ['gitmek', 'gelmek', 'yapmak', 'etmek', 'söylemek', 'görmek', 'duymak', 'hissetmek'],\n    'sıfat': ['güzel', 'iyi', 'kötü', 'büyük', 'küçük', 'hızlı', 'yavaş', 'uzun', 'kısa', 'yüksek'],\n    'zamir': ['ben', 'sen', 'o', 'biz', 'siz', 'onlar', 'bu', 'şu', 'kim', 'ne', 'kendi'],\n    'bağlaç': ['ve', 'veya', 'ama', 'fakat', 'çünkü', 'eğer', 'ile', 'ancak', 'ya da'],\n    'edat': ['için', 'gibi', 'kadar', 'göre', 'dolayı', 'beri', 'önce', 'sonra', 'rağmen'],\n    'nicelik': ['bir', 'iki', 'üç', 'az', 'çok', 'biraz', 'fazla', 'tüm', 'hepsi', 'her']\n  };\n\n  const wordLower = word.toLowerCase();\n\n  for (const [category, examples] of Object.entries(categories)) {\n    for (const example of examples) {\n      if (wordLower.includes(example)) {\n        return category;\n      }\n    }\n  }\n\n  // Basit morfem analizi\n  if (wordLower.endsWith('lik') || wordLower.endsWith('lık') || \n      wordLower.endsWith('luk') || wordLower.endsWith('lük')) {\n    return 'isim';\n  }\n\n  if (wordLower.endsWith('mek') || wordLower.endsWith('mak')) {\n    return 'fiil';\n  }\n\n  if (wordLower.length > 3 && (\n      wordLower.endsWith('ci') || wordLower.endsWith('cı') || \n      wordLower.endsWith('cu') || wordLower.endsWith('cü'))) {\n    return 'isim';\n  }\n\n  // Varsayılan kategori\n  return wordLower.length <= 3 ? 'bağlaç' : 'isim';\n}\n\n/**\n * Duygu değeri hesapla (basit)\n */\nfunction calculateSentiment(word: string): number {\n  const positiveWords = [\n    'iyi', 'güzel', 'harika', 'muhteşem', 'sevmek', 'başarı', 'mutlu', 'sevinç',\n    'keyif', 'huzur', 'dostluk', 'eğlence', 'destek', 'coşku', 'heyecan'\n  ];\n\n  const negativeWords = [\n    'kötü', 'çirkin', 'berbat', 'korkunç', 'nefret', 'başarısız', 'mutsuz', 'üzüntü',\n    'acı', 'kaygı', 'endişe', 'korku', 'öfke', 'sıkıntı', 'stres', 'tehlike'\n  ];\n\n  const wordLower = word.toLowerCase();\n\n  for (const positive of positiveWords) {\n    if (wordLower.includes(positive)) {\n      return 0.5; // Pozitif duygu\n    }\n  }\n\n  for (const negative of negativeWords) {\n    if (wordLower.includes(negative)) {\n      return -0.5; // Negatif duygu\n    }\n  }\n\n  return 0; // Nötr\n}\n\n/**\n * Yeni ilişki oluştur\n */\nexport const createRelation = (\n  userWord: string,\n  systemWord: string,\n  dependency: number = 50,\n  association: number = 50,\n  frequency: number = 1,\n  order: number = 1,\n  feedback: number = 0,\n  bidirectional: boolean = false,\n  context: string[] = [],\n  relationType: 'semantic' | 'temporal' | 'causal' | 'hierarchical' = 'semantic'\n): Relation => {\n  const strength = (dependency + association) / 2; // İlişki gücü\n\n  return {\n    id: uuid(),\n    userWord,\n    systemWord,\n    dependency,\n    association,\n    frequency,\n    order,\n    feedback,\n    strength,\n    context,\n    learningCount: 1,\n    lastUsed: Date.now(),\n    creationTime: Date.now(),\n    relationType,\n    bidirectional,\n    confidence: 0.5 // Başlangıç güven değeri\n  };\n};\n\n/**\n * İlişki güçlendirme\n */\nexport const reinforceRelation = (relation: Relation, amount: number, feedback?: number): Relation => {\n  // İlişkiyi güçlendir\n  const updatedRelation = { ...relation };\n\n  updatedRelation.dependency = Math.min(100, Math.max(1, relation.dependency + amount));\n  updatedRelation.association = Math.min(100, Math.max(1, relation.association + amount));\n  updatedRelation.learningCount += 1;\n  updatedRelation.lastUsed = Date.now();\n  updatedRelation.strength = (updatedRelation.dependency + updatedRelation.association) / 2;\n\n  // Eğer geri bildirim varsa güncelle\n  if (feedback !== undefined) {\n    updatedRelation.feedback = Math.min(100, Math.max(-100, relation.feedback + feedback));\n  }\n\n  // Güven değerini güncelle (öğrenme sayısına bağlı)\n  updatedRelation.confidence = Math.min(1, Math.max(0, 0.5 + (updatedRelation.learningCount / 20)));\n\n  return updatedRelation;\n};\n\n/**\n * İlişkileri zayıflatma (unutma)\n */\nexport const weakenRelations = (relations: Relation[], factor: number = FORGET_RATE): Relation[] => {\n  const now = Date.now();\n  const oneDay = 24 * 60 * 60 * 1000; // Bir günlük milisaniye\n\n  return relations.map(relation => {\n    const daysSinceLastUse = (now - relation.lastUsed) / oneDay;\n\n    // Son kullanımdan bu yana geçen gün sayısına göre zayıflat\n    if (daysSinceLastUse > 1) {\n      const weakenAmount = Math.min(15, factor * daysSinceLastUse); // En fazla 15 puan zayıflat\n\n      return {\n        ...relation,\n        dependency: Math.max(1, relation.dependency - weakenAmount),\n        association: Math.max(1, relation.association - weakenAmount),\n        strength: Math.max(1, relation.strength - weakenAmount),\n        confidence: Math.max(0.1, relation.confidence - (weakenAmount / 100))\n      };\n    }\n\n    return relation;\n  });\n};\n\n/**\n * Sinir ağı aktivasyonu\n */\nexport const propagateActivation = (\n  userNetworks: (NetworkNode | null)[][][],\n  systemNetworks: (NetworkNode | null)[][][],\n  relations: Relation[],\n  inputText: string,\n  maxDepth: number = 3\n): ActivationResult => {\n  const startTime = Date.now();\n\n  // İnput metnini kelimelere ayır\n  const inputWords = inputText.toLowerCase().split(/\\s+/);\n\n  // Aktivasyon sonuçları\n  const activatedNodes: NetworkNode[] = [];\n  const activatedRelations: Relation[] = [];\n  const activationPath: { layer: number; row: number; col: number; type: 'user' | 'system'; value: number; word: string }[] = [];\n  const activationLevels = new Map<string, number>(); // Düğüm kimliği -> aktivasyon seviyesi\n\n  // Düğüm pozisyonlarını tut\n  const nodePositions = new Map<string, { layer: number; row: number; col: number; type: 'user' | 'system' }>();\n\n  // Tüm ağdaki düğümlerin pozisyonlarını kaydet\n  for (let layer = 0; layer < userNetworks.length; layer++) {\n    for (let row = 0; row < userNetworks[layer].length; row++) {\n      for (let col = 0; col < userNetworks[layer][0].length; col++) {\n        const node = userNetworks[layer][row][col];\n        if (node) {\n          nodePositions.set(node.id, { layer, row, col, type: 'user' });\n        }\n      }\n    }\n  }\n\n  for (let layer = 0; layer < systemNetworks.length; layer++) {\n    for (let row = 0; row < systemNetworks[layer].length; row++) {\n      for (let col = 0; col < systemNetworks[layer][0].length; col++) {\n        const node = systemNetworks[layer][row][col];\n        if (node) {\n          nodePositions.set(node.id, { layer, row, col, type: 'system' });\n        }\n      }\n    }\n  }\n\n  // Aktivasyon kuyruğu\n  type ActivationQueueItem = {\n    node: NetworkNode;\n    position: { layer: number; row: number; col: number; type: 'user' | 'system' };\n    activationValue: number;\n    depth: number;\n  };\n\n  const activationQueue: ActivationQueueItem[] = [];\n\n  // Başlangıç aktivasyonu (kullanıcı ağı)\n  for (let layer = 0; layer < userNetworks.length; layer++) {\n    for (let row = 0; row < userNetworks[layer].length; row++) {\n      for (let col = 0; col < userNetworks[layer][0].length; col++) {\n        const node = userNetworks[layer][row][col];\n        if (node) {\n          // Kelime eşleşmesi kontrolü\n          let matched = false;\n          for (const inputWord of inputWords) {\n            if (calculateWordSimilarity(node.word.toLowerCase(), inputWord) > 0.7) {\n              matched = true;\n              break;\n            }\n          }\n\n          if (matched) {\n            // Aktivasyon seviyesi: 1.0 (tam aktivasyon)\n            node.activation = 1.0;\n            node.lastActivation = Date.now();\n            node.activationHistory.push(1.0);\n\n            activationQueue.push({\n              node,\n              position: { layer, row, col, type: 'user' },\n              activationValue: 1.0,\n              depth: 0\n            });\n\n            activatedNodes.push(node);\n            activationLevels.set(node.id, 1.0);\n\n            activationPath.push({\n              layer, row, col, type: 'user', value: 1.0, word: node.word\n            });\n          }\n        }\n      }\n    }\n  }\n\n  // Aktivasyonu yay\n  while (activationQueue.length > 0) {\n    const current = activationQueue.shift()!;\n\n    // Maksimum derinliği aştıysak durdur\n    if (current.depth >= maxDepth) {\n      continue;\n    }\n\n    const currentNodeId = current.node.id;\n    const currentNodeValue = current.activationValue;\n\n    // Bağlantıları takip et\n    for (const connectionId of current.node.connections) {\n      // Kullanıcı ağında düğümü bul\n      let connectedNode = findNodeInNetwork(userNetworks, connectionId);\n      let nodeType: 'user' | 'system' = 'user';\n\n      // Eğer kullanıcı ağında yoksa, sistem ağında ara\n      if (!connectedNode) {\n        connectedNode = findNodeInNetwork(systemNetworks, connectionId);\n        nodeType = 'system';\n      }\n\n      if (connectedNode) {\n        // Bağlantının gücünü al\n        const connectionStrength = current.node.connectionStrengths?.[connectionId] || 0.5;\n\n        // Yeni aktivasyon değeri\n        const newActivationValue = currentNodeValue * connectionStrength * (1 - ACTIVATION_DECAY_RATE);\n\n        // Mevcut aktivasyonla karşılaştır\n        const currentActivation = activationLevels.get(connectionId) || 0;\n        const activationValue = Math.max(currentActivation, newActivationValue);\n\n        // Düğümün pozisyonunu bul\n        const position = nodePositions.get(connectionId);\n\n        if (activationValue > CONNECTION_THRESHOLD && position) {\n          // Aktivasyon seviyesini güncelle\n          connectedNode.activation = activationValue;\n          connectedNode.lastActivation = Date.now();\n          connectedNode.activationHistory.push(activationValue);\n\n          activationLevels.set(connectionId, activationValue);\n\n          // Bu düğüm daha önce aktive edilmemişse, aktivasyona ekle\n          if (!activatedNodes.find(n => n.id === connectionId)) {\n            activatedNodes.push(connectedNode);\n\n            activationPath.push({\n              ...position,\n              value: activationValue,\n              word: connectedNode.word\n            });\n\n            // Sıradaki aktivasyon\n            activationQueue.push({\n              node: connectedNode,\n              position,\n              activationValue,\n              depth: current.depth + 1\n            });\n          }\n        }\n      }\n    }\n\n    // İlişkileri kontrol et\n    for (const relation of relations) {\n      // Mevcut düğüm kullanıcı kelimesi mi?\n      if (current.node.word.toLowerCase() === relation.userWord.toLowerCase()) {\n        // İlişkideki sistem kelimesine aktive et\n        for (let layer = 0; layer < systemNetworks.length; layer++) {\n          for (let row = 0; row < systemNetworks[layer].length; row++) {\n            for (let col = 0; col < systemNetworks[layer][0].length; col++) {\n              const node = systemNetworks[layer][row][col];\n\n              if (node && node.word.toLowerCase() === relation.systemWord.toLowerCase()) {\n                // İlişki gücüne bağlı aktivasyon\n                const activationValue = currentNodeValue * (relation.strength / 100) * (1 - ACTIVATION_DECAY_RATE);\n\n                // Mevcut aktivasyonla karşılaştır\n                const currentActivation = activationLevels.get(node.id) || 0;\n                const newActivation = Math.max(currentActivation, activationValue);\n\n                if (newActivation > CONNECTION_THRESHOLD) {\n                  // Aktivasyon seviyesini güncelle\n                  node.activation = newActivation;\n                  node.lastActivation = Date.now();\n                  node.activationHistory.push(newActivation);\n\n                  activationLevels.set(node.id, newActivation);\n                  activatedRelations.push(relation);\n\n                  // Bu düğüm daha önce aktive edilmemişse, aktivasyona ekle\n                  if (!activatedNodes.find(n => n.id === node.id)){\n                    activatedNodes.push(node);\n\n                    activationPath.push({\n                      layer, row, col, type: 'system',\n                      value: newActivation,word: node.word\n                    });\n\n                    // Sıradaki aktivasyon\n                    activationQueue.push({\n                      node,\n                      position: { layer, row, col, type: 'system' },\n                      activationValue: newActivation,\n                      depth: current.depth + 1\n                    });\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      // Mevcut düğüm sistem kelimesi mi? (ve ilişki çift yönlüyse)\n      else if (relation.bidirectional && current.node.word.toLowerCase() === relation.systemWord.toLowerCase()) {\n        // İlişkideki kullanıcı kelimesine aktive et\n        for (let layer = 0; layer < userNetworks.length; layer++) {\n          for (let row = 0; row < userNetworks[layer].length; row++) {\n            for (let col = 0; col < userNetworks[layer][0].length; col++) {\n              const node = userNetworks[layer][row][col];\n\n              if (node && node.word.toLowerCase() === relation.userWord.toLowerCase()) {\n                // İlişki gücüne bağlı aktivasyon\n                const activationValue = currentNodeValue * (relation.strength / 100) * (1 - ACTIVATION_DECAY_RATE);\n\n                // Mevcut aktivasyonla karşılaştır\n                const currentActivation = activationLevels.get(node.id) || 0;\n                const newActivation = Math.max(currentActivation, activationValue);\n\n                if (newActivation > CONNECTION_THRESHOLD) {\n                  // Aktivasyon seviyesini güncelle\n                  node.activation = newActivation;\n                  node.lastActivation = Date.now();\n                  node.activationHistory.push(newActivation);\n\n                  activationLevels.set(node.id, newActivation);\n                  activatedRelations.push({ ...relation, isReversed: true });\n\n                  // Bu düğüm daha önce aktive edilmemişse, aktivasyona ekle\n                  if (!activatedNodes.find(n => n.id === node.id)) {\n                    activatedNodes.push(node);\n\n                    activationPath.push({\n                      layer, row, col, type: 'user',\n                      value: newActivation,\n                      word: node.word\n                    });\n\n                    // Sıradaki aktivasyon\n                    activationQueue.push({\n                      node,\n                      position: { layer, row, col, type: 'user' },\n                      activationValue: newActivation,\n                      depth: current.depth + 1\n                    });\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Aktive edilen kavramları önem sırasına göre sırala\n  const primaryConcepts = activatedNodes\n    .filter(node => node.activation > 0.5)\n    .sort((a, b) => b.activation - a.activation || b.importance! - a.importance!)\n    .map(node => node.word)\n    .slice(0, 5);\n\n  // Yanıt puanı hesapla (1-100 arası)\n  const responseScore = Math.min(100, Math.max(1, Math.round(\n    (activatedNodes.length * 5) + \n    (activatedRelations.length * 10) + \n    (activatedNodes.reduce((sum, node) => sum + node.activation, 0) * 20)\n  )));\n\n  // Güven değeri hesapla (0-1 arası)\n  const confidence = Math.min(1, Math.max(0, \n    (activatedRelations.length > 0) \n      ? activatedRelations.reduce((sum, rel) => sum + rel.confidence, 0) / activatedRelations.length\n      : 0.3\n  ));\n\n  // İşlem süresi\n  const processingTime = Date.now() - startTime;\n\n  return {\n    activationPath,\n    activatedNodes,\n    activatedRelations,\n    primaryConcepts,\n    responseScore,\n    confidence,\n    processingTime\n  };\n};\n\n\n\n/**\n * Levenshtein mesafesi ile kelime benzerliği hesapla\n * @param word1 İlk kelime\n * @param word2 İkinci kelime\n * @returns 0-1 arası benzerlik değeri\n */\nexport const calculateWordSimilarity = (word1: string, word2: string): number => {\n  const str1 = word1.toLowerCase();\n  const str2 = word2.toLowerCase();\n\n  if (str1 === str2) return 1.0;\n  if (str1.length === 0 || str2.length === 0) return 0.0;\n\n  const matrix: number[][] = [];\n\n  // Matrix'i initialize et\n  for (let i = 0; i <= str2.length; i++) {\n    matrix[i] = [i];\n  }\n\n  for (let j = 0; j <= str1.length; j++) {\n    matrix[0][j] = j;\n  }\n\n  // Levenshtein distance hesapla\n  for (let i = 1; i <= str2.length; i++) {\n    for (let j = 1; j <= str1.length; j++) {\n      if (str2.charAt(i - 1) === str1.charAt(j - 1)) {\n        matrix[i][j] = matrix[i - 1][j - 1];\n      } else {\n        matrix[i][j] = Math.min(\n          matrix[i - 1][j - 1] + 1, // substitution\n          matrix[i][j - 1] + 1,     // insertion\n          matrix[i - 1][j] + 1      // deletion\n        );\n      }\n    }\n  }\n\n  const maxLength = Math.max(str1.length, str2.length);\n  const distance = matrix[str2.length][str1.length];\n\n  return 1 - (distance / maxLength);\n};\n\n/**\n * Tersine düşünme için soru tipini belirle\n * @param question Kullanıcı sorusu\n * @returns Soru tipi\n */\nexport const determineQuestionType = (question: string): {\n  type: 'what-is' | 'where-is' | 'who-is' | 'how-to' | 'when-is' | 'other';\n  subject: string;\n} => {\n  const lowerQuestion = question.toLowerCase().trim();\n  const words = lowerQuestion.split(/\\s+/);\n  let type: 'what-is' | 'where-is' | 'who-is' | 'how-to' | 'when-is' | 'other' = 'other';\n  let subject = '';\n\n  // \"Nedir\" tipindeki sorular\n  if (\n    lowerQuestion.includes('nedir') || \n    lowerQuestion.includes('ne demek') || \n    lowerQuestion.includes('nedir?') || \n    lowerQuestion.includes('ne demektir') ||\n    lowerQuestion.endsWith('ne') ||\n    lowerQuestion.endsWith('ne?')\n  ) {\n    type = 'what-is';\n\n    // Son cümle öğesini konu olarak al (genellikle \"... nedir?\" kalıbında)\n    if (lowerQuestion.includes('nedir') || lowerQuestion.includes('nedir?')) {\n      subject = words.slice(0, words.indexOf('nedir')).join(' ');\n    } else if (lowerQuestion.includes('ne demek')) {\n      subject = words.slice(0, words.indexOf('ne')).join(' ');\n    } else if (lowerQuestion.endsWith('ne') || lowerQuestion.endsWith('ne?')) {\n      subject = words.slice(0, words.length - 1).join(' ');\n    }\n  }\n  // \"Nerede\" tipindeki sorular\n  else if (\n    lowerQuestion.includes('nerede') || \n    lowerQuestion.includes('neresi') ||\n    lowerQuestion.includes('nerededir')\n  ) {\n    type = 'where-is';\n\n    // \"X nerede?\" veya \"X neresi?\" formatında\n    if (lowerQuestion.includes('nerede')) {\n      subject = words.slice(0, words.indexOf('nerede')).join(' ');\n    } else if (lowerQuestion.includes('neresi')) {\n      subject = words.slice(0, words.indexOf('neresi')).join(' ');\n    }\n  }\n  // \"Kim\" tipindeki sorular\n  else if (lowerQuestion.includes('kim')) {\n    type = 'who-is';\n    subject = words.slice(0, words.indexOf('kim')).join(' ');\n  }\n  // \"Nasıl\" tipindeki sorular\n  else if (lowerQuestion.includes('nasıl')) {\n    type = 'how-to';\n  }\n  // \"Ne zaman\" tipindeki sorular\n  else if (lowerQuestion.includes('ne zaman')) {\n    type = 'when-is';\n  }\n\n  // Konu yoksa, belirli kelimeleri çıkararak tahmin et\n  if (!subject && words.length > 1) {\n    const stopwords = ['mi', 'midir', 'mudur', 'mıdır', 'müdür', 'bir', 'bu', 'şu', 'şey'];\n    subject = words.filter(w => !stopwords.includes(w)).join(' ');\n  }\n\n  return { type, subject: subject.trim() };\n};\n\n/**\n * Tersine cevap için \"nedir\" sorularına odaklanan bir fonksiyon\n * @param query Kullanıcı sorgusu\n * @param trainingData Eğitim verileri\n * @returns Tersine cevap veya null\n */\nexport const findReverseAnswer = (\n  query: string, \n  trainingData: TrainingPair[]\n): { response: string; confidence: number } | null => {\n  const { type, subject } = determineQuestionType(query);\n\n  // Sadece \"nedir?\" ve \"nerede?\" tipi sorularla ilgilen\n  if (!['what-is', 'where-is'].includes(type) || !subject) {\n    return null;\n  }\n\n  const matches: { pair: TrainingPair; score: number }[] = [];\n\n  for (const pair of trainingData) {\n    const outputLower = pair.output.toLowerCase();\n    const subjectLower = subject.toLowerCase();\n\n    // Tam eşleşme\n    if (outputLower === subjectLower) {\n      matches.push({ pair, score: 1.0 });\n      continue;\n    }\n\n    // İlk kelime eşleşiyor mu?\n    if (outputLower.startsWith(subjectLower + ' ') || outputLower.startsWith(subjectLower + ',')) {\n      matches.push({ pair, score: 0.9 });\n      continue;\n    }\n\n    // İfade çıktının herhangi bir yerinde tam olarak geçiyor mu?\n    if (outputLower.includes(' ' + subjectLower + ' ') || \n        outputLower.includes(', ' + subjectLower + ' ')) {\n      matches.push({ pair, score: 0.8 });\n      continue;\n    }\n\n    // Benzerlik kontrolü\n    const similarity = calculateWordSimilarity(outputLower, subjectLower);\n    if (similarity > 0.8) {\n      matches.push({ pair, score: similarity });\n    }\n  }\n\n  // En iyi eşleşmeyi bul\n  matches.sort((a, b) => b.score - a.score);\n\n  if (matches.length > 0 && matches[0].score >= 0.7) {\n    const bestMatch = matches[0].pair;\n\n    let response = '';\n\n    if (type === 'where-is') {\n      // \"Türkiye nerede?\" -> \"Ankara, Türkiye'de bulunur.\"\n      // Cümleyi \"yerde bulunur\" veya benzeri bir yapıya dönüştürmeye çalış\n      if (bestMatch.input.toLowerCase().includes('nerede')) {\n        response = `${subject}, ${bestMatch.input.replace(/\\s+nerede.*$/i, '')}dir.`;\n      } else {\n        response = `${subject}, ${bestMatch.input}dir.`;\n      }\n    } else { // type === 'what-is'\n      // \"Elma nedir?\" -> \"Elma, bir meyvedir.\"\n      response = `${subject}, ${bestMatch.input.replace(/\\?/g, '').trim()}dir.`;\n    }\n    \n    // Çift \"-dir\" eki varsa düzelt\n    response = response.replace(/dirdir/, 'dir');\n\n    // İlk harfi büyük yap\n    response = response.charAt(0).toUpperCase() + response.slice(1);\n\n    return {\n      response,\n      confidence: matches[0].score * 0.8 \n    };\n  }\n\n  return null;\n};\n\n/**\n * Gelişmiş anlamlandırma sistemi - Kelime anlamı soruları için sözlük önceliği\n */\nconst performSemanticAnalysis = (\n  input: string, \n  turkishDictionary: any, \n  trainingData: TrainingPair[],\n  activatedNodes: NetworkNode[]\n): { response: string; confidence: number; method: string; notification?: string } | null => {\n  const cleanInput = input.toLowerCase().trim().replace(/[?!.,]/g, '');\n  const words = cleanInput.split(/\\s+/).filter(w => w.length > 1);\n\n  // 1. ÖNCELİKLE kelime anlamı sorularını kontrol et - \"nedir\", \"ne demek\" vs.\n  const { targetWord, questionType } = extractQuestionTarget(input);\n\n  // Eğer kelime anlamı sorusu tespit edildiyse, MUTLAK ÖNCELİKLE sözlüğe bak\n  if (targetWord && questionType && ['nedir', 'ne_demek', 'ne', 'ne_anlama_gelir', 'anlamı_nedir'].includes(questionType)) {\n    const entry = turkishDictionary.getWord(targetWord);\n\n    if (entry) {\n      let response = '';\n      if (questionType === 'nedir' || questionType === 'anlamı_nedir') {\n        response = `${targetWord.charAt(0).toUpperCase() + targetWord.slice(1)}: ${entry.meaning[0]}`;\n        if (entry.type) response += ` (${entry.type})`;\n        if (entry.examples && entry.examples.length > 0) {\n          response += `\\n\\nÖrnek kullanım: ${entry.examples[0]}`;\n        }\n      } else if (questionType === 'ne_demek' || questionType === 'ne_anlama_gelir') {\n        response = `${targetWord}: ${entry.meaning[0]}`;\n        if (entry.type) response += ` (${entry.type})`;\n      } else if (questionType === 'ne') {\n        response = `${targetWord}: ${entry.meaning[0]}`;\n        if (entry.type) response += ` (${entry.type})`;\n      }\n\n      response = removeDuplicateSentences(response);\n\n      return {\n        response,\n        confidence: 0.98, // Çok yüksek güven - sözlük kesin öncelik\n        method: 'dictionary_definition_priority',\n        notification: '📖 Sözlükten kelime anlamı bulundu'\n      };\n    }\n\n    // Sözlükte bulunamazsa da sözlük cevabı ver\n    return {\n      response: `\"${targetWord}\" kelimesini sözlükte bulamadım. Bilmiyorum - yorumun altındaki kalemle cevabımı düzelt.`,\n      confidence: 0.4,\n      method: 'word_not_found_in_dictionary',\n      notification: '❌ Sözlükte bulunamadı - düzeltme gerekli'\n    };\n  }\n\n  // 2. Kelime anlamı sorusu değilse, eğitim verisinde direkt eşleşme ara\n  const exactTrainingMatch = trainingData.find(pair => \n    pair.input.toLowerCase().trim() === input.toLowerCase().trim()\n  );\n\n  if (exactTrainingMatch) {\n    return {\n      response: exactTrainingMatch.output,\n      confidence: 1.0,\n      method: 'exact_training_match',\n      notification: '✅ Eğitim verisinde bulundu'\n    };\n  }\n\n  // 3. Eğer soru kalıbı tespit edildiyse, önce hedef kelime ile eğitim verilerinde arama yap\n  if (targetWord && questionType) {\n    // Hedef kelimeyi içeren eğitim verilerini ara\n    const targetWordTraining = trainingData.filter(pair => {\n      const inputLower = pair.input.toLowerCase();\n      const targetLower = targetWord.toLowerCase();\n\n      // Tam kelime eşleşmesi ara\n      return inputLower.includes(targetLower) || \n             inputLower.split(/\\s+/).some(word => word === targetLower);\n    });\n\n    if (targetWordTraining.length > 0) {\n      // En iyi eşleşmeyi bul\n      const bestMatch = targetWordTraining.reduce((best, current) => {\n        const currentSimilarity = calculateSemanticSimilarity(targetWord, current.input);\n        const bestSimilarity = calculateSemanticSimilarity(targetWord, best.input);\n        return currentSimilarity > bestSimilarity ? current : best;\n      });\n\n      return {\n        response: bestMatch.output,\n        confidence: 0.95,\n        method: 'target_word_training_match',\n        notification: '📚 Eğitim verilerinde hedef kelime bulundu'\n      };\n    }\n\n    // 4. Eğitim verilerinde bulunamazsa sözlüğe bak\n    const entry = turkishDictionary.getWord(targetWord);\n\n    if (entry) {\n      let response = '';\n      if (questionType === 'nedir') {\n        response = `${targetWord.charAt(0).toUpperCase() + targetWord.slice(1)}: ${entry.meaning[0]}`;\n        if (entry.type) response += ` (${entry.type})`;\n        if (entry.examples && entry.examples.length > 0) {\n          response += `\\n\\nÖrnek kullanım: ${entry.examples[0]}`;\n        }\n      } else if (questionType === 'ne_demek') {\n        response = `\"${targetWord}\" kelimesi: ${entry.meaning[0]}`;\n        if (entry.type) response += ` (${entry.type})`;\n      }\n\n      return {\n        response,\n        confidence: 0.75,\n        method: 'dictionary_definition',\n        notification: '📖 Türkçe sözlükte bulundu (eğitim verisinde yok)'\n      };\n    } else {\n      return {\n        response: `\"${targetWord}\" kelimesini ne eğitim verilerinde ne de sözlükte bulamadım. Bu kelime hakkında bana daha fazla bilgi verebilir misiniz?`,\n        confidence: 0.3,\n        method: 'word_not_found',\n        notification: '❌ Hiçbir yerde bulunamadı'\n      };\n    }\n  }\n\n  // 5. Benzer eğitim verilerini ara\n  const similarTraining = trainingData.filter(pair => {\n    const similarity = calculateSemanticSimilarity(input, pair.input);\n    return similarity > 0.6;\n  });\n\n  if (similarTraining.length > 0) {\n    const bestMatch = similarTraining.reduce((best, current) => {\n      const currentSimilarity = calculateSemanticSimilarity(input, current.input);\n      const bestSimilarity = calculateSemanticSimilarity(input, best.input);\n      return currentSimilarity > bestSimilarity ? current : best;\n    });\n\n    return {\n      response: bestMatch.output,\n      confidence: 0.9,\n      method: 'semantic_similarity_match',\n      notification: '📚 Benzer eğitim verisi kullanıldı'\n    };\n  }\n\n  // 3. Kelimeleri ayırıp anlamlandırma\n  const knownWords = [];\n  const unknownWords = [];\n\n  for (const word of words) {\n    const entry = turkishDictionary.getWord(word);\n    if (entry) {\n      knownWords.push({ word, entry });\n    } else {\n      unknownWords.push(word);\n    }\n  }\n\n  // 4. Eğitim verisinde sözcükler ile eşleşme ara\n  if (knownWords.length > 0) {\n    for (const { word, entry } of knownWords) {\n      const relatedTraining = trainingData.filter(pair => {\n        const pairWords = pair.input.toLowerCase().split(/\\s+/);\n        return pairWords.some(pw => pw.includes(word) || word.includes(pw));\n      });\n\n      if (relatedTraining.length > 0) {\n        const bestMatch = relatedTraining.reduce((best, current) => {\n          const currentScore = calculateSemanticSimilarity(input, current.input);\n          const bestScore = calculateSemanticSimilarity(input, best.input);\n          return currentScore > bestScore ? current : best;\n        });\n\n        const similarity = calculateSemanticSimilarity(input, bestMatch.input);\n        if (similarity > 0.3) {\n          return {\n            response: bestMatch.output,\n            confidence: similarity * 0.8,\n            method: 'semantic_training_match',\n            notification: '🔗 İlişkili veri bulundu'\n          };\n        }\n      }\n    }\n\n    // 5. Sözlük tanımlarıyla bağlamsal cevap oluştur\n    if (knownWords.length <= 3) {\n      let contextualResponse = '';\n\n      // İlişkili sözcükleri uygun sırada düzenle\n      const sortedWords = knownWords.sort((a, b) => {\n        // Önce isim, sonra fiil, sonra sıfat\n        const typeOrder = { 'isim': 1, 'fiil': 2, 'sıfat': 3, 'zamir': 4, 'edat': 5, 'bağlaç': 6 };\n        return (typeOrder[a.entry.type] || 10) - (typeOrder[b.entry.type] || 10);\n      });\n\n      if (sortedWords.length === 1) {\n        const { word, entry } = sortedWords[0];\n        contextualResponse = `${word.charAt(0).toUpperCase() + word.slice(1)} hakkında bilgi: ${entry.meaning[0]}`;\n\n        if (entry.examples && entry.examples.length > 0) {\n          contextualResponse += `\\n\\nÖrnek kullanım: ${entry.examples[0]}`;\n        }\n      } else {\n        contextualResponse = `Bu konuda bildiğim kelimeler:\\n\\n`;\n        sortedWords.forEach(({ word, entry }, index) => {\n          contextualResponse += `${index + 1}. ${word}: ${entry.meaning[0]} (${entry.type})\\n`;\n        });\n\n        // İlişkiler varsa ekle\n        if (sortedWords.length > 1) {\n          contextualResponse += `\\nBu kelimeler arasında anlam bağlantısı olabilir.`;\n        }\n      }\n\n      if (contextualResponse) {\n        return {\n          response: contextualResponse.trim(),\n          confidence: 0.6,\n          method: 'contextual_dictionary',\n          notification: '📝 Sözlük bilgisi kullanıldı'\n        };\n      }\n    }\n  }\n\n  // 6. Bilinmeyen kelimeler varsa\n  if (unknownWords.length > 0) {\n    const unknownWordsList = unknownWords.slice(0, 3).join(', ');\n    return {\n      response: `\"${unknownWordsList}\" kelime(leri)ni bilmiyorum - yorumun altındaki kalemle cevabımı düzelt.`,\n      confidence: 0.3,\n      method: 'unknown_words',\n      notification: '🤷 Bilinmeyen kelimeler'\n    };\n  }\n\n  // 7. Hiçbir şey bulunamadı\n  return {\n    response: `Bilmiyorum - yorumun altındaki kalemle cevabımı düzelt.`,\n    confidence: 0.2,\n    method: 'not_understood',\n    notification: '❌ Anlayamadım'\n  };\n};\n\n/**\n * Soru tipini ve hedef kelimeyi çıkar\n */\nconst extractQuestionTarget = (input: string): { targetWord: string | null; questionType: string | null } => {\n  const cleanInput = input.toLowerCase().trim();\n\n  // \"X nedir?\" kalıbı\n  const nedirMatch = cleanInput.match(/^(.+?)\\s*nedir\\s*\\??$/);\n  if (nedirMatch) {\n    return { targetWord: nedirMatch[1].trim(), questionType: 'nedir' };\n  }\n\n  // \"X ne demek?\" kalıbı\n  const neDemekMatch = cleanInput.match(/^(.+?)\\s*ne\\s*demek\\s*\\??$/);\n  if (neDemekMatch) {\n    return { targetWord: neDemekMatch[1].trim(), questionType: 'ne_demek' };\n  }\n\n  // \"X ne anlama gelir?\" kalıbı\n  const neAnlamaMatch = cleanInput.match(/^(.+?)\\s*ne\\s*anlama\\s*gelir\\s*\\??$/);\n  if (neAnlamaMatch) {\n    return { targetWord: neAnlamaMatch[1].trim(), questionType: 'ne_anlama_gelir' };\n  }\n\n  // \"X ne anlama geliyor?\" kalıbı\n  const neAnlamaGeliyorMatch = cleanInput.match(/^(.+?)\\s*ne\\s*anlama\\s*geliyor\\s*\\??$/);\n  if (neAnlamaGeliyorMatch) {\n    return { targetWord: neAnlamaGeliyorMatch[1].trim(), questionType: 'ne_anlama_gelir' };\n  }\n\n  // \"X'in anlamı nedir?\" kalıbı\n  const anlamiNedirMatch = cleanInput.match(/^(.+?)(?:'?(?:in|ın|un|ün))?\\s*anlamı\\s*nedir\\s*\\??$/);\n  if (anlamiNedirMatch) {\n    return { targetWord: anlamiNedirMatch[1].trim(), questionType: 'anlamı_nedir' };\n  }\n\n  // \"X'in anlamı ne?\" kalıbı\n  const anlamiNeMatch = cleanInput.match(/^(.+?)(?:'?(?:in|ın|un|ün))?\\s*anlamı\\s*ne\\s*\\??$/);\n  if (anlamiNeMatch) {\n    return { targetWord: anlamiNeMatch[1].trim(), questionType: 'anlamı_nedir' };\n  }\n\n  // \"X manası nedir?\" kalıbı\n  const manasiNedirMatch = cleanInput.match(/^(.+?)(?:'?(?:in|ın|un|ün))?\\s*manası\\s*nedir\\s*\\??$/);\n  if (manasiNedirMatch) {\n    return { targetWord: manasiNedirMatch[1].trim(), questionType: 'anlamı_nedir' };\n  }\n\n  // \"X kelimesi ne demek?\" kalıbı\n  const kelimesiNeDemekMatch = cleanInput.match(/^(.+?)\\s*kelimesi\\s*ne\\s*demek\\s*\\??$/);\n  if (kelimesiNeDemekMatch) {\n    return { targetWord: kelimesiNeDemekMatch[1].trim(), questionType: 'ne_demek' };\n  }\n\n  // \"X kelimesinin anlamı nedir?\" kalıbı\n  const kelimesinAnlamiMatch = cleanInput.match(/^(.+?)\\s*kelimesinin\\s*anlamı\\s*nedir\\s*\\??$/);\n  if (kelimesinAnlamiMatch) {\n    return { targetWord: kelimesinAnlamiMatch[1].trim(), questionType: 'anlamı_nedir' };\n  }\n\n  // \"X ne?\" kalıbı (daha dikkatli)\n  const neMatch = cleanInput.match(/^(.+?)\\s*ne\\s*\\??$/);\n  if (neMatch) {\n    const word = neMatch[1].trim();\n    // \"ne\", \"bu ne\", \"şu ne\", \"o ne\" gibi genel ifadeleri hariç tut\n    // Sadece belirli bir kelime soruluyorsa kabul et\n    if (!['bu', 'şu', 'o', 'ne', 'bunlar', 'şunlar', 'onlar', 'hangi', 'nasıl'].includes(word) && word.length > 1) {\n      return { targetWord: word, questionType: 'ne' };\n    }\n  }\n\n  // Tek kelime sorguları - \"selam?\" gibi\n  if (cleanInput.match(/^[a-zçğıöşüA-ZÇĞIİÖŞÜ]+\\?*$/)) {\n    const word = cleanInput.replace(/\\?/g, '').trim();\n    if (word.length > 2) {\n      return { targetWord: word, questionType: 'ne' };\n    }\n  }\n\n  return { targetWord: null, questionType: null };\n};\n\n/**\n * Basit anlamsal benzerlik hesaplama\n */\nconst calculateSemanticSimilarity = (text1: string, text2: string): number => {\n  const words1 = text1.toLowerCase().split(/\\s+/).filter(w => w.length > 2);\n  const words2 = text2.toLowerCase().split(/\\s+/).filter(w => w.length > 2);\n\n  if (words1.length === 0 || words2.length === 0) return 0;\n\n  const intersection = words1.filter(w => words2.includes(w)).length;\n  const union = new Set([...words1, ...words2]).size;\n\n  return intersection / union;\n};\n\n/**\n * Gelişmiş tekrar önleme fonksiyonu\n */\nconst removeDuplicateSentences = (text: string): string => {\n  if (!text || text.trim().length === 0) return '';\n\n  // Temel temizlik\n  text = text.replace(/\\s+/g, ' ').trim();\n\n  // Agresif tekrar kalıplarını temizle\n  text = text.replace(/(.+?[.!?])\\s*\\1+/gi, '$1'); // Tam cümle tekrarları\n  text = text.replace(/(.+?),\\s*\\1/gi, '$1'); // \"Merhaba, Merhaba\" => \"Merhaba\"\n  text = text.replace(/(\\b\\w+)\\s+\\1\\b/gi, '$1'); // \"Size Size\" => \"Size\"\n\n  // Virgül ve nokta ile bölünmüş tekrarları temizle\n  text = text.replace(/(.+?),\\s*(.+?)\\.\\s*\\1/gi, '$2.'); // \"A, B. A\" => \"B.\"\n\n  // Aynı ifadenin farklı noktalama ile tekrarını temizle\n  text = text.replace(/(.+?[.!?])\\s*(.+?),?\\s*\\1/gi, '$1');\n\n  // Cümleleri ayır\n  const sentences = text.split(/[.!?]+/).map(s => s.trim()).filter(s => s.length > 0);\n\n  if (sentences.length <= 1) {\n    return text.endsWith('.') || text.endsWith('!') || text.endsWith('?') ? text : text + '.';\n  }\n\n  // Gelişmiş benzersiz cümle seçimi\n  const uniqueSentences: string[] = [];\n\n  for (const sentence of sentences) {\n    if (sentence.length < 3) continue; // Çok kısa cümleleri atla\n\n    const normalizedSentence = sentence.toLowerCase()\n      .replace(/[^\\wçğıöşü\\s]/g, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n\n    // Benzer veya aynı cümle var mı kontrol et\n    const isDuplicate = uniqueSentences.some(existing => {\n      const normalizedExisting = existing.toLowerCase()\n        .replace(/[^\\wçğıöşü\\s]/g, '')\n        .replace(/\\s+/g, '')\n        .replace(/\\s+/g, ' ')\n        .trim();\n\n      // Tam eşleşme\n      if (normalizedExisting === normalizedSentence) return true;\n\n      // Bir cümle diğerinin içinde mi (90% benzerlik)\n      if (normalizedExisting.length > 0 && normalizedSentence.length > 0) {\n        const longer = normalizedExisting.length > normalizedSentence.length ? normalizedExisting : normalizedSentence;\n        const shorter = normalizedExisting.length > normalizedSentence.length ? normalizedSentence : normalizedExisting;\n\n        if (longer.includes(shorter) && shorter.length > longer.length * 0.7) return true;\n\n        // Kelime benzerliği kontrolü\n        const words1 = normalizedExisting.split(/\\s+/);\n        const words2 = normalizedSentence.split(/\\s+/);\n        const commonWords = words1.filter(w => words2.includes(w)).length;\n        const totalWords = Math.max(words1.length, words2.length);\n\n        return totalWords > 0 && (commonWords / totalWords) > 0.85;\n      }\n\n      return false;\n    });\n\n    if (!isDuplicate) {\n      uniqueSentences.push(sentence);\n    }\n  }\n\n  if (uniqueSentences.length === 0) {\n    return \"Size nasıl yardımcı olabilirim?\";\n  }\n\n  const result = uniqueSentences.join('. ');\n  return result.endsWith('.') || result.endsWith('!') || result.endsWith('?') ? result : result + '.';\n};\n\n/**\n * Kullanıcı girdisinin yanıt başında tekrarlanmasını önle\n */\nconst removeInputEcho = (response: string, userInput: string): string => {\n  if (!response || !userInput) return response;\n\n  const cleanResponse = response.trim();\n  const cleanInput = userInput.trim().toLowerCase();\n\n  // Yanıt kullanıcı girdisi ile başlıyorsa, o kısmı çıkar\n  if (cleanResponse.toLowerCase().startsWith(cleanInput)) {\n    const withoutEcho = cleanResponse.substring(cleanInput.length).trim();\n    // Başta kalan noktalama işaretlerini temizle\n    return withoutEcho.replace(/^[,.\\-:\\s]+/, '').trim();\n  }\n\n  return cleanResponse;\n};\n\n/**\n * Birinci yaklaşım: Eğitim verileri odaklı yanıt üretimi\n */\nconst generateTrainingBasedResponse = async (\n  activationResult: ActivationResult,\n  trainingData: TrainingPair[],\n  recentConversation: string = \"\"\n): Promise<{ response: string; usedTraining: TrainingPair | null; confidence: number; method: string }> => {\n  const { activatedNodes, primaryConcepts, confidence } = activationResult;\n\n  // ÖNCE kelime anlamı sorusu mu kontrol et\n  const { targetWord, questionType } = extractQuestionTarget(recentConversation);\n\n  // Eğer kelime anlamı sorusu ise, bu yaklaşımı tamamen devre dışı bırak\n  if (targetWord && questionType && ['nedir', 'ne_demek', 'ne', 'ne_anlama_gelir', 'anlamı_nedir'].includes(questionType)) {\n    // Kelime anlamı soruları için eğitim verisi yaklaşımını tamamen engelle\n    return {\n      response: `Kelime anlamı sorusu tespit edildi. Sözlük sistemine yönlendiriliyor.`,\n      usedTraining: null,\n      confidence: 0.1, // Çok düşük güven - seçilmemesi için\n      method: 'training_disabled_for_word_meaning'\n    };\n  }\n\n  // Normal sorular için eğitim verisinde tam eşleşme ara\n  const exactMatch = trainingData.find(pair => \n    pair.input.toLowerCase().trim() === recentConversation.toLowerCase().trim()\n  );\n\n  if (exactMatch) {\n    return {\n      response: exactMatch.output,\n      usedTraining: exactMatch,\n      confidence: 1.0,\n      method: 'exact_training_match'\n    };\n  }\n\n  // Ters sorgu kontrolü\n  if (recentConversation) {\n    const reverseResponse = findReverseAnswer(recentConversation, trainingData);\n    if (reverseResponse) {\n      let cleanResponse = reverseResponse.response;\n      cleanResponse = cleanResponse.replace(/Bu konuyla ilgili bildiğim[:]*\\s*/g, '')\n                                   .replace(/Bu konuda bildiğim[:]*\\s*/g, '')\n                                   .replace(/^\"(.+)\"$/g, '$1')\n                                   .trim();\n\n      return {\n        response: cleanResponse,\n        usedTraining: null,\n        confidence: reverseResponse.confidence,\n        method: 'reverse_training_match'\n      };\n    }\n  }\n\n  // En iyi eşleşme için eğitim verilerini kontrol et\n  let bestMatch: { pair: TrainingPair; score: number } | null = null;\n\n  for (const pair of trainingData) {\n    const inputWords = pair.input.toLowerCase().split(/\\s+/);\n    let matchScore = 0;\n\n    // Ana kavramlar için puan ver\n    for (const concept of primaryConcepts) {\n      if (pair.input.toLowerCase().includes(concept.toLowerCase())) {\n        matchScore += 3;\n      }\n    }\n\n    // İnput kelimelerinin eşleşme puanı\n    for (const word of inputWords) {\n      for (const concept of primaryConcepts) {\n        if (calculateWordSimilarity(word, concept.toLowerCase()) > 0.7) {\n          matchScore += 2;\n        }\n      }\n    }\n\n    // Önceki konuşma bağlamını kullan\n    if (recentConversation && pair.input.toLowerCase().includes(recentConversation.toLowerCase())) {\n      matchScore += 2;\n    }\n\n    if (!bestMatch || matchScore > bestMatch.score) {\n      bestMatch = { pair, score: matchScore };\n    }\n  }\n\n  if (bestMatch && bestMatch.score > 3) {\n    let response = bestMatch.pair.output;\n\n    // Eğitim verisi tekrarlarını temizle\n    response = response.replace(/Bu konuyla ilgili bildiğim[:]*\\s*/g, '')\n                      .replace(/Bu konuda bildiğim[:]*\\s*/g, '')\n                      .replace(/^\"(.+)\"$/g, '$1')\n                      .trim();\n\n    // Soru kelimelerinin cevabın başında tekrarlanmasını önle\n    if (recentConversation) {\n      const questionWords = recentConversation.toLowerCase().split(/\\s+/).filter(w => w.length > 3);\n      for (const word of questionWords) {\n        const wordRegex = new RegExp(`^${word}\\\\s+`, 'i');\n        response = response.replace(wordRegex, '');\n      }\n    }\n\n    // Yanıtı temizle\n    response = removeDuplicateSentences(response);\n\n    // Boş yanıt kontrolü\n    if (!response || response.trim().length < 3) {\n      response = \"Bu konuda daha detaylı bilgi verebilir misiniz?\";\n    }\n\n    if (!response.endsWith('.') && !response.endsWith('!') && !response.endsWith('?')) {\n      response += '.';\n    }\n\n    response = response.charAt(0).toUpperCase() + response.slice(1);\n\n    return {\n      response: response,\n      usedTraining: bestMatch.pair,\n      confidence: Math.min(0.9, confidence + 0.2),\n      method: 'best_training_match'\n    };\n  }\n\n  // Aktivasyon temelli yanıt\n  let response = \"\";\n  if (primaryConcepts.length > 0) {\n    const conceptsText = primaryConcepts.slice(0, 3).join(\", \");\n    response = `${conceptsText} hakkında konuşuyorsunuz. Daha spesifik bir soru sorabilir misiniz?`;\n  } else {\n    response = \"Bu konu hakkında daha detaylı bilgi verebilir misiniz?\";\n  }\n\n  response = removeDuplicateSentences(response);\n  response = response.charAt(0).toUpperCase() + response.slice(1);\n  if (!response.match(/[.!?]$/)) {\n    response += '.';\n  }\n\n  return {\n    response,\n    usedTraining: null,\n    confidence: Math.max(0.3, confidence),\n    method: 'activation_based'\n  };\n};\n\n/**\n * İkinci yaklaşım: Anlamsal analiz ve sözlük odaklı yanıt üretimi\n */\nconst generateSemanticBasedResponse = async (\n  activationResult: ActivationResult,\n  trainingData: TrainingPair[],\n  recentConversation: string = \"\",\n  turkishDictionary?: any\n): Promise<{ response: string; usedTraining: TrainingPair | null; confidence: number; method: string }> => {\n  const { activatedNodes } = activationResult;\n\n  // Türkçe sözlük ile anlamlandırma (varsa)\n  if (turkishDictionary && recentConversation) {\n    // Direkt soru kalıplarını kontrol et\n    const phraseAnalysis = turkishDictionary.analyzePhrase(recentConversation);\n\n    if (phraseAnalysis.semanticComponents?.expectedResponse && phraseAnalysis.confidence > 0.7) {\n      return {\n        response: phraseAnalysis.semanticComponents.expectedResponse,\n        usedTraining: null,\n        confidence: phraseAnalysis.confidence,\n        method: 'direct_dictionary_pattern'\n      };\n    }\n\n    // Gelişmiş anlamlandırma sistemini kullan\n    const semanticResult = performSemanticAnalysis(\n      recentConversation, \n      turkishDictionary, \n      trainingData,\n      activatedNodes\n    );\n\n    if (semanticResult) {\n      return {\n        response: semanticResult.response,\n        usedTraining: semanticResult.method === 'exact_training_match' || semanticResult.method === 'semantic_training_match' \n          ? trainingData.find(pair => pair.output === semanticResult.response) || null \n          : null,\n        confidence: semanticResult.confidence,\n        method: semanticResult.method\n      };\n    }\n  }\n\n  // Benzer eğitim verilerini ara\n  const similarTraining = trainingData.filter(pair => {\n    const similarity = calculateSemanticSimilarity(recentConversation, pair.input);\n    return similarity > 0.6;\n  });\n\n  if (similarTraining.length > 0) {\n    const bestMatch = similarTraining.reduce((best, current) => {\n      const currentSimilarity = calculateSemanticSimilarity(recentConversation, current.input);\n      const bestSimilarity = calculateSemanticSimilarity(recentConversation, best.input);\n      return currentSimilarity > bestSimilarity ? current : best;\n    });\n\n    return {\n      response: bestMatch.output,\n      usedTraining: bestMatch,\n      confidence: 0.8,\n      method: 'semantic_similarity_match'\n    };\n  }\n\n  // Fallback yanıt\n  return {\n    response: `Bu konuyu tam olarak anlayamadım. Lütfen daha açık bir şekilde sorar mısınız?`,\n    usedTraining: null,\n    confidence: 0.2,\n    method: 'semantic_fallback'\n  };\n};\n\n/**\n * Yanıt kalitesini değerlendirme fonksiyonu\n */\nconst evaluateResponseQuality = (\n  response: string,\n  confidence: number,\n  method: string,\n  usedTraining: TrainingPair | null,\n  recentConversation: string\n): number => {\n  let qualityScore = 0;\n\n  // Güven seviyesi (40% ağırlık)\n  qualityScore += confidence * 40;\n\n  // Yanıt uzunluğu ve anlamlılık (20% ağırlık)\n  const wordCount = response.split(/\\s+/).length;\n  if (wordCount >= 3 && wordCount <= 50) {\n    qualityScore += 20;\n  } else if (wordCount > 50) {\n    qualityScore += 10; // Çok uzun yanıtlar için daha düşük puan\n  }\n\n  // Metod kalitesi (25% ağırlık)\n  const methodScores: Record<string, number> = {\n    'exact_training_match': 25,\n    'direct_dictionary_pattern': 23,\n    'best_training_match': 20,\n    'reverse_training_match': 18,\n    'target_word_training_match': 16,\n    'semantic_training_match': 15,\n    'dictionary_definition': 12,\n    'semantic_similarity_match': 10,\n    'contextual_dictionary': 8,\n    'activation_based': 5,\n    'semantic_fallback': 2,\n    'word_not_found': 1,\n    'not_understood': 0\n  };\n\n  qualityScore += methodScores[method] || 0;\n\n  // Eğitim verisi kullanımı (10% ağırlık)\n  if (usedTraining) {\n    qualityScore += 10;\n  }\n\n  // Yanıt içeriği kontrolü (5% ağırlık)\n  if (!response.includes('bilmiyorum') && !response.includes('anlayamadım')) {\n    qualityScore += 5;\n  }\n\n  // Soru tekrarını kontrol et (negatif puan)\n  if (recentConversation && response.toLowerCase().includes(recentConversation.toLowerCase())) {\n    qualityScore -= 15;\n  }\n\n  return Math.max(0, Math.min(100, qualityScore));\n};\n\n/**\n * Gelişmiş cevap benzerlik karşılaştırması\n */\nconst calculateResponseSimilarity = (response1: string, response2: string): number => {\n  if (!response1 || !response2) return 0;\n\n  const normalize = (text: string) => text.toLowerCase()\n    .replace(/[^\\wçğıöşü\\s]/g, '')\n    .replace(/\\s+/g, ' ')\n    .trim();\n\n  const text1 = normalize(response1);\n  const text2 = normalize(response2);\n\n  // Tam eşleşme\n  if (text1 === text2) return 1.0;\n\n  // Boş metinlerden biri varsa\n  if (text1.length === 0 || text2.length === 0) return 0;\n\n  // Bir metin diğerinin %80'inden fazlasını içeriyorsa\n  const longer = text1.length > text2.length ? text1 : text2;\n  const shorter = text1.length > text2.length ? text2 : text1;\n\n  if (longer.includes(shorter) && shorter.length > longer.length * 0.8) {\n    return 0.95;\n  }\n\n  // Kelime bazlı Jaccard benzerliği\n  const words1 = text1.split(/\\s+/).filter(w => w.length > 2);\n  const words2 = text2.split(/\\s+/).filter(w => w.length > 2);\n\n  if (words1.length === 0 && words2.length === 0) return 1.0;\n  if (words1.length === 0 || words2.length === 0) return 0;\n\n  const intersection = words1.filter(w => words2.includes(w)).length;\n  const union = new Set([...words1, ...words2]).size;\n\n  const jaccardSimilarity = intersection / union;\n\n  // Cümle yapısı benzerliği (başlangıç ve bitiş kelimeleri)\n  const startSimilarity = words1[0] === words2[0] ? 0.1 : 0;\n  const endSimilarity = words1[words1.length - 1] === words2[words2.length - 1] ? 0.1 : 0;\n\n  // Uzunluk benzerliği (çok farklı uzunluklar farklı cevaplar olabilir)\n  const lengthRatio = Math.min(text1.length, text2.length) / Math.max(text1.length, text2.length);\n  const lengthPenalty = lengthRatio < 0.5 ? 0.2 : 0; // Çok farklı uzunluklar için ceza\n\n  return Math.max(0, jaccardSimilarity + startSimilarity + endSimilarity - lengthPenalty);\n};\n\n/**\n * Merkezi cevap seçme ve koordinasyon sistemi\n */\nexport const selectBestResponse = (responses: Array<{\n  response: string;\n  confidence: number;\n  method: string;\n  usedTraining?: TrainingPair | null;\n  source: string;\n}>): {\n  response: string;\n  confidence: number;\n  method: string;\n  usedTraining?: TrainingPair | null;\n  notification: string;\n} => {\n  if (responses.length === 0) {\n    return {\n      response: \"Üzgünüm, yanıt üretemiyorum.\",\n      confidence: 0.1,\n      method: \"fallback\",\n      notification: \"❌ Hiçbir yanıt üretilemedi\"\n    };\n  }\n\n  if (responses.length === 1) {\n    return {\n      ...responses[0],\n      response: removeDuplicateSentences(responses[0].response),\n      notification: `✅ ${responses[0].source} kullanıldı`\n    };\n  }\n\n  // 1. Önce aynı/benzer cevapları tespit et - daha sıkı kontrol\n  const similarGroups: Array<Array<typeof responses[0]>> = [];\n  const processed = new Set<number>();\n\n  for (let i = 0; i < responses.length; i++) {\n    if (processed.has(i)) continue;\n\n    const group = [responses[i]];\n    processed.add(i);\n\n    for (let j = i + 1; j < responses.length; j++) {\n      if (processed.has(j)) continue;\n\n      const similarity = calculateResponseSimilarity(responses[i].response, responses[j].response);\n      if (similarity > 0.6) { // Eşiği düşürdük - daha fazla benzer yanıt yakala\n        group.push(responses[j]);\n        processed.add(j);\n      }\n    }\n\n    similarGroups.push(group);\n  }\n\n  // 2. Eğer tüm yanıtlar benzer ise, en yüksek güven skoruna sahip olanı seç\n  if (similarGroups.length === 1 && similarGroups[0].length === responses.length) {\n    const bestResponse = responses.reduce((best, current) => \n      current.confidence > best.confidence ? current : best\n    );\n\n    return {\n      response: removeDuplicateSentences(bestResponse.response),\n      confidence: bestResponse.confidence,\n      method: bestResponse.method,\n      usedTraining: bestResponse.usedTraining,\n      notification: `🎯 Benzer yanıtlar arasından en güvenilir seçildi (${bestResponse.source})`\n    };\n  }\n\n  // 3. Her gruptan en iyi yanıtı seç\n  const bestFromEachGroup = similarGroups.map(group => {\n    // Grup içinde en yüksek güven skoru + en iyi metod\n    const methodPriority = {\n      'exact_training_match': 100,\n      'direct_dictionary_pattern': 95,\n      'best_training_match': 90,\n      'reverse_training_match': 85,\n      'target_word_training_match': 80,\n      'semantic_training_match': 75,\n      'dictionary_definition': 70,\n      'contextual_dictionary': 65,\n      'semantic_similarity_match': 60,\n      'activation_based': 55,\n      'semantic_fallback': 50,\n      'not_understood': 45,\n      'word_not_found': 40,\n      'unknown_words': 35,\n      'fallback': 30\n    };\n\n    const scored = group.map(response => ({\n      ...response,\n      score: (response.confidence * 70) + ((methodPriority[response.method] || 30) * 0.3)\n    }));\n\n    return scored.reduce((best, current) => current.score > best.score ? current : best);\n  });\n\n  // 4. Final seçim - en yüksek skorlu yanıt\n  const finalResponse = bestFromEachGroup.reduce((best, current) => \n    current.score > best.score ? current : best\n  );\n\n  // 5. Bildirim mesajı oluştur\n  let notification = '';\n  if (similarGroups.length > 1) {\n    notification = `🎯 ${responses.length} farklı yanıt arasından ${finalResponse.source} seçildi`;\n  } else {\n    notification = `✅ En güvenilir yanıt seçildi (${finalResponse.source})`;\n  }\n\n  return {\n    response: removeDuplicateSentences(finalResponse.response),\n    confidence: finalResponse.confidence,\n    method: finalResponse.method,\n    usedTraining: finalResponse.usedTraining,\n    notification\n  };\n};\n\n/**\n * Gelişmiş duygu analizi yap\n */\nexport const analyzeEmotionalState = (text: string): any => {\n  const emotionPatterns = {\n    merak: ['nasıl', 'neden', 'nedir', 'mi', 'mı', 'ne zaman', 'hangi'],\n    üzüntü: ['üzgün', 'kötü', 'maalesef', 'keşke', 'ah'],\n    sevinç: ['mutlu', 'harika', 'güzel', 'sevindim', 'teşekkür'],\n    endişe: ['endişe', 'korku', 'acaba', 'ya', 'risk'],\n    heyecan: ['heyecan', 'wow', 'vay', 'inanılmaz', 'muhteşem']\n  };\n\n  let maxEmotion = 'nötr';\n  let maxScore = 0;\n  const subEmotions = [];\n\n  // Duygu yoğunluğunu analiz et\n  for (const [emotion, patterns] of Object.entries(emotionPatterns)) {\n    let score = 0;\n    for (const pattern of patterns) {\n      if (text.toLowerCase().includes(pattern)) {\n        score += 0.2;\n        if (!subEmotions.includes(pattern)) {\n          subEmotions.push(pattern);\n        }\n      }\n    }\n    if (score > maxScore) {\n      maxScore = score;\n      maxEmotion = emotion;\n    }\n  }\n\n  return {\n    primary: maxScore > 0 ? maxEmotion as any : 'nötr',\n    intensity: Math.min(1, maxScore),\n    subEmotions\n  };\n};\n\n/**\n * Kişilik profili oluştur/güncelle \n */\nexport const updatePersonalityProfile = (\n  text: string,\n  currentProfile?: Memory['personality']\n): Memory['personality'] => {\n  const newProfile = currentProfile || {\n    interests: [],\n    preferences: {},\n    traits: [],\n    relationshipLevel: 0\n  };\n\n  // İlgi alanlarını analiz et\n  const interests = text.match(/(?:sev|ilgilen|hoşlan|beğen).+?([\\w\\s]+)/g);\n  if (interests) {\n    interests.forEach(interest => {\n      if (!newProfile.interests.includes(interest)) {\n        newProfile.interests.push(interest);\n      }\n    });\n  }\n\n  // Tercihleri güncelle\n  const preferences = text.match(/tercih|isterim|istemem|daha çok|yerine/g);\n  if (preferences) {\n    preferences.forEach(pref => {\n      newProfile.preferences[pref] = (newProfile.preferences[pref] || 0) + 0.1;\n    });\n  }\n\n  // İlişki seviyesini güncelle\n  const friendshipIndicators = text.match(/teşekkür|rica|dostum|arkadaş|güven/g);\n  if (friendshipIndicators) {\n    newProfile.relationshipLevel = Math.min(1, newProfile.relationshipLevel + 0.05);\n  }\n\n  return newProfile;\n};\n\n/**\n * Farkındalık ve gelişim takibi\n */\nexport const updateConsciousness = (\n  text: string,\n  currentState?: Memory['consciousness']\n): Memory['consciousness'] => {\n  const newState = currentState || {\n    awareness: 0,\n    insights: [],\n    developmentPath: []\n  };\n\n  // Farkındalık seviyesini güncelle\n  const awarenessIndicators = text.match(/farkında|anladım|öğrendim|kavradım/g);\n  if (awarenessIndicators) {\n    newState.awareness = Math.min(1, newState.awareness + 0.1);\n  }\n\n  // Yeni içgörüler ekle\n  const insights = text.match(/(?:demek ki|yani|aslında).+?[.!?]/g);\n  if (insights) {\n    insights.forEach(insight => {\n      if (!newState.insights.includes(insight)) {\n        newState.insights.push(insight);\n      }\n    });\n  }\n\n  // Gelişim yolunu güncelle\n  const developmentIndicators = text.match(/gelişmek|ilerlemek|öğrenmek|hedef/g);\n  if (developmentIndicators) {\n    developmentIndicators.forEach(indicator => {\n      if (!newState.developmentPath.includes(indicator)) {\n        newState.developmentPath.push(indicator);\n      }\n    });\n  }\n\n  return newState;\n};\n\n/**\n * Adaptif özellikler ve sürekli gelişim\n */\nexport const updateAdaptiveFeatures = (\n  text: string,\n  currentFeatures?: Memory['adaptiveFeatures']\n): Memory['adaptiveFeatures'] => {\n  const newFeatures = currentFeatures || {\n    newPatterns: [],\n    learnedSkills: [],\n    improvements: []\n  };\n\n  // Yeni örüntüleri tespit et\n  const patterns = text.match(/(?:her zaman|genellikle|sıklıkla).+?[.!?]/g);\n  if (patterns) {\n    patterns.forEach(pattern => {\n      if (!newFeatures.newPatterns.includes(pattern)) {\n        newFeatures.newPatterns.push(pattern);\n      }\n    });\n  }\n\n  // Öğrenilen becerileri güncelle\n  const skills = text.match(/(?:yapabilirim|öğrendim|biliyorum).+?[.!?]/g);\n  if (skills) {\n    skills.forEach(skill => {\n      if (!newFeatures.learnedSkills.includes(skill)) {\n        newFeatures.learnedSkills.push(skill);\n      }\n    });\n  }\n\n  // Gelişim alanlarını belirle\n  const improvements = text.match(/(?:geliştirmek|iyileştirmek|düzeltmek).+?[.!?]/g);\n  if (improvements) {\n    improvements.forEach(improvement => {\n      if (!newFeatures.improvements.includes(improvement)) {\n        newFeatures.improvements.push(improvement);\n      }\n    });\n  }\n\n  return newFeatures;\n};\n\n/**\n * Kullanıcı girdisini işle - Merkezi koordinasyon sistemi\n */\nexport const processUserInput = async (\n  input: string,\n  options?: {\n    userNetworks?: (NetworkNode | null)[][][];\n    systemNetworks?: (NetworkNode | null)[][][];\n    relations?: Relation[];\n    bidirectionalRelations?: Relation[];\n    trainingData?: TrainingPair[];\n    turkishDictionary?: any;\n    memorySystem?: EnhancedMemorySystem;\n  }\n): Promise<{ response: string; usedTraining: TrainingPair | null; confidence: number; notification?: string }> => {\n\n  // Varsayılan değerler\n  const userNetworks = options?.userNetworks || [];\n  const systemNetworks = options?.systemNetworks || [];\n  const relations = options?.relations || [];\n  const bidirectionalRelations = options?.bidirectionalRelations || [];\n  const trainingData = options?.trainingData || [];\n  const turkishDictionary = options?.turkishDictionary;\n  const memorySystem = options?.memorySystem;\n\n  // Aktivasyon analizi yap\n  const activationResult = propagateActivation(userNetworks, systemNetworks, relations, input);\n\n  // Çoklu kaynak yanıt üretimi\n  const responses: Array<{\n    response: string;\n    confidence: number;\n    method: string;\n    usedTraining?: TrainingPair | null;\n    source: string;\n  }> = [];\n\n  // 1. Eğitim verisi temelli yanıt\n  try {\n    const trainingResponse = await generateTrainingBasedResponse(activationResult, trainingData, input);\n    responses.push({\n      response: trainingResponse.response,\n      confidence: trainingResponse.confidence,\n      method: trainingResponse.method,\n      usedTraining: trainingResponse.usedTraining,\n      source: \"Eğitim Verileri\"\n    });\n  } catch (error) {\n    console.error('Eğitim temelli yanıt hatası:', error);\n  }\n\n  // 2. Anlamsal analiz temelli yanıt\n  if (turkishDictionary && memorySystem) {\n    try {\n      const semanticResponse = await generateSemanticBasedResponse(activationResult, trainingData, input, turkishDictionary);\n      responses.push({\n        response: semanticResponse.response,\n        confidence: semanticResponse.confidence,\n        method: semanticResponse.method,\n        usedTraining: semanticResponse.usedTraining,\n        source: \"Anlamsal Analiz\"\n      });\n    } catch (error) {\n      console.error('Anlamsal yanıt hatası:', error);\n    }\n  }\n\n  // 3. Ters sorgu kontrolü\n  if (input && trainingData.length > 0) {\n    try {\n      const reverseResponse = findReverseAnswer(input, trainingData);\n      if (reverseResponse && reverseResponse.confidence > 0.5) {\n        responses.push({\n          response: reverseResponse.response,\n          confidence: reverseResponse.confidence,\n          method: \"reverse_query\",\n          source: \"Ters Sorgu\"\n        });\n      }\n    } catch (error) {\n      console.error('Ters sorgu hatası:', error);\n    }\n  }\n\n  // 4. Aktivasyon temelli basit yanıt (fallback)\n  if (activationResult.primaryConcepts.length > 0) {\n    const concepts = activationResult.primaryConcepts.slice(0, 3).join(\", \");\n    responses.push({\n      response: `${concepts} hakkında konuşuyorsunuz. Size nasıl yardımcı olabilirim?`,\n      confidence: Math.max(0.3, activationResult.confidence),\n      method: \"activation_fallback\",\n      source: \"Aktivasyon Ağı\"\n    });\n  }\n\n  // 5. Son çare fallback\n  if (responses.length === 0) {\n    responses.push({\n      response: \"Bu konuyu tam olarak anlayamadım. Lütfen daha açık bir şekilde sorar mısınız?\",\n      confidence: 0.2,\n      method: \"ultimate_fallback\",\n      source: \"Son Çare\"\n    });\n  }\n\n  // Merkezi seçim sistemi ile en iyi yanıtı belirle\n  const selectedResponse = selectBestResponse(responses);\n\n  // Giriş yankısını temizle\n  selectedResponse.response = removeInputEcho(selectedResponse.response, input);\n\n  // Otomatik eğitim sistemi - Kelime anlamı sorularında devre dışı bırak\n  const { targetWord, questionType } = extractQuestionTarget(input);\n  const isWordMeaningQuery = targetWord && questionType && \n    ['nedir', 'ne_demek', 'ne', 'ne_anlama_gelir', 'anlamı_nedir'].includes(questionType);\n\n  if (!isWordMeaningQuery && input && selectedResponse.response && input.length > 2 && selectedResponse.response.length > 2) {\n    // Sözlük yanıtlarını otomatik eğitime dahil etme\n    const isDictionaryResponse = selectedResponse.method && \n      (selectedResponse.method.includes('dictionary') || \n       selectedResponse.response.match(/^[\\w\\s]+:\\s+.+\\s+\\([a-züğıöçş]+\\)$/i));\n\n    if (!isDictionaryResponse) {\n      // Sessiz eğitim - log azaltıldı\n      trainNetwork(input, selectedResponse.response);\n    }\n  }\n\n  return {\n    response: selectedResponse.response,\n    usedTraining: selectedResponse.usedTraining,\n    confidence: selectedResponse.confidence,\n    notification: selectedResponse.notification\n  };\n};\n\n/**\n * Gelişmiş eşleşme skoru hesaplama\n */\nfunction calculateAdvancedMatchScore(input1: string, input2: string): number {\n  const words1 = input1.toLowerCase().split(/\\s+/).filter(w => w.length > 1);\n  const words2 = input2.toLowerCase().split(/\\s+/).filter(w => w.length > 1);\n\n  let score = 0;\n  let maxScore = Math.max(words1.length, words2.length);\n\n  for (const word1 of words1) {\n    for (const word2 of words2) {\n      if (word1 === word2) {\n        score += 1.0; // Tam eşleşme\n      } else if (word1.includes(word2) || word2.includes(word1)) {\n        score += 0.7; /// Kısmi eşleşme\n      } else if (Math.abs(word1.length - word2.length) <= 2) {\n        // Levenshtein mesafesi benzeri basit kontrol\n        const similarity = calculateWordSimilarity(word1, word2);\n        if (similarity > 0.6) {\n          score += similarity * 0.5;\n        }\n      }\n    }\n  }\n\n  return maxScore > 0 ? score / maxScore : 0;\n}","size_bytes":79212},"client/src/lib/NeuralNetworkUtils.tsx":{"content":"/**\n * Yapay Sinir Ağı Yardımcı Fonksiyonları\n */\n\n// Sabitler\nexport const INITIAL_GRID_ROWS = 12;\nexport const INITIAL_GRID_COLS = 24;\nexport const INITIAL_NETWORK_LAYERS = 4;\nexport const MIN_RELATION_SCORE = 25;\nexport const LEARNING_RATE = 0.18;\nexport const MAX_NETWORK_SIZE = 60;\n\n// Gelişmiş parametreler\nexport const ACTIVATION_DECAY_RATE = 0.05;  // Aktivasyon azalma hızı\nexport const CONNECTION_THRESHOLD = 0.25;   // Bağlantı oluşturma eşiği\nexport const MAX_CONNECTIONS_PER_NODE = 12; // Bir düğümün maksimum bağlantı sayısı\nexport const REINFORCEMENT_RATE = 0.12;     // Pekiştirme öğrenme hızı\nexport const FORGET_RATE = 0.08;            // Unutma hızı\nexport const NEUROPLASTICITY = 0.15;        // Ağın adapte olma yeteneği\n\n/**\n * Boş bir ızgara oluştur\n */\nexport const createEmptyGrid = (rows: number, cols: number): (NetworkNode | null)[][] => {\n  const grid: (NetworkNode | null)[][] = [];\n  for (let i = 0; i < rows; i++) {\n    grid[i] = [];\n    for (let j = 0; j < cols; j++) {\n      grid[i][j] = null;\n    }\n  }\n  return grid;\n};\n\n/**\n * Ağa yeni hücre ekle\n * @param networks Mevcut ağ katmanları\n * @param increaseAmount Eklenecek hücre sayısı\n * @returns Güncellenmiş ağ katmanları\n */\nexport const addCellsToNetwork = (\n  networks: (NetworkNode | null)[][][],\n  increaseAmount: number = 2\n): (NetworkNode | null)[][][] => {\n  // Ağın mevcut yapısını koru\n  const updatedNetworks = JSON.parse(JSON.stringify(networks)) as (NetworkNode | null)[][][];\n  \n  // Her katmana hücre ekle\n  for (let layer = 0; layer < updatedNetworks.length; layer++) {\n    // Mevcut satır sayısı\n    const currentRows = updatedNetworks[layer].length;\n    \n    // Yeni satırlar ekle\n    for (let i = 0; i < increaseAmount; i++) {\n      const newRow: (NetworkNode | null)[] = [];\n      \n      // Her sütun için null değer ekle\n      for (let col = 0; col < updatedNetworks[layer][0].length; col++) {\n        newRow.push(null);\n      }\n      \n      // Yeni satırı ekle\n      updatedNetworks[layer].push(newRow);\n    }\n  }\n  \n  return updatedNetworks;\n};\n\n/**\n * Ağdan hücre sil\n * @param networks Mevcut ağ katmanları\n * @param decreaseAmount Silinecek hücre sayısı\n * @returns Güncellenmiş ağ katmanları\n */\nexport const removeCellsFromNetwork = (\n  networks: (NetworkNode | null)[][][],\n  decreaseAmount: number = 2\n): (NetworkNode | null)[][][] => {\n  // Ağın mevcut yapısını koru\n  const updatedNetworks = JSON.parse(JSON.stringify(networks)) as (NetworkNode | null)[][][];\n  \n  // Her katmandan hücre sil (en az 4 satır kalacak şekilde)\n  for (let layer = 0; layer < updatedNetworks.length; layer++) {\n    // Mevcut satır sayısı\n    const currentRows = updatedNetworks[layer].length;\n    \n    // Minimum 4 satır kalacak şekilde hesapla\n    const rowsToRemove = Math.min(decreaseAmount, currentRows - 4);\n    \n    if (rowsToRemove > 0) {\n      // Son satırdan başlayarak sil (içinde düğüm olmayan satırları tercih et)\n      const rowsToKeep = currentRows - rowsToRemove;\n      const newRows: (NetworkNode | null)[][] = [];\n      \n      // Önce düğüm içeren satırları koru\n      let nonEmptyRows = 0;\n      for (let row = 0; row < currentRows; row++) {\n        const hasNodes = updatedNetworks[layer][row].some(node => node !== null);\n        if (hasNodes && nonEmptyRows < rowsToKeep) {\n          newRows.push(updatedNetworks[layer][row]);\n          nonEmptyRows++;\n        }\n      }\n      \n      // Boş satırları ekleyerek row sayısını tamamla\n      let remainingRows = rowsToKeep - nonEmptyRows;\n      if (remainingRows > 0) {\n        for (let row = 0; row < currentRows && remainingRows > 0; row++) {\n          const hasNodes = updatedNetworks[layer][row].some(node => node !== null);\n          if (!hasNodes && !newRows.includes(updatedNetworks[layer][row])) {\n            newRows.push(updatedNetworks[layer][row]);\n            remainingRows--;\n          }\n        }\n      }\n      \n      // Yeni ızgarayı güncelle\n      updatedNetworks[layer] = newRows;\n    }\n  }\n  \n  return updatedNetworks;\n};\n\n/**\n * Ağ düğümü arayüzü\n */\nexport interface NetworkNode {\n  id: string;                // Benzersiz düğüm kimliği\n  word: string;              // Düğümün temsil ettiği kelime\n  activation: number;        // Aktivasyon seviyesi (0-1)\n  count: number;             // Kullanım sayısı\n  connections: string[];     // Bağlantılar (diğer düğüm kimlikleri)\n  dependency: number;        // Bağımlılık değeri (0-100)\n  association: number;       // İlişki değeri (0-100)\n  frequency: number;         // Kullanım sıklığı\n  order: number;             // Sıra değeri\n  feedback: number;          // Kullanıcı geri bildirimi (-100 ile 100 arası)\n  depth: number;             // Ağ derinliği\n  parentWords: string[];     // Üst düğümler\n  \n  // Gelişmiş özellikler\n  lastActivation: number;    // Son aktivasyon zamanı\n  activationHistory: number[]; // Aktivasyon geçmişi\n  semanticVector?: number[]; // Anlamsal vektör (embedding)\n  category?: string;         // Kategori (ör: isim, fiil, sıfat)\n  sentiment?: number;        // Duygu değeri (-1 ile 1 arası)\n  importance?: number;       // Önem değeri (0-100)\n  connectionStrengths?: { [nodeId: string]: number }; // Bağlantı güç değerleri\n  createdAt: number;         // Oluşturulma zamanı\n  modifiedAt: number;        // Son değiştirilme zamanı\n}\n\n/**\n * İlişki arayüzü (geliştilmiş)\n */\nexport interface Relation {\n  id: string;                // Benzersiz ilişki kimliği\n  userWord: string;          // Kullanıcı kelimesi\n  systemWord: string;        // Sistem kelimesi\n  dependency: number;        // Bağımlılık değeri (0-100)\n  association: number;       // İlişki değeri (0-100) \n  frequency: number;         // Sıklık değeri\n  order: number;             // Sıra değeri\n  feedback: number;          // Kullanıcı geri bildirimi\n  isReversed?: boolean;      // Ters ilişki mi?\n  ai_generated?: boolean;    // Yapay zeka tarafından oluşturuldu mu?\n  \n  // Gelişmiş özellikler\n  strength: number;          // İlişki gücü (0-100)\n  context?: string[];        // İlişki bağlamı\n  learningCount: number;     // Öğrenme sayısı\n  lastUsed: number;          // Son kullanım zamanı\n  creationTime: number;      // Oluşturulma zamanı\n  relationType?: 'semantic' | 'temporal' | 'causal' | 'hierarchical'; // İlişki tipi\n  bidirectional: boolean;    // İki yönlü mü?\n  confidence: number;        // Güven değeri (0-1)\n}\n\n/**\n * Eğitim çifti arayüzü\n */\nexport interface TrainingPair {\n  id: string;                // Benzersiz eğitim kimliği\n  input: string;             // Girdi metni\n  output: string;            // Çıktı metni\n  timestamp: number;         // Tarih damgası\n  score?: number;            // Kalite puanı (0-100)\n  difficulty?: number;       // Zorluk derecesi (0-100)\n  category?: string;         // Kategori\n  tags?: string[];           // Etiketler\n  usageCount: number;        // Kullanım sayısı\n}\n\n/**\n * Aktivasyon yayılımı sonucu\n */\nexport interface ActivationResult {\n  activationPath: {\n    layer: number;\n    row: number;\n    col: number;\n    type: 'user' | 'system';\n    value: number;\n    word: string;\n  }[];\n  activatedNodes: NetworkNode[];\n  activatedRelations: Relation[];\n  primaryConcepts: string[];\n  responseScore: number;\n  confidence: number;\n  processingTime: number;\n}\n\n// Bu fonksiyon yukarıda tanımlandı\n\n/**\n * Kelime için pozisyon bul\n */\nexport const findPositionForWord = (\n  grid: (NetworkNode | null)[][],\n  centerX = Math.floor(grid[0].length / 2),\n  centerY = Math.floor(grid.length / 2),\n  maxDistance = 5\n): { row: number; col: number } | null => {\n  // Spiral arama algoritması ile boş pozisyonu bul\n  for (let distance = 0; distance <= maxDistance; distance++) {\n    // Üst kenar\n    for (let i = -distance; i <= distance; i++) {\n      const row = centerY - distance;\n      const col = centerX + i;\n      if (row >= 0 && row < grid.length && col >= 0 && col < grid[0].length && !grid[row][col]) {\n        return { row, col };\n      }\n    }\n    \n    // Sağ kenar\n    for (let i = -distance + 1; i <= distance; i++) {\n      const row = centerY + i;\n      const col = centerX + distance;\n      if (row >= 0 && row < grid.length && col >= 0 && col < grid[0].length && !grid[row][col]) {\n        return { row, col };\n      }\n    }\n    \n    // Alt kenar\n    for (let i = distance - 1; i >= -distance; i--) {\n      const row = centerY + distance;\n      const col = centerX + i;\n      if (row >= 0 && row < grid.length && col >= 0 && col < grid[0].length && !grid[row][col]) {\n        return { row, col };\n      }\n    }\n    \n    // Sol kenar\n    for (let i = distance - 1; i >= -distance + 1; i--) {\n      const row = centerY + i;\n      const col = centerX - distance;\n      if (row >= 0 && row < grid.length && col >= 0 && col < grid[0].length && !grid[row][col]) {\n        return { row, col };\n      }\n    }\n  }\n  \n  return null;\n};\n\n/**\n * Benzersiz kimlik oluştur\n */\nexport const uuid = (): string => {\n  return Date.now().toString(36) + Math.random().toString(36).substring(2);\n};\n\n/**\n * Kelimeyi ağa ekle (geliştirilmiş)\n */\nexport const addWordToNetwork = (\n  word: string,\n  network: (NetworkNode | null)[][][],\n  layer: number,\n  existingNodes: Map<string, { node: NetworkNode, layer: number, row: number, col: number }>,\n  parentWord?: string\n): NetworkNode | null => {\n  // Kelimenin kimliğini oluştur\n  const wordId = word.toLowerCase() + \"-\" + uuid();\n  \n  // Eğer kelime zaten varsa, mevcut düğümü güçlendir ve döndür\n  for (const [_, info] of existingNodes.entries()) {\n    if (info.node.word.toLowerCase() === word.toLowerCase()) {\n      // Mevcut düğümü güncelle (kullanım sayısını arttır)\n      info.node.count += 1;\n      info.node.frequency += 1;\n      info.node.modifiedAt = Date.now();\n      \n      // Aktivasyon değerini arttır\n      info.node.activation = Math.min(1, info.node.activation + 0.2);\n      info.node.activationHistory.push(info.node.activation);\n      \n      // Ebeveyn kelime varsa bağlantı ekle\n      if (parentWord) {\n        const parentInfo = Array.from(existingNodes.values()).find(n => \n          n.node.word.toLowerCase() === parentWord.toLowerCase()\n        );\n        \n        if (parentInfo) {\n          // Ebeveyn bağlantısı ekle\n          if (!info.node.parentWords.includes(parentWord)) {\n            info.node.parentWords.push(parentWord);\n          }\n          \n          // Çift yönlü bağlantı\n          if (!info.node.connections.includes(parentInfo.node.id)) {\n            info.node.connections.push(parentInfo.node.id);\n          }\n          \n          if (!parentInfo.node.connections.includes(info.node.id)) {\n            parentInfo.node.connections.push(info.node.id);\n          }\n          \n          // Bağlantı güçlerini güncelle\n          info.node.connectionStrengths = info.node.connectionStrengths || {};\n          parentInfo.node.connectionStrengths = parentInfo.node.connectionStrengths || {};\n          \n          info.node.connectionStrengths[parentInfo.node.id] = \n            (info.node.connectionStrengths[parentInfo.node.id] || 0) + 0.1;\n          \n          parentInfo.node.connectionStrengths[info.node.id] = \n            (parentInfo.node.connectionStrengths[info.node.id] || 0) + 0.1;\n        }\n      }\n      \n      return info.node;\n    }\n  }\n  \n  // Kelime ağda yoksa, bu katmanda yeni pozisyon bul\n  const grid = network[layer];\n  const position = findPositionForWord(grid);\n  \n  if (!position) {\n    console.error(`Kelime '${word}' için pozisyon bulunamadı (katman ${layer})`);\n    return null;\n  }\n  \n  // Anlamsal vektör oluştur\n  const semanticVector = generateSimpleSemanticVector(word);\n  \n  // Kategoriyi belirle\n  const category = categorizeWord(word);\n  \n  // Duygu değerini hesapla\n  const sentiment = calculateSentiment(word);\n  \n  // Yeni düğüm oluştur\n  const newNode: NetworkNode = {\n    id: wordId,\n    word: word,\n    activation: 0.8, // Başlangıçta yüksek aktivasyon\n    count: 1,\n    connections: [],\n    dependency: Math.floor(Math.random() * 40) + 20, // 20-60 arası\n    association: Math.floor(Math.random() * 40) + 20, // 20-60 arası\n    frequency: 1,\n    order: 1,\n    feedback: 0,\n    depth: layer,\n    parentWords: parentWord ? [parentWord] : [],\n    \n    // Gelişmiş özellikler\n    lastActivation: Date.now(),\n    activationHistory: [0.8], // Başlangıç aktivasyonu\n    semanticVector: semanticVector,\n    category: category,\n    sentiment: sentiment,\n    importance: Math.floor(Math.random() * 30) + 10, // 10-40 arası\n    connectionStrengths: {},\n    createdAt: Date.now(),\n    modifiedAt: Date.now()\n  };\n  \n  // Düğümü ağa yerleştir\n  grid[position.row][position.col] = newNode;\n  \n  // Düğüm bilgilerini kaydet\n  existingNodes.set(newNode.id, {\n    node: newNode,\n    layer,\n    row: position.row,\n    col: position.col\n  });\n  \n  // Ebeveyn kelime varsa bağlantı ekle\n  if (parentWord) {\n    const parentInfo = Array.from(existingNodes.values()).find(n => \n      n.node.word.toLowerCase() === parentWord.toLowerCase()\n    );\n    \n    if (parentInfo) {\n      // Çift yönlü bağlantı\n      newNode.connections.push(parentInfo.node.id);\n      parentInfo.node.connections.push(newNode.id);\n      \n      // Bağlantı güçlerini ayarla\n      newNode.connectionStrengths = newNode.connectionStrengths || {};\n      parentInfo.node.connectionStrengths = parentInfo.node.connectionStrengths || {};\n      \n      newNode.connectionStrengths[parentInfo.node.id] = 0.5; // Başlangıç gücü\n      parentInfo.node.connectionStrengths[newNode.id] = 0.5; // Başlangıç gücü\n    }\n  }\n  \n  return newNode;\n};\n\n/**\n * Ağda düğüm bul\n */\nfunction findNodeInNetwork(network: (NetworkNode | null)[][][], nodeId: string): NetworkNode | null {\n  for (let layer = 0; layer < network.length; layer++) {\n    for (let row = 0; row < network[layer].length; row++) {\n      for (let col = 0; col < network[layer][0].length; col++) {\n        const node = network[layer][row][col];\n        if (node && node.id === nodeId) {\n          return node;\n        }\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Kosinüs benzerliği hesapla\n */\nfunction calculateCosineSimilarity(vec1: number[], vec2: number[]): number {\n  if (vec1.length !== vec2.length) {\n    return 0;\n  }\n  \n  let dotProduct = 0;\n  let mag1 = 0;\n  let mag2 = 0;\n  \n  for (let i = 0; i < vec1.length; i++) {\n    dotProduct += vec1[i] * vec2[i];\n    mag1 += vec1[i] * vec1[i];\n    mag2 += vec2[i] * vec2[i];\n  }\n  \n  mag1 = Math.sqrt(mag1);\n  mag2 = Math.sqrt(mag2);\n  \n  const mag = mag1 * mag2;\n  return mag === 0 ? 0 : dotProduct / mag;\n}\n\n/**\n * Basit anlamsal vektör oluştur\n */\nfunction generateSimpleSemanticVector(word: string): number[] {\n  // Gerçek bir uygulamada, bu bir word embedding API'si olabilir\n  // Burada basit bir yaklaşım kullanıyoruz\n  const vector = [];\n  const seed = word.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);\n  \n  const random = (n: number) => {\n    const x = Math.sin(n) * 10000;\n    return x - Math.floor(x);\n  };\n  \n  for (let i = 0; i < 5; i++) {\n    vector.push((random(seed + i) * 2) - 1); // -1 ile 1 arasında değerler\n  }\n  \n  return vector;\n}\n\n/**\n * Kelimeyi kategorize et\n */\nfunction categorizeWord(word: string): string {\n  const categories: Record<string, string[]> = {\n    'isim': ['insan', 'araba', 'ev', 'kitap', 'bilgisayar', 'telefon', 'masa', 'sandalye'],\n    'fiil': ['gitmek', 'gelmek', 'yapmak', 'etmek', 'söylemek', 'görmek', 'duymak', 'hissetmek'],\n    'sıfat': ['güzel', 'iyi', 'kötü', 'büyük', 'küçük', 'hızlı', 'yavaş', 'uzun', 'kısa', 'yüksek'],\n    'zamir': ['ben', 'sen', 'o', 'biz', 'siz', 'onlar', 'bu', 'şu', 'kim', 'ne', 'kendi'],\n    'bağlaç': ['ve', 'veya', 'ama', 'fakat', 'çünkü', 'eğer', 'ile', 'ancak', 'ya da'],\n    'edat': ['için', 'gibi', 'kadar', 'göre', 'dolayı', 'beri', 'önce', 'sonra', 'rağmen'],\n    'nicelik': ['bir', 'iki', 'üç', 'az', 'çok', 'biraz', 'fazla', 'tüm', 'hepsi', 'her']\n  };\n  \n  const wordLower = word.toLowerCase();\n  \n  for (const [category, examples] of Object.entries(categories)) {\n    for (const example of examples) {\n      if (wordLower.includes(example)) {\n        return category;\n      }\n    }\n  }\n  \n  // Basit morfem analizi\n  if (wordLower.endsWith('lik') || wordLower.endsWith('lık') || \n      wordLower.endsWith('luk') || wordLower.endsWith('lük')) {\n    return 'isim';\n  }\n  \n  if (wordLower.endsWith('mek') || wordLower.endsWith('mak')) {\n    return 'fiil';\n  }\n  \n  if (wordLower.length > 3 && (\n      wordLower.endsWith('ci') || wordLower.endsWith('cı') || \n      wordLower.endsWith('cu') || wordLower.endsWith('cü'))) {\n    return 'isim';\n  }\n  \n  // Varsayılan kategori\n  return wordLower.length <= 3 ? 'bağlaç' : 'isim';\n}\n\n/**\n * Duygu değeri hesapla (basit)\n */\nfunction calculateSentiment(word: string): number {\n  const positiveWords = [\n    'iyi', 'güzel', 'harika', 'muhteşem', 'sevmek', 'başarı', 'mutlu', 'sevinç',\n    'keyif', 'huzur', 'dostluk', 'eğlence', 'destek', 'coşku', 'heyecan'\n  ];\n  \n  const negativeWords = [\n    'kötü', 'çirkin', 'berbat', 'korkunç', 'nefret', 'başarısız', 'mutsuz', 'üzüntü',\n    'acı', 'kaygı', 'endişe', 'korku', 'öfke', 'sıkıntı', 'stres', 'tehlike'\n  ];\n  \n  const wordLower = word.toLowerCase();\n  \n  for (const positive of positiveWords) {\n    if (wordLower.includes(positive)) {\n      return 0.5; // Pozitif duygu\n    }\n  }\n  \n  for (const negative of negativeWords) {\n    if (wordLower.includes(negative)) {\n      return -0.5; // Negatif duygu\n    }\n  }\n  \n  return 0; // Nötr\n}\n\n/**\n * Yeni ilişki oluştur\n */\nexport const createRelation = (\n  userWord: string,\n  systemWord: string,\n  dependency: number = 50,\n  association: number = 50,\n  frequency: number = 1,\n  order: number = 1,\n  feedback: number = 0,\n  bidirectional: boolean = false,\n  context: string[] = [],\n  relationType: 'semantic' | 'temporal' | 'causal' | 'hierarchical' = 'semantic'\n): Relation => {\n  const strength = (dependency + association) / 2; // İlişki gücü\n  \n  return {\n    id: uuid(),\n    userWord,\n    systemWord,\n    dependency,\n    association,\n    frequency,\n    order,\n    feedback,\n    strength,\n    context,\n    learningCount: 1,\n    lastUsed: Date.now(),\n    creationTime: Date.now(),\n    relationType,\n    bidirectional,\n    confidence: 0.5 // Başlangıç güven değeri\n  };\n};\n\n/**\n * İlişki güçlendirme\n */\nexport const reinforceRelation = (relation: Relation, amount: number, feedback?: number): Relation => {\n  // İlişkiyi güçlendir\n  const updatedRelation = { ...relation };\n  \n  updatedRelation.dependency = Math.min(100, Math.max(1, relation.dependency + amount));\n  updatedRelation.association = Math.min(100, Math.max(1, relation.association + amount));\n  updatedRelation.learningCount += 1;\n  updatedRelation.lastUsed = Date.now();\n  updatedRelation.strength = (updatedRelation.dependency + updatedRelation.association) / 2;\n  \n  // Eğer geri bildirim varsa güncelle\n  if (feedback !== undefined) {\n    updatedRelation.feedback = Math.min(100, Math.max(-100, relation.feedback + feedback));\n  }\n  \n  // Güven değerini güncelle (öğrenme sayısına bağlı)\n  updatedRelation.confidence = Math.min(1, Math.max(0, 0.5 + (updatedRelation.learningCount / 20)));\n  \n  return updatedRelation;\n};\n\n/**\n * İlişkileri zayıflatma (unutma)\n */\nexport const weakenRelations = (relations: Relation[], factor: number = FORGET_RATE): Relation[] => {\n  const now = Date.now();\n  const oneDay = 24 * 60 * 60 * 1000; // Bir günlük milisaniye\n  \n  return relations.map(relation => {\n    const daysSinceLastUse = (now - relation.lastUsed) / oneDay;\n    \n    // Son kullanımdan bu yana geçen gün sayısına göre zayıflat\n    if (daysSinceLastUse > 1) {\n      const weakenAmount = Math.min(15, factor * daysSinceLastUse); // En fazla 15 puan zayıflat\n      \n      return {\n        ...relation,\n        dependency: Math.max(1, relation.dependency - weakenAmount),\n        association: Math.max(1, relation.association - weakenAmount),\n        strength: Math.max(1, relation.strength - weakenAmount),\n        confidence: Math.max(0.1, relation.confidence - (weakenAmount / 100))\n      };\n    }\n    \n    return relation;\n  });\n};\n\n/**\n * Sinir ağı aktivasyonu\n */\nexport const propagateActivation = (\n  userNetworks: (NetworkNode | null)[][][],\n  systemNetworks: (NetworkNode | null)[][][],\n  relations: Relation[],\n  inputText: string,\n  maxDepth: number = 3\n): ActivationResult => {\n  const startTime = Date.now();\n  \n  // İnput metnini kelimelere ayır\n  const inputWords = inputText.toLowerCase().split(/\\s+/);\n  \n  // Aktivasyon sonuçları\n  const activatedNodes: NetworkNode[] = [];\n  const activatedRelations: Relation[] = [];\n  const activationPath: { layer: number; row: number; col: number; type: 'user' | 'system'; value: number; word: string }[] = [];\n  const activationLevels = new Map<string, number>(); // Düğüm kimliği -> aktivasyon seviyesi\n  \n  // Düğüm pozisyonlarını tut\n  const nodePositions = new Map<string, { layer: number; row: number; col: number; type: 'user' | 'system' }>();\n  \n  // Tüm ağdaki düğümlerin pozisyonlarını kaydet\n  for (let layer = 0; layer < userNetworks.length; layer++) {\n    for (let row = 0; row < userNetworks[layer].length; row++) {\n      for (let col = 0; col < userNetworks[layer][0].length; col++) {\n        const node = userNetworks[layer][row][col];\n        if (node) {\n          nodePositions.set(node.id, { layer, row, col, type: 'user' });\n        }\n      }\n    }\n  }\n  \n  for (let layer = 0; layer < systemNetworks.length; layer++) {\n    for (let row = 0; row < systemNetworks[layer].length; row++) {\n      for (let col = 0; col < systemNetworks[layer][0].length; col++) {\n        const node = systemNetworks[layer][row][col];\n        if (node) {\n          nodePositions.set(node.id, { layer, row, col, type: 'system' });\n        }\n      }\n    }\n  }\n  \n  // Aktivasyon kuyruğu\n  type ActivationQueueItem = {\n    node: NetworkNode;\n    position: { layer: number; row: number; col: number; type: 'user' | 'system' };\n    activationValue: number;\n    depth: number;\n  };\n  \n  const activationQueue: ActivationQueueItem[] = [];\n  \n  // Başlangıç aktivasyonu (kullanıcı ağı)\n  for (let layer = 0; layer < userNetworks.length; layer++) {\n    for (let row = 0; row < userNetworks[layer].length; row++) {\n      for (let col = 0; col < userNetworks[layer][0].length; col++) {\n        const node = userNetworks[layer][row][col];\n        if (node) {\n          // Kelime eşleşmesi kontrolü\n          let matched = false;\n          for (const inputWord of inputWords) {\n            if (calculateWordSimilarity(node.word.toLowerCase(), inputWord) > 0.7) {\n              matched = true;\n              break;\n            }\n          }\n          \n          if (matched) {\n            // Aktivasyon seviyesi: 1.0 (tam aktivasyon)\n            node.activation = 1.0;\n            node.lastActivation = Date.now();\n            node.activationHistory.push(1.0);\n            \n            activationQueue.push({\n              node,\n              position: { layer, row, col, type: 'user' },\n              activationValue: 1.0,\n              depth: 0\n            });\n            \n            activatedNodes.push(node);\n            activationLevels.set(node.id, 1.0);\n            \n            activationPath.push({\n              layer, row, col, type: 'user', value: 1.0, word: node.word\n            });\n          }\n        }\n      }\n    }\n  }\n  \n  // Aktivasyonu yay\n  while (activationQueue.length > 0) {\n    const current = activationQueue.shift()!;\n    \n    // Maksimum derinliği aştıysak durdur\n    if (current.depth >= maxDepth) {\n      continue;\n    }\n    \n    const currentNodeId = current.node.id;\n    const currentNodeValue = current.activationValue;\n    \n    // Bağlantıları takip et\n    for (const connectionId of current.node.connections) {\n      // Kullanıcı ağında düğümü bul\n      let connectedNode = findNodeInNetwork(userNetworks, connectionId);\n      let nodeType: 'user' | 'system' = 'user';\n      \n      // Eğer kullanıcı ağında yoksa, sistem ağında ara\n      if (!connectedNode) {\n        connectedNode = findNodeInNetwork(systemNetworks, connectionId);\n        nodeType = 'system';\n      }\n      \n      if (connectedNode) {\n        // Bağlantının gücünü al\n        const connectionStrength = current.node.connectionStrengths?.[connectionId] || 0.5;\n        \n        // Yeni aktivasyon değeri\n        const newActivationValue = currentNodeValue * connectionStrength * (1 - ACTIVATION_DECAY_RATE);\n        \n        // Mevcut aktivasyonla karşılaştır\n        const currentActivation = activationLevels.get(connectionId) || 0;\n        const activationValue = Math.max(currentActivation, newActivationValue);\n        \n        // Düğümün pozisyonunu bul\n        const position = nodePositions.get(connectionId);\n        \n        if (activationValue > CONNECTION_THRESHOLD && position) {\n          // Aktivasyon seviyesini güncelle\n          connectedNode.activation = activationValue;\n          connectedNode.lastActivation = Date.now();\n          connectedNode.activationHistory.push(activationValue);\n          \n          activationLevels.set(connectionId, activationValue);\n          \n          // Bu düğüm daha önce aktive edilmemişse, aktivasyona ekle\n          if (!activatedNodes.find(n => n.id === connectionId)) {\n            activatedNodes.push(connectedNode);\n            \n            activationPath.push({\n              ...position,\n              value: activationValue,\n              word: connectedNode.word\n            });\n            \n            // Sıradaki aktivasyon\n            activationQueue.push({\n              node: connectedNode,\n              position,\n              activationValue,\n              depth: current.depth + 1\n            });\n          }\n        }\n      }\n    }\n    \n    // İlişkileri kontrol et\n    for (const relation of relations) {\n      // Mevcut düğüm kullanıcı kelimesi mi?\n      if (current.node.word.toLowerCase() === relation.userWord.toLowerCase()) {\n        // İlişkideki sistem kelimesine aktive et\n        for (let layer = 0; layer < systemNetworks.length; layer++) {\n          for (let row = 0; row < systemNetworks[layer].length; row++) {\n            for (let col = 0; col < systemNetworks[layer][0].length; col++) {\n              const node = systemNetworks[layer][row][col];\n              \n              if (node && node.word.toLowerCase() === relation.systemWord.toLowerCase()) {\n                // İlişki gücüne bağlı aktivasyon\n                const activationValue = currentNodeValue * (relation.strength / 100) * (1 - ACTIVATION_DECAY_RATE);\n                \n                // Mevcut aktivasyonla karşılaştır\n                const currentActivation = activationLevels.get(node.id) || 0;\n                const newActivation = Math.max(currentActivation, activationValue);\n                \n                if (newActivation > CONNECTION_THRESHOLD) {\n                  // Aktivasyon seviyesini güncelle\n                  node.activation = newActivation;\n                  node.lastActivation = Date.now();\n                  node.activationHistory.push(newActivation);\n                  \n                  activationLevels.set(node.id, newActivation);\n                  activatedRelations.push(relation);\n                  \n                  // Bu düğüm daha önce aktive edilmemişse, aktivasyona ekle\n                  if (!activatedNodes.find(n => n.id === node.id)) {\n                    activatedNodes.push(node);\n                    \n                    activationPath.push({\n                      layer, row, col, type: 'system',\n                      value: newActivation,\n                      word: node.word\n                    });\n                    \n                    // Sıradaki aktivasyon\n                    activationQueue.push({\n                      node,\n                      position: { layer, row, col, type: 'system' },\n                      activationValue: newActivation,\n                      depth: current.depth + 1\n                    });\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      // Mevcut düğüm sistem kelimesi mi? (ve ilişki çift yönlüyse)\n      else if (relation.bidirectional && current.node.word.toLowerCase() === relation.systemWord.toLowerCase()) {\n        // İlişkideki kullanıcı kelimesine aktive et\n        for (let layer = 0; layer < userNetworks.length; layer++) {\n          for (let row = 0; row < userNetworks[layer].length; row++) {\n            for (let col = 0; col < userNetworks[layer][0].length; col++) {\n              const node = userNetworks[layer][row][col];\n              \n              if (node && node.word.toLowerCase() === relation.userWord.toLowerCase()) {\n                // İlişki gücüne bağlı aktivasyon\n                const activationValue = currentNodeValue * (relation.strength / 100) * (1 - ACTIVATION_DECAY_RATE);\n                \n                // Mevcut aktivasyonla karşılaştır\n                const currentActivation = activationLevels.get(node.id) || 0;\n                const newActivation = Math.max(currentActivation, activationValue);\n                \n                if (newActivation > CONNECTION_THRESHOLD) {\n                  // Aktivasyon seviyesini güncelle\n                  node.activation = newActivation;\n                  node.lastActivation = Date.now();\n                  node.activationHistory.push(newActivation);\n                  \n                  activationLevels.set(node.id, newActivation);\n                  activatedRelations.push({ ...relation, isReversed: true });\n                  \n                  // Bu düğüm daha önce aktive edilmemişse, aktivasyona ekle\n                  if (!activatedNodes.find(n => n.id === node.id)) {\n                    activatedNodes.push(node);\n                    \n                    activationPath.push({\n                      layer, row, col, type: 'user',\n                      value: newActivation,\n                      word: node.word\n                    });\n                    \n                    // Sıradaki aktivasyon\n                    activationQueue.push({\n                      node,\n                      position: { layer, row, col, type: 'user' },\n                      activationValue: newActivation,\n                      depth: current.depth + 1\n                    });\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  // Aktive edilen kavramları önem sırasına göre sırala\n  const primaryConcepts = activatedNodes\n    .filter(node => node.activation > 0.5)\n    .sort((a, b) => b.activation - a.activation || b.importance! - a.importance!)\n    .map(node => node.word)\n    .slice(0, 5);\n  \n  // Yanıt puanı hesapla (1-100 arası)\n  const responseScore = Math.min(100, Math.max(1, Math.round(\n    (activatedNodes.length * 5) + \n    (activatedRelations.length * 10) + \n    (activatedNodes.reduce((sum, node) => sum + node.activation, 0) * 20)\n  )));\n  \n  // Güven değeri hesapla (0-1 arası)\n  const confidence = Math.min(1, Math.max(0, \n    (activatedRelations.length > 0) \n      ? activatedRelations.reduce((sum, rel) => sum + rel.confidence, 0) / activatedRelations.length\n      : 0.3\n  ));\n  \n  // İşlem süresi\n  const processingTime = Date.now() - startTime;\n  \n  return {\n    activationPath,\n    activatedNodes,\n    activatedRelations,\n    primaryConcepts,\n    responseScore,\n    confidence,\n    processingTime\n  };\n};\n\n/**\n * Kelime benzerliği hesapla (Levenshtein mesafesi)\n */\nfunction calculateWordSimilarity(word1: string, word2: string): number {\n  if (word1 === word2) return 1;\n  if (word1.length === 0) return 0;\n  if (word2.length === 0) return 0;\n  \n  // Levenshtein mesafesi\n  const matrix: number[][] = [];\n  \n  // Matris ilklendirme\n  for (let i = 0; i <= word1.length; i++) {\n    matrix[i] = [i];\n  }\n  for (let j = 0; j <= word2.length; j++) {\n    matrix[0][j] = j;\n  }\n  \n  // Mesafe hesaplama\n  for (let i = 1; i <= word1.length; i++) {\n    for (let j = 1; j <= word2.length; j++) {\n      const cost = word1[i - 1] === word2[j - 1] ? 0 : 1;\n      matrix[i][j] = Math.min(\n        matrix[i - 1][j] + 1,      // silme\n        matrix[i][j - 1] + 1,      // ekleme\n        matrix[i - 1][j - 1] + cost // değiştirme\n      );\n    }\n  }\n  \n  // Normalleştirilmiş benzerlik (0-1 arası)\n  const maxLength = Math.max(word1.length, word2.length);\n  const distance = matrix[word1.length][word2.length];\n  \n  return 1 - (distance / maxLength);\n}\n\n/**\n * Tersine düşünme için soru tipini belirle\n * @param question Kullanıcı sorusu\n * @returns Soru tipi\n */\nexport const determineQuestionType = (question: string): {\n  type: 'what-is' | 'where-is' | 'who-is' | 'how-to' | 'when-is' | 'other';\n  subject: string;\n} => {\n  const lowerQuestion = question.toLowerCase().trim();\n  const words = lowerQuestion.split(/\\s+/);\n  let type: 'what-is' | 'where-is' | 'who-is' | 'how-to' | 'when-is' | 'other' = 'other';\n  let subject = '';\n  \n  // \"Nedir\" tipindeki sorular\n  if (\n    lowerQuestion.includes('nedir') || \n    lowerQuestion.includes('ne demek') || \n    lowerQuestion.includes('nedir?') || \n    lowerQuestion.includes('ne demektir') ||\n    lowerQuestion.endsWith('ne') ||\n    lowerQuestion.endsWith('ne?')\n  ) {\n    type = 'what-is';\n    \n    // Son cümle öğesini konu olarak al (genellikle \"... nedir?\" kalıbında)\n    if (lowerQuestion.includes('nedir') || lowerQuestion.includes('nedir?')) {\n      subject = words.slice(0, words.indexOf('nedir')).join(' ');\n    } else if (lowerQuestion.includes('ne demek')) {\n      subject = words.slice(0, words.indexOf('ne')).join(' ');\n    } else if (lowerQuestion.endsWith('ne') || lowerQuestion.endsWith('ne?')) {\n      subject = words.slice(0, words.length - 1).join(' ');\n    }\n  }\n  // \"Nerede\" tipindeki sorular\n  else if (\n    lowerQuestion.includes('nerede') || \n    lowerQuestion.includes('neresi') ||\n    lowerQuestion.includes('nerededir')\n  ) {\n    type = 'where-is';\n    \n    // \"X nerede?\" veya \"X neresi?\" formatında\n    if (lowerQuestion.includes('nerede')) {\n      subject = words.slice(0, words.indexOf('nerede')).join(' ');\n    } else if (lowerQuestion.includes('neresi')) {\n      subject = words.slice(0, words.indexOf('neresi')).join(' ');\n    }\n  }\n  // \"Kim\" tipindeki sorular\n  else if (lowerQuestion.includes('kim')) {\n    type = 'who-is';\n    subject = words.slice(0, words.indexOf('kim')).join(' ');\n  }\n  // \"Nasıl\" tipindeki sorular\n  else if (lowerQuestion.includes('nasıl')) {\n    type = 'how-to';\n  }\n  // \"Ne zaman\" tipindeki sorular\n  else if (lowerQuestion.includes('ne zaman')) {\n    type = 'when-is';\n  }\n  \n  // Konu yoksa, belirli kelimeleri çıkararak tahmin et\n  if (!subject && words.length > 1) {\n    const stopwords = ['mi', 'midir', 'mudur', 'mıdır', 'müdür', 'bir', 'bu', 'şu', 'şey'];\n    subject = words.filter(w => !stopwords.includes(w)).join(' ');\n  }\n  \n  return { type, subject: subject.trim() };\n};\n\n/**\n * Tersine soruları işle - \"Ankara nedir?\" -> \"Türkiye'nin başkentidir\"\n * @param query Kullanıcı sorgusu\n * @param trainingData Eğitim verileri\n * @returns Tersine cevap ya da null\n */\nexport const findReverseAnswer = (\n  query: string, \n  trainingData: TrainingPair[]\n): { response: string; confidence: number } | null => {\n  const { type, subject } = determineQuestionType(query);\n  \n  // Sadece \"nedir?\" tipi sorularla ilgilen\n  if ((type !== 'what-is' && type !== 'where-is') || !subject) {\n    return null;\n  }\n  \n  // Eğitim verisini tara, burada subject bir cevap olarak görünüyor mu diye bak\n  const matches: { pair: TrainingPair; score: number }[] = [];\n  \n  for (const pair of trainingData) {\n    const outputLower = pair.output.toLowerCase();\n    const subjectLower = subject.toLowerCase();\n    \n    // Tam eşleşme\n    if (outputLower === subjectLower) {\n      matches.push({ pair, score: 1.0 });\n      continue;\n    }\n    \n    // İlk kelime eşleşiyor mu?\n    if (outputLower.startsWith(subjectLower + ' ') || outputLower.startsWith(subjectLower + ',')) {\n      matches.push({ pair, score: 0.9 });\n      continue;\n    }\n    \n    // İfade çıktının herhangi bir yerinde tam olarak geçiyor mu?\n    if (outputLower.includes(' ' + subjectLower + ' ') || \n        outputLower.includes(', ' + subjectLower + ' ')) {\n      matches.push({ pair, score: 0.8 });\n      continue;\n    }\n    \n    // Benzerlik kontrolü\n    const similarity = calculateWordSimilarity(outputLower, subjectLower);\n    if (similarity > 0.8) {\n      matches.push({ pair, score: similarity });\n    }\n  }\n  \n  // En iyi eşleşmeyi bul\n  matches.sort((a, b) => b.score - a.score);\n  \n  if (matches.length > 0 && matches[0].score >= 0.7) {\n    const bestMatch = matches[0].pair;\n    \n    // Cevap oluştur\n    let response = '';\n    \n    // Önce direkt cevap olup olmadığını kontrol et\n    if (bestMatch.input.includes('cevap') || bestMatch.input.includes('yanıt')) {\n      // Direkt cevabı döndür, ön ekler olmadan\n      response = subject;\n    }\n    else if (bestMatch.input.includes('neresi')) {\n      // \"Türkiye'nin başkenti neresidir\" -> \"Ankara, Türkiye'nin başkentidir.\" (nokta eklendi)\n      response = `${subject}, ${bestMatch.input.replace(/\\s+neresi.*$/i, '')}dir.`;\n    } \n    else if (bestMatch.input.includes('nerede')) {\n      // \"X nerede bulunur\" -> \"Y, X'de bulunur.\" (nokta eklendi)\n      response = `${subject}, ${bestMatch.input.replace(/\\s+nerede.*$/i, '')}dir.`;\n    }\n    else {\n      // Genel format (nokta eklendi)\n      response = `${subject}, ${bestMatch.input.replace(/\\?/g, '').trim()}dir.`;\n    }\n    \n    // Çift \"-dir\" eki varsa düzelt\n    response = response.replace(/dirdir/, 'dir');\n    \n    // İlk harfi büyük yap\n    response = response.charAt(0).toUpperCase() + response.slice(1);\n    \n    return {\n      response,\n      confidence: matches[0].score * 0.8 // Güven biraz düşük olsun\n    };\n  }\n  \n  return null;\n};\n\n/**\n * Yanıt oluştur (geliştirilmiş)\n */\nexport const generateResponse = async (\n  activationResult: ActivationResult,\n  trainingData: TrainingPair[],\n  recentConversation: string = \"\"\n): Promise<{ response: string; usedTraining: TrainingPair | null; confidence: number }> => {\n  const { activatedNodes, primaryConcepts, confidence } = activationResult;\n  \n  // Önce ters sorgu kontrolü yap\n  if (recentConversation) {\n    const reverseResponse = findReverseAnswer(recentConversation, trainingData);\n    if (reverseResponse) {\n      // Bu konuyla ilgili bildiğim ifadesini temizleme\n      let cleanResponse = reverseResponse.response;\n      cleanResponse = cleanResponse.replace(/Bu konuyla ilgili bildiğim[:]*\\s*/g, '')\n                                 .replace(/Bu konuda bildiğim[:]*\\s*/g, '')\n                                 .replace(/^\"(.+)\"$/g, '$1')\n                                 .trim();\n      \n      return {\n        response: cleanResponse,\n        usedTraining: null,\n        confidence: reverseResponse.confidence,\n      };\n    }\n  }\n  \n  // Yanıt için tüm kelimeleri yüksek aktivasyona göre sırala\n  const sortedWords = activatedNodes\n    .sort((a, b) => b.activation - a.activation)\n    .map(node => node.word);\n  \n  // Önce en iyi eşleşme için eğitim verilerini kontrol et\n  let bestMatch: { pair: TrainingPair; score: number } | null = null;\n  \n  for (const pair of trainingData) {\n    const inputWords = pair.input.toLowerCase().split(/\\s+/);\n    let matchScore = 0;\n    \n    // Ana kavramlar için puan ver\n    for (const concept of primaryConcepts) {\n      if (pair.input.toLowerCase().includes(concept.toLowerCase())) {\n        matchScore += 3;\n      }\n    }\n    \n    // İnput kelimelerinin eşleşme puanı\n    for (const word of inputWords) {\n      for (const concept of primaryConcepts) {\n        if (calculateWordSimilarity(word, concept.toLowerCase()) > 0.7) {\n          matchScore += 2;\n        }\n      }\n    }\n    \n    // Önceki konuşma bağlamını kullan\n    if (recentConversation && pair.input.toLowerCase().includes(recentConversation.toLowerCase())) {\n      matchScore += 2;\n    }\n    \n    // Daha iyi bir eşleşme bulunduysa güncelle\n    if (!bestMatch || matchScore > bestMatch.score) {\n      bestMatch = { pair, score: matchScore };\n    }\n  }\n  \n  // İyi bir eşleşme varsa, eğitim çıktısını kullan\n  if (bestMatch && bestMatch.score > 3) {\n    // Eğitim çiftinin kullanım sayısını arttır\n    const updatedPair = { ...bestMatch.pair, usageCount: (bestMatch.pair.usageCount || 0) + 1 };\n    \n    // Eğer çıktı \"Bu konuyla ilgili bildiğim\" ifadesini içeriyorsa, temizle\n    let response = bestMatch.pair.output;\n    \n    // Tekrarlamalı olarak tüm \"Bu konuyla ilgili bildiğim\" ifadelerini temizle\n    let hasChanged = true;\n    while (hasChanged) {\n      const originalResponse = response;\n      response = response.replace(/Bu konuyla ilgili bildiğim[:]*\\s*/g, '')\n                        .replace(/Bu konuda bildiğim[:]*\\s*/g, '')\n                        .replace(/^\"(.+)\"$/g, '$1') // Sadece başta ve sonda tırnak varsa kaldır\n                        .trim();\n      \n      // Değişiklik olmazsa döngüden çık\n      hasChanged = originalResponse !== response;\n    }\n    \n    // Eğitim verilerinde metin tekrarlarını temizle\n    // Örneğin \"nasılsın İyiyim\" -> \"İyiyim\" dönüştürülecek\n    const wordPairs = bestMatch.pair.input.toLowerCase().split(/\\s+/).filter(w => w.length > 3);\n    for (const word of wordPairs) {\n      // Eğer girdi kelimesi cevabın başında yer alıyorsa kaldır\n      const wordRegex = new RegExp(`^${word}\\\\s+`, 'i');\n      response = response.replace(wordRegex, '');\n    }\n    \n    // Eğer yanıt aynı cümleyi birden fazla kez içeriyorsa sadece bir kez göster\n    const sentences = response.split(/[.!?]+/).filter(s => s.trim()).map(s => s.trim());\n    if (sentences.length > 1) {\n      const uniqueSentences = [];\n      for (const sentence of sentences) {\n        if (!uniqueSentences.some(s => s.toLowerCase().includes(sentence.toLowerCase()) || \n                                     sentence.toLowerCase().includes(s.toLowerCase()))) {\n          uniqueSentences.push(sentence);\n        }\n      }\n      response = uniqueSentences.join('. ');\n    }\n    \n    // Noktalama işaretlerini düzenle\n    if (!response.endsWith('.') && !response.endsWith('!') && !response.endsWith('?')) {\n      response += '.';\n    }\n    \n    // İlk harfi büyük yap\n    response = response.charAt(0).toUpperCase() + response.slice(1);\n    \n    // Çift loglama sorununu çözmek için log kaldırıldı\n    \n    return {\n      response: response,\n      usedTraining: updatedPair,\n      confidence: Math.min(0.9, confidence + 0.2) // Eğitim çifti kullanıldığında güven artar\n    };\n  }\n  \n  // Eğitim verisinde iyi bir eşleşme yoksa, aktivasyon sonuçlarını kullan\n  \n  // Basit cevap oluştur (gerçek bir uygulamada burada bir dil modeli olacak)\n  let response = \"Anladığım kadarıyla \";\n  \n  if (primaryConcepts.length > 0) {\n    response += primaryConcepts.slice(0, 3).join(\", \") + \" hakkında konuşuyorsunuz. \";\n    \n    // Aktivasyon seviyesi yüksek kelimeleri ekle\n    const highActivationWords = activatedNodes\n      .filter(node => node.activation > 0.7)\n      .map(node => node.word)\n      .slice(0, 5);\n    \n    if (highActivationWords.length > 0) {\n      response += \"Ayrıca \" + highActivationWords.join(\", \") + \" konuları da önemli görünüyor.\";\n    } else {\n      response += \"Daha fazla bilgi verebilir misiniz?\";\n    }\n  } else {\n    // Eğitim verisinde ve bağlantılarda bir bilgi bulunamadığında standart yanıt\n    response = \"Üzgünüm, bu konuda bilgi bulamadım. Daha açık bir şekilde ifade edebilir misiniz?\";\n  }\n  \n  // Sorgu tekrarını önleme\n  const cleanUserInput = recentConversation;\n  // Cevabın başında kullanıcı sorusunun tekrarlanmasını önle\n  // Başta \"abaküs nedir?\" gibi bir tekrar varsa temizle\n  if (cleanUserInput.length > 0) {\n    const questionPattern = new RegExp(`^${cleanUserInput.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\s*`, 'i');\n    response = response.replace(questionPattern, '');\n  }\n  \n  // Cümleleri ayır ve tekrarları temizle - Tamamen yeniden yazıldı\n  const sentences = response.split(/[.!?]+\\s*/).filter(s => s.trim());\n  if (sentences.length > 0) {\n    // Benzer cümleleri tespit etmek için daha katı bir algoritma\n    const uniqueSentences: Array<string> = [];\n    const similarityThreshold = 0.75; // %75 benzerlik eşiği (daha sıkı)\n    \n    // İlk geçiş: Tam düplicatları kaldır\n    for (const sentence of sentences) {\n      if (!uniqueSentences.includes(sentence)) {\n        uniqueSentences.push(sentence);\n      }\n    }\n    \n    // İkinci geçiş: Benzer cümleleri kaldır\n    const filteredSentences: Array<string> = [];\n    \n    for (const sentence of uniqueSentences) {\n      // Çok kısa cümleleri doğrudan ekle (3 kelimeden az)\n      if (sentence.split(/\\s+/).length < 3) {\n        filteredSentences.push(sentence);\n        continue;\n      }\n      \n      // Benzerlik kontrolü\n      let isDuplicate = false;\n      \n      for (const existingSentence of filteredSentences) {\n        // Çok kısa cümleleri karşılaştırma\n        if (existingSentence.split(/\\s+/).length < 3) continue;\n        \n        // Temel kelime kontrolü\n        const words1 = sentence.toLowerCase().split(/\\s+/);\n        const words2 = existingSentence.toLowerCase().split(/\\s+/);\n        \n        // Jaccard benzerlik indeksi hesapla - daha kesin bir metrik\n        const intersection = words1.filter(word => words2.includes(word)).length;\n        const union = new Set([...words1, ...words2]).size;\n        const similarity = intersection / union;\n        \n        // Eğer bir cümle diğerinin tamamen alt kümesiyse\n        const isSubset = words1.every(word => words2.includes(word)) || \n                        words2.every(word => words1.includes(word));\n                        \n        // Benzerlik OR alt küme ise duplike olarak işaretle\n        if (similarity > similarityThreshold || isSubset) {\n          isDuplicate = true;\n          break;\n        }\n      }\n      \n      if (!isDuplicate) {\n        filteredSentences.push(sentence);\n      }\n    }\n    \n    // Emoji kategorileri - yanıt tipine göre\n    const knowledgeEmojis = ['💡', '📚', '🧠', '✨', '🔍'];\n    const humorEmojis = ['😄', '😊', '😁', '🙂', '😉'];\n    const adviceEmojis = ['👍', '✅', '⭐️', '🌟', '💯'];\n    const feedbackEmojis = ['🙌', '👏', '🎯', '🏆', '🔑'];\n    \n    // Yanıt içeriğini analiz ederek uygun emoji kategorisini seç\n    let emojiPool = knowledgeEmojis; // Varsayılan olarak bilgi emojileri\n    \n    // Yanıtın içeriğine göre emoji havuzunu belirle\n    const responseText = filteredSentences.join('. ').toLowerCase();\n    \n    if (responseText.includes('öneririm') || responseText.includes('tavsiye') || \n        responseText.includes('yapmanız gereken') || responseText.includes('daha iyi olur')) {\n      emojiPool = adviceEmojis;\n    } else if (responseText.includes('komik') || responseText.includes('eğlenceli') || \n              responseText.includes('güldüren') || responseText.includes('espri')) {\n      emojiPool = humorEmojis;\n    } else if (responseText.includes('tebrikler') || responseText.includes('harika') || \n              responseText.includes('aferin') || responseText.includes('iyi iş')) {\n      emojiPool = feedbackEmojis;\n    }\n    \n    // Rastgele emoji ekle (yaklaşık %40 ihtimalle - biraz artırıldı)\n    const shouldAddEmoji = Math.random() < 0.4;\n    \n    // Filtre sonrası cümleleri birleştir\n    response = filteredSentences.join('. ');\n    \n    // Cümlenin sonuna nokta ekle\n    if (!response.endsWith('.') && !response.endsWith('!') && !response.endsWith('?')) {\n      response += '.';\n    }\n    \n    // Emoji ekle\n    if (shouldAddEmoji && filteredSentences.length > 0) {\n      const randomEmoji = emojiPool[Math.floor(Math.random() * emojiPool.length)];\n      response = response + ' ' + randomEmoji;\n    }\n  }\n  \n  return {\n    response,\n    usedTraining: null,\n    confidence: Math.max(0.3, confidence) // En az 0.3 güven seviyesi\n  };\n};\n","size_bytes":48674},"client/src/lib/TurkishDictionary.ts":{"content":"interface DictionaryEntry {\n  word: string;\n  meaning: string[];\n  type: 'isim' | 'fiil' | 'sıfat' | 'zamir' | 'edat' | 'bağlaç' | 'soru' | 'özel';\n  examples?: string[];\n  synonyms?: string[];\n  antonyms?: string[];\n}\n\ninterface PhrasePattern {\n  pattern: RegExp;\n  intent: string;\n  confidence: number;\n  matches: (words: string[]) => boolean;\n  generateResponse: (context: any) => string;\n  wasSuccessful?: boolean;\n}\n\ninterface PhraseAnalysisResult {\n  words: DictionaryEntry[];\n  understanding: string;\n  confidence: number;\n  semanticComponents: Record<string, any>;\n}\n\nexport class TurkishDictionary {\n  private dictionary: Map<string, DictionaryEntry>;\n  private phrases: Map<string, { meaning: string, type: string }>;\n  private patterns: PhrasePattern[];\n  private statistics: {\n    totalQueries: number;\n    successfulQueries: number;\n    commonPatterns: Map<string, number>;\n  };\n\n  constructor() {\n    this.dictionary = new Map();\n    this.phrases = new Map();\n    this.patterns = [];\n    this.statistics = {\n      totalQueries: 0,\n      successfulQueries: 0,\n      commonPatterns: new Map()\n    };\n    this.initializeBasicWords();\n    this.initializeCommonPatterns();\n  }\n\n  private initializeBasicWords() {\n    const basicWords: DictionaryEntry[] = [\n      {\n        word: 'kitap',\n        meaning: ['Ciltli veya ciltsiz olarak bir araya getirilmiş basılı veya yazılı kağıt yaprakların bütünü'],\n        type: 'isim',\n        examples: ['kitap okumak', 'kitap yazmak']\n      },\n      {\n        word: 'yürümek',\n        meaning: ['Adım atarak ilerlemek, gitmek'],\n        type: 'fiil',\n        examples: ['parkta yürümek', 'hızlı yürümek']\n      },\n      {\n        word: 'güzel',\n        meaning: ['Göze ve kulağa hoş gelen, hayranlık uyandıran'],\n        type: 'sıfat',\n        examples: ['güzel manzara', 'güzel müzik']\n      },\n      {\n        word: 'hızlı',\n        meaning: ['Süratli, çabuk'],\n        type: 'sıfat',\n        examples: ['hızlı araba', 'hızlı koşmak']\n      },\n      {\n        word: 'okumak',\n        meaning: ['Yazıyı seslendirmek veya sessiz olarak anlamak'],\n        type: 'fiil',\n        examples: ['kitap okumak', 'gazete okumak']\n      },\n      // ... 9,995 more entries to follow\n      {\n        word: 'ne',\n        meaning: ['soru yoluyla bir şeyin niteliğini, türünü veya durumunu öğrenmeyi amaçlayan söz'],\n        type: 'soru',\n        examples: ['ne istiyorsun?', 'bu ne?']\n      },\n      {\n        word: 'ben',\n        meaning: ['teklik birinci kişiyi gösteren söz'],\n        type: 'zamir',\n        examples: ['ben geldim', 'benim adım']\n      },\n      {\n        word: 'sen',\n        meaning: ['teklik ikinci kişiyi gösteren söz'],\n        type: 'zamir',\n        examples: ['sen gittin', 'senin adın']\n      },\n      {\n        word: 'o',\n        meaning: ['teklik üçüncü kişiyi gösteren söz'],\n        type: 'zamir',\n        examples: ['o geldi', 'onun adı']\n      },\n      {\n        word: 'biz',\n        meaning: ['çokluk birinci kişiyi gösteren söz'],\n        type: 'zamir',\n        examples: ['biz geldik', 'bizim adımız']\n      },\n      {\n        word: 'siz',\n        meaning: ['çokluk ikinci kişiyi gösteren söz'],\n        type: 'zamir',\n        examples: ['siz gittiniz', 'sizin adınız']\n      },\n      {\n        word: 'onlar',\n        meaning: ['çokluk üçüncü kişiyi gösteren söz'],\n        type: 'zamir',\n        examples: ['onlar geldi', 'onların adı']\n      },\n      {\n        word: 'kim',\n        meaning: ['bir şahsı sorma, belirtme sözü'],\n        type: 'soru',\n        examples: ['kim geldi?', 'kim söyledi?']\n      },\n      {\n        word: 'nerede',\n        meaning: ['yer, mevki sorma sözü'],\n        type: 'soru',\n        examples: ['nerede oturuyorsun?', 'okul nerede?']\n      },\n      {\n        word: 'nasıl',\n        meaning: ['bir şeyin yapılış biçimini veya durumunu sorma sözü'],\n        type: 'soru',\n        examples: ['nasıl gidiyorsun?', 'nasıl bir ev?']\n      },\n      {\n        word: 'neden',\n        meaning: ['sebep, gerekçe sorma sözü'],\n        type: 'soru',\n        examples: ['neden geldin?', 'neden böyle oldu?']\n      },\n      {\n        word: 'nedir',\n        meaning: ['bir şeyin anlamını, ne olduğunu sorma sözü'],\n        type: 'soru',\n        examples: ['bu nedir?', 'amacın nedir?']\n      },\n      {\n        word: 'merhaba',\n        meaning: ['selamlama sözü'],\n        type: 'isim',\n        examples: ['merhaba, nasılsın?', 'herkese merhaba']\n      },\n      {\n        word: 'selam',\n        meaning: ['selamlama sözü, esenlik dileme'],\n        type: 'isim',\n        examples: ['selam verdim', 'selam söyle']\n      },\n      {\n        word: 'günaydın',\n        meaning: ['sabah selamlaşma sözü'],\n        type: 'isim',\n        examples: ['günaydın, nasılsın?', 'herkese günaydın']\n      },\n      {\n        word: 'iyi',\n        meaning: ['istenilen, beğenilen nitelikleri taşıyan, kötü karşıtı'],\n        type: 'sıfat',\n        examples: ['iyi bir insan', 'iyi düşünce']\n      },\n      {\n        word: 'kötü',\n        meaning: ['istenilmeyen, beğenilmeyen nitelikleri taşıyan, iyi karşıtı'],\n        type: 'sıfat',\n        examples: ['kötü hava', 'kötü haber']\n      }\n    ];\n\n    basicWords.forEach(entry => {\n      this.dictionary.set(entry.word, entry);\n    });\n\n    // Toplu kelime ekleme örneği\n    const additionalWords: DictionaryEntry[] = [\n      { word: 'elma', meaning: ['Bir tür meyve'], type: 'isim' },\n      { word: 'gitmek', meaning: ['Bir yerden bir yere doğru hareket etmek'], type: 'fiil' },\n      // Add more words here...\n    ];\n\n    additionalWords.forEach(entry => this.dictionary.set(entry.word, entry));\n\n    // Example bulk addition\n    const bulkWords: DictionaryEntry[] = [\n      { word: 'armut', meaning: ['Bir meyve türü'], type: 'isim' },\n      { word: 'kalem', meaning: ['Yazı yazmak için kullanılan araç'], type: 'isim' },\n      { word: 'koşmak', meaning: ['Hızlı bir şekilde hareket etmek'], type: 'fiil' },\n      { word: 've', meaning: ['Birleşik halde iki ifadeyi bağlayan söz'], type: 'bağlaç' },\n\n      // En çok kullanılan 1000 Türkçe kelime\n      { word: 'bir', meaning: ['Sayı ismi, tek'], type: 'sayı' },\n      { word: 'bu', meaning: ['İşaret zamiri, yakınımdaki'], type: 'zamir' },\n      { word: 'da', meaning: ['de ile birlikte bağlaç'], type: 'bağlaç' },\n      { word: 'de', meaning: ['da ile birlikte bağlaç'], type: 'bağlaç' },\n      { word: 'var', meaning: ['Mevcut olan, bulunan'], type: 'sıfat' },\n      { word: 'yok', meaning: ['Bulunmayan, olmayan'], type: 'sıfat' },\n      { word: 'için', meaning: ['Amaç bildiren edat'], type: 'edat' },\n      { word: 'ile', meaning: ['Birliktelik bildiren edat'], type: 'edat' },\n      { word: 'çok', meaning: ['Fazla miktarda'], type: 'sıfat' },\n      { word: 'daha', meaning: ['Üstünlük derecesi'], type: 'zarf' },\n      { word: 'böyle', meaning: ['Bu şekilde'], type: 'sıfat' },\n      { word: 'olan', meaning: ['Bulunan, mevcut'], type: 'sıfat' },\n      { word: 'olan', meaning: ['Bulunan, mevcut'], type: 'sıfat' },\n      { word: 'şey', meaning: ['Genel nesne adı'], type: 'isim' },\n      { word: 'her', meaning: ['Bütün, tüm'], type: 'sıfat' },\n      { word: 'şu', meaning: ['İşaret zamiri'], type: 'zamir' },\n      { word: 'ya', meaning: ['Veya anlamında bağlaç'], type: 'bağlaç' },\n      { word: 'or', meaning: ['Veya anlamında bağlaç'], type: 'bağlaç' },\n      { word: 'ama', meaning: ['Fakat anlamında bağlaç'], type: 'bağlaç' },\n      { word: 'çünkü', meaning: ['Sebep bildiren bağlaç'], type: 'bağlaç' },\n      { word: 'eğer', meaning: ['Şart bildiren bağlaç'], type: 'bağlaç' },\n      { word: 'kadar', meaning: ['Miktar bildiren edat'], type: 'edat' },\n      { word: 'sonra', meaning: ['Zamansal sıralama'], type: 'zarf' },\n      { word: 'önce', meaning: ['Zamansal öncelik'], type: 'zarf' },\n      { word: 'zaman', meaning: ['Vakit, süre'], type: 'isim' },\n      { word: 'yer', meaning: ['Mekan, alan'], type: 'isim' },\n      { word: 'gün', meaning: ['24 saatlik zaman dilimi'], type: 'isim' },\n      { word: 'yıl', meaning: ['12 aylık zaman dilimi'], type: 'isim' },\n      { word: 'ay', meaning: ['Yılın 12 bölümünden biri'], type: 'isim' },\n      { word: 'hafta', meaning: ['7 günlük zaman dilimi'], type: 'isim' },\n      { word: 'saat', meaning: ['60 dakikalık zaman birimi'], type: 'isim' },\n      { word: 'dakika', meaning: ['60 saniyelik zaman birimi'], type: 'isim' },\n      { word: 'gelmek', meaning: ['Bir yerden buraya doğru hareket etmek'], type: 'fiil' },\n      { word: 'getirmek', meaning: ['Bir şeyi yanında taşıyarak gelmek'], type: 'fiil' },\n      { word: 'görmek', meaning: ['Gözle algılamak'], type: 'fiil' },\n      { word: 'göstermek', meaning: ['Görülmesini sağlamak'], type: 'fiil' },\n      { word: 'almak', meaning: ['Eline geçirmek, satın almak'], type: 'fiil' },\n      { word: 'vermek', meaning: ['Başkasına teslim etmek'], type: 'fiil' },\n      { word: 'olmak', meaning: ['Varlık kazanmak, bulunmak'], type: 'fiil' },\n      { word: 'yapmak', meaning: ['Meydana getirmek, imal etmek'], type: 'fiil' },\n      { word: 'etmek', meaning: ['Yapmak, gerçekleştirmek'], type: 'fiil' },\n      { word: 'bilmek', meaning: ['Öğrenmiş olmak'], type: 'fiil' },\n      { word: 'demek', meaning: ['Söylemek, ifade etmek'], type: 'fiil' },\n      { word: 'söylemek', meaning: ['Kelimelerle ifade etmek'], type: 'fiil' },\n      { word: 'kalmak', meaning: ['Bir yerde durmak'], type: 'fiil' },\n      { word: 'kalmak', meaning: ['Artmak, geri kalmak'], type: 'fiil' },\n      { word: 'durmak', meaning: ['Hareketsiz kalmak'], type: 'fiil' },\n      { word: 'bakmak', meaning: ['Gözle görmek'], type: 'fiil' },\n      { word: 'çıkmak', meaning: ['İçeriden dışarıya gitmek'], type: 'fiil' },\n      { word: 'girmek', meaning: ['Dışarıdan içeriye gitmek'], type: 'fiil' },\n      { word: 'büyük', meaning: ['Iri, geniş'], type: 'sıfat' },\n      { word: 'küçük', meaning: ['Dar, ufak'], type: 'sıfat' },\n      { word: 'yeni', meaning: ['Yakın zamanda yapılmış'], type: 'sıfat' },\n      { word: 'eski', meaning: ['Geçmişte yapılmış'], type: 'sıfat' },\n      { word: 'uzun', meaning: ['Boyu fazla olan'], type: 'sıfat' },\n      { word: 'kısa', meaning: ['Boyu az olan'], type: 'sıfat' },\n      { word: 'yüksek', meaning: ['Yeri çok olan'], type: 'sıfat' },\n      { word: 'alçak', meaning: ['Yeri az olan'], type: 'sıfat' },\n      { word: 'geniş', meaning: ['Eni fazla olan'], type: 'sıfat' },\n      { word: 'dar', meaning: ['Eni az olan'], type: 'sıfat' },\n      { word: 'beyaz', meaning: ['Renk adı'], type: 'isim' },\n      { word: 'siyah', meaning: ['Renk adı'], type: 'isim' },\n      { word: 'kırmızı', meaning: ['Renk adı'], type: 'isim' },\n      { word: 'mavi', meaning: ['Renk adı'], type: 'isim' },\n      { word: 'yeşil', meaning: ['Renk adı'], type: 'isim' },\n      { word: 'sarı', meaning: ['Renk adı'], type: 'isim' },\n      { word: 'ev', meaning: ['Yaşanılan yer'], type: 'isim' },\n      { word: 'okul', meaning: ['Eğitim verilen yer'], type: 'isim' },\n      { word: 'iş', meaning: ['Meslek, görev'], type: 'isim' },\n      { word: 'para', meaning: ['Değişim aracı'], type: 'isim' },\n      { word: 'su', meaning: ['Sıvı madde'], type: 'isim' },\n      { word: 'yemek', meaning: ['Beslenme maddesi'], type: 'isim' },\n      { word: 'içmek', meaning: ['Sıvı almak'], type: 'fiil' },\n      { word: 'yemek', meaning: ['Beslenme maddesi almak'], type: 'fiil' },\n      { word: 'baba', meaning: ['Erkek ebeveyn'], type: 'isim' },\n      { word: 'anne', meaning: ['Kadın ebeveyn'], type: 'isim' },\n      { word: 'çocuk', meaning: ['Küçük yaştaki insan'], type: 'isim' },\n      { word: 'adam', meaning: ['Erkek insan'], type: 'isim' },\n      { word: 'kadın', meaning: ['Dişi insan'], type: 'isim' },\n      { word: 'erkek', meaning: ['Eril cinsiyet'], type: 'isim' },\n      { word: 'kız', meaning: ['Genç kadın'], type: 'isim' },\n      { word: 'oğlan', meaning: ['Genç erkek'], type: 'isim' },\n      { word: 'arkadaş', meaning: ['Dost, ahbap'], type: 'isim' },\n      { word: 'sevmek', meaning: ['Aşk duymak'], type: 'fiil' },\n      { word: 'sevgi', meaning: ['Sevme duygusu'], type: 'isim' },\n      { word: 'mutlu', meaning: ['Sevinçli'], type: 'sıfat' },\n      { word: 'üzgün', meaning: ['Kederli'], type: 'sıfat' },\n      { word: 'kızgın', meaning: ['Öfkeli'], type: 'sıfat' },\n      { word: 'korkmak', meaning: ['Endişe duymak'], type: 'fiil' },\n      { word: 'gülmek', meaning: ['Sevinç ifadesi'], type: 'fiil' },\n      { word: 'ağlamak', meaning: ['Gözyaşı dökmek'], type: 'fiil' },\n      { word: 'araba', meaning: ['Motorlu taşıt'], type: 'isim' },\n      { word: 'otobüs', meaning: ['Toplu taşıma aracı'], type: 'isim' },\n      { word: 'uçak', meaning: ['Hava taşıtı'], type: 'isim' },\n      { word: 'gemi', meaning: ['Su taşıtı'], type: 'isim' },\n      { word: 'tren', meaning: ['Ray üzerinde giden taşıt'], type: 'isim' },\n      { word: 'yol', meaning: ['Geçit, güzergah'], type: 'isim' },\n      { word: 'sokak', meaning: ['Dar yol'], type: 'isim' },\n      { word: 'şehir', meaning: ['Büyük yerleşim yeri'], type: 'isim' },\n      { word: 'köy', meaning: ['Küçük yerleşim yeri'], type: 'isim' },\n      { word: 'ülke', meaning: ['Devlet toprakları'], type: 'isim' },\n      { word: 'dünya', meaning: ['Yaşadığımız gezegen'], type: 'isim' },\n      { word: 'gökyüzü', meaning: ['Göğün görünen kısmı'], type: 'isim' },\n      { word: 'güneş', meaning: ['Güneş sistemi merkezi'], type: 'isim' },\n      { word: 'ay', meaning: ['Dünya uydusu'], type: 'isim' },\n      { word: 'yıldız', meaning: ['Gökyüzü cismi'], type: 'isim' },\n      { word: 'ağaç', meaning: ['Büyük bitki'], type: 'isim' },\n      { word: 'çiçek', meaning: ['Bitkinin renkli kısmı'], type: 'isim' },\n      { word: 'hayvan', meaning: ['Canlı varlık'], type: 'isim' },\n      { word: 'köpek', meaning: ['Evcil hayvan'], type: 'isim' },\n      { word: 'kedi', meaning: ['Evcil hayvan'], type: 'isim' },\n      { word: 'kuş', meaning: ['Uçabilen hayvan'], type: 'isim' },\n      { word: 'balık', meaning: ['Suda yaşayan hayvan'], type: 'isim' },\n      { word: 'et', meaning: ['Hayvan ürünü besin'], type: 'isim' },\n      { word: 'ekmek', meaning: ['Temel besin'], type: 'isim' },\n      { word: 'süt', meaning: ['Hayvansal içecek'], type: 'isim' },\n      { word: 'peynir', meaning: ['Süt ürünü'], type: 'isim' },\n      { word: 'sebze', meaning: ['Bitkisel besin'], type: 'isim' },\n      { word: 'meyve', meaning: ['Tatlı bitkisel besin'], type: 'isim' },\n      { word: 'portakal', meaning: ['Turuncu meyve'], type: 'isim' },\n      { word: 'muz', meaning: ['Sarı meyve'], type: 'isim' },\n      { word: 'üzüm', meaning: ['Salkım meyve'], type: 'isim' },\n      { word: 'masa', meaning: ['Düz yüzeyli mobilya'], type: 'isim' },\n      { word: 'sandalye', meaning: ['Oturma mobilyası'], type: 'isim' },\n      { word: 'yatak', meaning: ['Yatma mobilyası'], type: 'isim' },\n      { word: 'dolap', meaning: ['Saklama mobilyası'], type: 'isim' },\n      { word: 'kapı', meaning: ['Giriş-çıkış yeri'], type: 'isim' },\n      { word: 'pencere', meaning: ['Işık ve hava girişi'], type: 'isim' },\n      { word: 'duvar', meaning: ['İnşaat elemanı'], type: 'isim' },\n      { word: 'tavan', meaning: ['Üst örtü'], type: 'isim' },\n      { word: 'zemin', meaning: ['Alt yüzey'], type: 'isim' },\n      { word: 'oda', meaning: ['Kapalı alan'], type: 'isim' },\n      { word: 'mutfak', meaning: ['Yemek hazırlama yeri'], type: 'isim' },\n      { word: 'banyo', meaning: ['Temizlik yeri'], type: 'isim' },\n      { word: 'salon', meaning: ['Oturma odası'], type: 'isim' },\n      { word: 'bahçe', meaning: ['Açık yeşil alan'], type: 'isim' },\n      { word: 'kışın', meaning: ['Soğuk mevsimde'], type: 'zarf' },\n      { word: 'yazın', meaning: ['Sıcak mevsimde'], type: 'zarf' },\n      { word: 'baharda', meaning: ['İlkbahar mevsiminde'], type: 'zarf' },\n      { word: 'sonbaharda', meaning: ['Güz mevsiminde'], type: 'zarf' },\n      { word: 'soğuk', meaning: ['Düşük sıcaklık'], type: 'sıfat' },\n      { word: 'sıcak', meaning: ['Yüksek sıcaklık'], type: 'sıfat' },\n      { word: 'kar', meaning: ['Donmuş yağmur'], type: 'isim' },\n      { word: 'yağmur', meaning: ['Gökten düşen su'], type: 'isim' },\n      { word: 'rüzgar', meaning: ['Hava akımı'], type: 'isim' },\n      { word: 'bulut', meaning: ['Gökyüzü oluşumu'], type: 'isim' },\n      { word: 'telefon', meaning: ['İletişim aracı'], type: 'isim' },\n      { word: 'bilgisayar', meaning: ['Elektronik hesap makinesi'], type: 'isim' },\n      { word: 'televizyon', meaning: ['Görüntü alıcısı'], type: 'isim' },\n      { word: 'radyo', meaning: ['Ses alıcısı'], type: 'isim' },\n      { word: 'müzik', meaning: ['Ses sanatı'], type: 'isim' },\n      { word: 'film', meaning: ['Sinema eseri'], type: 'isim' },\n      { word: 'oyun', meaning: ['Eğlence aktivitesi'], type: 'isim' },\n      { word: 'spor', meaning: ['Fiziksel aktivite'], type: 'isim' },\n      { word: 'futbol', meaning: ['Ayakla oynanan spor'], type: 'isim' },\n      { word: 'basketbol', meaning: ['Potaya atılan spor'], type: 'isim' },\n      { word: 'tenis', meaning: ['Raketle oynanan spor'], type: 'isim' },\n      { word: 'yüzmek', meaning: ['Suda hareket etmek'], type: 'fiil' },\n      { word: 'koşmak', meaning: ['Hızlı hareket etmek'], type: 'fiil' },\n      { word: 'yürümek', meaning: ['Adım atarak ilerlemek'], type: 'fiil' },\n      { word: 'oturmak', meaning: ['Vücudu desteklemek'], type: 'fiil' },\n      { word: 'ayakta', meaning: ['Dik pozisyonda'], type: 'zarf' },\n      { word: 'yatmak', meaning: ['Uzanmak'], type: 'fiil' },\n      { word: 'uyumak', meaning: ['Dinlenmek'], type: 'fiil' },\n      { word: 'uyanmak', meaning: ['Uykudan çıkmak'], type: 'fiil' },\n      { word: 'kalkmak', meaning: ['Ayağa dikilmek'], type: 'fiil' },\n      { word: 'hasta', meaning: ['Sağlıksız'], type: 'sıfat' },\n      { word: 'sağlıklı', meaning: ['İyi durumda'], type: 'sıfat' },\n      { word: 'doktor', meaning: ['Tıp uzmanı'], type: 'isim' },\n      { word: 'hastane', meaning: ['Tedavi yeri'], type: 'isim' },\n      { word: 'ilaç', meaning: ['Tedavi maddesi'], type: 'isim' },\n      { word: 'ağrı', meaning: ['Acı duygusu'], type: 'isim' },\n      { word: 'ağrımak', meaning: ['Acı duymak'], type: 'fiil' },\n      { word: 'öğretmen', meaning: ['Eğitim veren kişi'], type: 'isim' },\n      { word: 'öğrenci', meaning: ['Eğitim alan kişi'], type: 'isim' },\n      { word: 'ders', meaning: ['Öğretim konusu'], type: 'isim' },\n      { word: 'öğrenmek', meaning: ['Bilgi edinmek'], type: 'fiil' },\n      { word: 'öğretmek', meaning: ['Bilgi vermek'], type: 'fiil' },\n      { word: 'yazmak', meaning: ['Harflerle ifade etmek'], type: 'fiil' },\n      { word: 'kalem', meaning: ['Yazı aleti'], type: 'isim' },\n      { word: 'kağıt', meaning: ['Yazı malzemesi'], type: 'isim' },\n      { word: 'defter', meaning: ['Yazı defteri'], type: 'isim' },\n      { word: 'sayfa', meaning: ['Kağıt yaprağı'], type: 'isim' },\n      { word: 'satır', meaning: ['Yatay yazı sırası'], type: 'isim' },\n      { word: 'kelime', meaning: ['Anlam birimi'], type: 'isim' },\n      { word: 'harf', meaning: ['Yazı simgesi'], type: 'isim' },\n      { word: 'sayı', meaning: ['Matematik birimi'], type: 'isim' },\n      { word: 'hesap', meaning: ['Matematik işlemi'], type: 'isim' },\n      { word: 'matematik', meaning: ['Sayı bilimi'], type: 'isim' },\n      { word: 'toplamak', meaning: ['Bir araya getirmek'], type: 'fiil' },\n      { word: 'çıkarmak', meaning: ['Azaltmak'], type: 'fiil' },\n      { word: 'çarpmak', meaning: ['Çoklamak'], type: 'fiil' },\n      { word: 'bölmek', meaning: ['Parçalara ayırmak'], type: 'fiil' },\n      { word: 'eşit', meaning: ['Aynı değerde'], type: 'sıfat' },\n      { word: 'fazla', meaning: ['Çok miktarda'], type: 'sıfat' },\n      { word: 'az', meaning: ['Küçük miktarda'], type: 'sıfat' },\n      { word: 'hiç', meaning: ['Sıfır miktarda'], type: 'zarf' },\n      { word: 'bütün', meaning: ['Tamamı'], type: 'sıfat' },\n      { word: 'yarım', meaning: ['Yarısı'], type: 'sıfat' },\n      { word: 'çeyrek', meaning: ['Dörtte biri'], type: 'isim' },\n      { word: 'ilk', meaning: ['Birinci'], type: 'sıfat' },\n      { word: 'son', meaning: ['En sonuncu'], type: 'sıfat' },\n      { word: 'orta', meaning: ['Arada olan'], type: 'sıfat' },\n      { word: 'başlamak', meaning: ['İlk adımı atmak'], type: 'fiil' },\n      { word: 'bitirmek', meaning: ['Sona erdirmek'], type: 'fiil' },\n      { word: 'devam', meaning: ['Sürdürme'], type: 'isim' },\n      { word: 'dur', meaning: ['Durma emri'], type: 'ünlem' },\n      { word: 'gel', meaning: ['Gelme emri'], type: 'ünlem' },\n      { word: 'git', meaning: ['Gitme emri'], type: 'ünlem' },\n      { word: 'hızlı', meaning: ['Süratli'], type: 'sıfat' },\n      { word: 'yavaş', meaning: ['Ağır'], type: 'sıfat' },\n      { word: 'erken', meaning: ['Zamanından önce'], type: 'zarf' },\n      { word: 'geç', meaning: ['Zamanından sonra'], type: 'zarf' },\n      { word: 'şimdi', meaning: ['Bu anda'], type: 'zarf' },\n      { word: 'bugün', meaning: ['Bu günde'], type: 'zarf' },\n      { word: 'dün', meaning: ['Önceki günde'], type: 'zarf' },\n      { word: 'yarın', meaning: ['Sonraki günde'], type: 'zarf' },\n      { word: 'sabah', meaning: ['Güneş doğduğu vakit'], type: 'isim' },\n      { word: 'öğle', meaning: ['Güneşin tepede olduğu vakit'], type: 'isim' },\n      { word: 'akşam', meaning: ['Güneş battığı vakit'], type: 'isim' },\n      { word: 'gece', meaning: ['Karanlık vakit'], type: 'isim' },\n      { word: 'sıkılmak', meaning: ['Canı sıkılmak'], type: 'fiil' },\n      { word: 'eğlenmek', meaning: ['Keyif almak'], type: 'fiil' },\n      { word: 'dinlenmek', meaning: ['Rahatlamak'], type: 'fiil' },\n      { word: 'çalışmak', meaning: ['İş yapmak'], type: 'fiil' },\n      { word: 'kazanmak', meaning: ['Elde etmek'], type: 'fiil' },\n      { word: 'kaybetmek', meaning: ['Yitirmek'], type: 'fiil' },\n      { word: 'bulmak', meaning: ['Keşfetmek'], type: 'fiil' },\n      { word: 'aramak', meaning: ['Arayış yapmak'], type: 'fiil' },\n      { word: 'beklemek', meaning: ['Beklenti içinde olmak'], type: 'fiil' },\n      { word: 'umut', meaning: ['Beklenti'], type: 'isim' },\n      { word: 'korku', meaning: ['Endişe duygusu'], type: 'isim' },\n      { word: 'merak', meaning: ['Öğrenme isteği'], type: 'isim' },\n      { word: 'şaşırmak', meaning: ['Beklenmedik karşılamak'], type: 'fiil' },\n      { word: 'şaşkın', meaning: ['Karışık zihinli'], type: 'sıfat' },\n      { word: 'sakin', meaning: ['Huzurlu'], type: 'sıfat' },\n      { word: 'heyecanlı', meaning: ['Coşkulu'], type: 'sıfat' },\n      { word: 'soru', meaning: ['Öğrenme isteği ifadesi'], type: 'isim' },\n      { word: 'cevap', meaning: ['Soru karşılığı'], type: 'isim' },\n      { word: 'sormak', meaning: ['Soru yöneltmek'], type: 'fiil' },\n      { word: 'cevaplamak', meaning: ['Yanıt vermek'], type: 'fiil' },\n      { word: 'anlamak', meaning: ['Kavramak'], type: 'fiil' },\n      { word: 'anlam', meaning: ['Mana'], type: 'isim' },\n      { word: 'düşünmek', meaning: ['Zihinsel faaliyet'], type: 'fiil' },\n      { word: 'düşünce', meaning: ['Fikir'], type: 'isim' },\n      { word: 'fikir', meaning: ['Düşünce'], type: 'isim' },\n      { word: 'akıl', meaning: ['Düşünme yetisi'], type: 'isim' },\n      { word: 'hatırlamak', meaning: ['Bellekten çıkarmak'], type: 'fiil' },\n      { word: 'unutmak', meaning: ['Bellekten silmek'], type: 'fiil' },\n      { word: 'hafıza', meaning: ['Bellek'], type: 'isim' },\n      { word: 'deneyim', meaning: ['Yaşanmış tecrübe'], type: 'isim' },\n      { word: 'tecrübe', meaning: ['Deneyim'], type: 'isim' },\n      { word: 'deneme', meaning: ['Test etme'], type: 'isim' },\n      { word: 'denemek', meaning: ['Test etmek'], type: 'fiil' },\n      { word: 'başarı', meaning: ['Hedefe ulaşma'], type: 'isim' },\n      { word: 'başarısızlık', meaning: ['Hedefe ulaşamama'], type: 'isim' },\n      { word: 'başarmak', meaning: ['Hedefe ulaşmak'], type: 'fiil' },\n      { word: 'başaramak', meaning: ['Hedefe ulaşamak'], type: 'fiil' },\n      { word: 'yardım', meaning: ['Destek'], type: 'isim' },\n      { word: 'yardım etmek', meaning: ['Destek olmak'], type: 'fiil' },\n      { word: 'teşekkür', meaning: ['Şükran ifadesi'], type: 'isim' },\n      { word: 'teşekkür etmek', meaning: ['Şükran göstermek'], type: 'fiil' },\n      { word: 'rica', meaning: ['İstek'], type: 'isim' },\n      { word: 'rica etmek', meaning: ['İstek bildirmek'], type: 'fiil' },\n      { word: 'özür', meaning: ['Af dileme'], type: 'isim' },\n      { word: 'özür dilemek', meaning: ['Af istemek'], type: 'fiil' },\n      { word: 'affetmek', meaning: ['Bağışlamak'], type: 'fiil' },\n      { word: 'kızmak', meaning: ['Öfkelenmek'], type: 'fiil' },\n      { word: 'barışmak', meaning: ['Uzlaşmak'], type: 'fiil' },\n      { word: 'kavga', meaning: ['Anlaşmazlık'], type: 'isim' },\n      { word: 'kavga etmek', meaning: ['Anlaşmazlığa düşmek'], type: 'fiil' },\n      { word: 'konuşmak', meaning: ['Sözle iletişim kurmak'], type: 'fiil' },\n      { word: 'konuşma', meaning: ['Sözlü iletişim'], type: 'isim' },\n      { word: 'ses', meaning: ['İşitsel dalga'], type: 'isim' },\n      { word: 'sessiz', meaning: ['Ses çıkarmayan'], type: 'sıfat' },\n      { word: 'gürültü', meaning: ['Rahatsız edici ses'], type: 'isim' },\n      { word: 'müzik', meaning: ['Hoş ses düzenlemesi'], type: 'isim' },\n      { word: 'şarkı', meaning: ['Sözlü müzik'], type: 'isim' },\n      { word: 'şarkı söylemek', meaning: ['Sesle müzik yapmak'], type: 'fiil' },\n      { word: 'dans', meaning: ['Ritmik hareket'], type: 'isim' },\n      { word: 'dans etmek', meaning: ['Ritmik hareket yapmak'], type: 'fiil' },\n      { word: 'resim', meaning: ['Görsel sanat'], type: 'isim' },\n      { word: 'çizmek', meaning: ['Resim yapmak'], type: 'fiil' },\n      { word: 'boyamak', meaning: ['Renk vermek'], type: 'fiil' },\n      { word: 'renk', meaning: ['Görsel özellik'], type: 'isim' },\n      { word: 'açık', meaning: ['Kapanmamış'], type: 'sıfat' },\n      { word: 'kapalı', meaning: ['Kapanmış'], type: 'sıfat' },\n      { word: 'açmak', meaning: ['Kapanmış olanı açık hale getirmek'], type: 'fiil' },\n      { word: 'kapamak', meaning: ['Açık olanı kapalı hale getirmek'], type: 'fiil' },\n      { word: 'kapı', meaning: ['Giriş-çıkış yeri'], type: 'isim' },\n      { word: 'anahtar', meaning: ['Açma-kapama aleti'], type: 'isim' },\n      { word: 'kilit', meaning: ['Güvenlik aleti'], type: 'isim' },\n      { word: 'kilitlemek', meaning: ['Güvenlik altına almak'], type: 'fiil' },\n      { word: 'güvenlik', meaning: ['Emniyetlilik'], type: 'isim' },\n      { word: 'güvenli', meaning: ['Emniyetli'], type: 'sıfat' },\n      { word: 'tehlike', meaning: ['Risk'], type: 'isim' },\n      { word: 'tehlikeli', meaning: ['Riskli'], type: 'sıfat' },\n      { word: 'dikkat', meaning: ['Özen'], type: 'isim' },\n      { word: 'dikkatli', meaning: ['Özenli'], type: 'sıfat' },\n      { word: 'dikkatsiz', meaning: ['Özensiz'], type: 'sıfat' },\n      { word: 'hata', meaning: ['Yanlışlık'], type: 'isim' },\n      { word: 'yanlış', meaning: ['Hatalı'], type: 'sıfat' },\n      { word: 'doğru', meaning: ['Hatasız'], type: 'sıfat' },\n      { word: 'doğru', meaning: ['Gerçek'], type: 'isim' },\n      { word: 'yalan', meaning: ['Gerçek dışı'], type: 'isim' },\n      { word: 'gerçek', meaning: ['Hakiki'], type: 'sıfat' },\n      { word: 'sahte', meaning: ['Gerçek olmayan'], type: 'sıfat' },\n      { word: 'temiz', meaning: ['Kirli olmayan'], type: 'sıfat' },\n      { word: 'kirli', meaning: ['Temiz olmayan'], type: 'sıfat' },\n      { word: 'temizlemek', meaning: ['Kirli olmaktan çıkarmak'], type: 'fiil' },\n      { word: 'yıkamak', meaning: ['Su ile temizlemek'], type: 'fiil' },\n      { word: 'kurulamak', meaning: ['Su almaktan çıkarmak'], type: 'fiil' },\n      { word: 'ıslak', meaning: ['Su almış'], type: 'sıfat' },\n      { word: 'kuru', meaning: ['Su almamış'], type: 'sıfat' },\n      { word: 'yaş', meaning: ['Nemli'], type: 'sıfat' },\n      { word: 'nem', meaning: ['Rutubet'], type: 'isim' },\n      { word: 'ateş', meaning: ['Yanıcı enerji'], type: 'isim' },\n      { word: 'yanmak', meaning: ['Ateş almak'], type: 'fiil' },\n      { word: 'yakmak', meaning: ['Ateş vermek'], type: 'fiil' },\n      { word: 'söndürmek', meaning: ['Ateşi yok etmek'], type: 'fiil' },\n      { word: 'duman', meaning: ['Yanma ürünü'], type: 'isim' },\n      { word: 'hava', meaning: ['Atmosfer'], type: 'isim' },\n      { word: 'nefes', meaning: ['Soluk'], type: 'isim' },\n      { word: 'nefes almak', meaning: ['Soluk vermek'], type: 'fiil' },\n      { word: 'solumak', meaning: ['Nefes almak'], type: 'fiil' },\n      { word: 'yaşamak', meaning: ['Hayat sürmek'], type: 'fiil' },\n      { word: 'yaşam', meaning: ['Hayat'], type: 'isim' },\n      { word: 'hayat', meaning: ['Yaşam'], type: 'isim' },\n      { word: 'ölmek', meaning: ['Hayatı kaybetmek'], type: 'fiil' },\n      { word: 'ölüm', meaning: ['Hayat kaybı'], type: 'isim' },\n      { word: 'doğmak', meaning: ['Dünyaya gelmek'], type: 'fiil' },\n      { word: 'doğum', meaning: ['Dünyaya gelme'], type: 'isim' },\n      { word: 'büyümek', meaning: ['Gelişmek'], type: 'fiil' },\n      { word: 'küçülmek', meaning: ['Boyut kaybetmek'], type: 'fiil' },\n      { word: 'değişmek', meaning: ['Farklılaşmak'], type: 'fiil' },\n      { word: 'değişiklik', meaning: ['Farklılaşma'], type: 'isim' },\n      { word: 'aynı', meaning: ['Benzer'], type: 'sıfat' },\n      { word: 'farklı', meaning: ['Benzemeyen'], type: 'sıfat' },\n      { word: 'benzemek', meaning: ['Aynı olmak'], type: 'fiil' },\n      { word: 'benzerlik', meaning: ['Aynılık'], type: 'isim' },\n      { word: 'karşılaştırmak', meaning: ['Benzerlik aramak'], type: 'fiil' },\n      { word: 'seçmek', meaning: ['Tercih etmek'], type: 'fiil' },\n      { word: 'seçim', meaning: ['Tercih'], type: 'isim' },\n      { word: 'tercih', meaning: ['Seçim'], type: 'isim' },\n      { word: 'istemek', meaning: ['Arzu etmek'], type: 'fiil' },\n      { word: 'istememek', meaning: ['Arzu etmemek'], type: 'fiil' },\n      { word: 'arzu', meaning: ['İstek'], type: 'isim' },\n      { word: 'ihtiyaç', meaning: ['Gereksinim'], type: 'isim' },\n      { word: 'gerek', meaning: ['İhtiyaç'], type: 'isim' },\n      { word: 'gerekli', meaning: ['İhtiyaç olan'], type: 'sıfat' },\n      { word: 'gereksiz', meaning: ['İhtiyaç olmayan'], type: 'sıfat' },\n      { word: 'kullanmak', meaning: ['Faydalanmak'], type: 'fiil' },\n      { word: 'kullanım', meaning: ['Faydalanma'], type: 'isim' },\n      { word: 'fayda', meaning: ['Yarar'], type: 'isim' },\n      { word: 'faydalı', meaning: ['Yararlı'], type: 'sıfat' },\n      { word: 'zararlı', meaning: ['Faydasız'], type: 'sıfat' },\n      { word: 'zarar', meaning: ['Hasar'], type: 'isim' },\n      { word: 'kırmak', meaning: ['Parçalamak'], type: 'fiil' },\n      { word: 'kırılmak', meaning: ['Parçalanmak'], type: 'fiil' },\n      { word: 'tamir', meaning: ['Onarım'], type: 'isim' },\n      { word: 'tamir etmek', meaning: ['Onarmak'], type: 'fiil' },\n      { word: 'düzeltmek', meaning: ['Doğru hale getirmek'], type: 'fiil' },\n      { word: 'bozmak', meaning: ['Düzeni bozmak'], type: 'fiil' },\n      { word: 'bozuk', meaning: ['Düzensiz'], type: 'sıfat' },\n      { word: 'düzen', meaning: ['Sıra'], type: 'isim' },\n      { word: 'düzenli', meaning: ['Sıralı'], type: 'sıfat' },\n      { word: 'düzensiz', meaning: ['Sırasız'], type: 'sıfat' },\n      { word: 'sıra', meaning: ['Düzen'], type: 'isim' },\n      { word: 'sıralamak', meaning: ['Düzenlemek'], type: 'fiil' },\n      { word: 'karışmak', meaning: ['Düzensizleşmek'], type: 'fiil' },\n      { word: 'karıştırmak', meaning: ['Düzensizleştirmek'], type: 'fiil' },\n      { word: 'karışık', meaning: ['Düzensiz'], type: 'sıfat' },\n      { word: 'basit', meaning: ['Sade'], type: 'sıfat' },\n      { word: 'karmaşık', meaning: ['Zor'], type: 'sıfat' },\n      { word: 'kolay', meaning: ['Zor olmayan'], type: 'sıfat' },\n      { word: 'zor', meaning: ['Kolay olmayan'], type: 'sıfat' },\n      { word: 'zorlamak', meaning: ['Güç kullanmak'], type: 'fiil' },\n      { word: 'güç', meaning: ['Kuvvet'], type: 'isim' },\n      { word: 'güçlü', meaning: ['Kuvvetli'], type: 'sıfat' },\n      { word: 'güçsüz', meaning: ['Kuvvetsiz'], type: 'sıfat' },\n      { word: 'zayıf', meaning: ['Güçsüz'], type: 'sıfat' },\n      { word: 'güçlendirmek', meaning: ['Kuvvetlendirmek'], type: 'fiil' },\n      { word: 'zayıflatmak', meaning: ['Güçsüzleştirmek'], type: 'fiil' },\n      { word: 'artırmak', meaning: ['Çoğaltmak'], type: 'fiil' },\n      { word: 'azaltmak', meaning: ['Eksiltmek'], type: 'fiil' },\n      { word: 'artmak', meaning: ['Çoğalmak'], type: 'fiil' },\n      { word: 'azalmak', meaning: ['Eksilmek'], type: 'fiil' },\n      { word: 'fazlası', meaning: ['Artan kısım'], type: 'isim' },\n      { word: 'eksik', meaning: ['Az olan'], type: 'sıfat' },\n      { word: 'tam', meaning: ['Eksik olmayan'], type: 'sıfat' },\n      { word: 'tamamlamak', meaning: ['Eksiklerini gidermek'], type: 'fiil' },\n      { word: 'bitirmek', meaning: ['Sona erdirmek'], type: 'fiil' },\n      { word: 'bitmek', meaning: ['Sona ermek'], type: 'fiil' },\n      { word: 'devam etmek', meaning: ['Sürdürmek'], type: 'fiil' },\n      { word: 'durmak', meaning: ['Devam etmemek'], type: 'fiil' },\n      { word: 'durdurmak', meaning: ['Devam ettirmemek'], type: 'fiil' },\n      { word: 'başlamak', meaning: ['Başlangıç yapmak'], type: 'fiil' },\n      { word: 'başlatmak', meaning: ['Başlangıç yaptırmak'], type: 'fiil' },\n      { word: 'başlangıç', meaning: ['İlk adım'], type: 'isim' },\n      { word: 'sonuç', meaning: ['Son durum'], type: 'isim' },\n      { word: 'nedeni', meaning: ['Sebep'], type: 'isim' },\n      { word: 'sebep', meaning: ['Neden'], type: 'isim' },\n      { word: 'sonucu', meaning: ['Etkisi'], type: 'isim' },\n      { word: 'etki', meaning: ['Sonuç'], type: 'isim' },\n      { word: 'etkilemek', meaning: ['Sonuç yaratmak'], type: 'fiil' },\n      { word: 'etkilenmek', meaning: ['Sonuç almak'], type: 'fiil' },\n      { word: 'önemli', meaning: ['Değerli'], type: 'sıfat' },\n      { word: 'önemsiz', meaning: ['Değersiz'], type: 'sıfat' },\n      { word: 'önem', meaning: ['Değer'], type: 'isim' },\n      { word: 'değer', meaning: ['Önem'], type: 'isim' },\n      { word: 'değerli', meaning: ['Önemli'], type: 'sıfat' },\n      { word: 'değersiz', meaning: ['Önemsiz'], type: 'sıfat' },\n      { word: 'pahalı', meaning: ['Yüksek değerli'], type: 'sıfat' },\n      { word: 'ucuz', meaning: ['Düşük değerli'], type: 'sıfat' },\n      { word: 'bedava', meaning: ['Ücretsiz'], type: 'sıfat' },\n      { word: 'ücret', meaning: ['Bedel'], type: 'isim' },\n      { word: 'ücretli', meaning: ['Bedelli'], type: 'sıfat' },\n      { word: 'ücretsiz', meaning: ['Bedelsiz'], type: 'sıfat' },\n      { word: 'satmak', meaning: ['Karşılığında ücret almak'], type: 'fiil' },\n      { word: 'satın almak', meaning: ['Karşılığında ücret vermek'], type: 'fiil' },\n      { word: 'alışveriş', meaning: ['Satın alma'], type: 'isim' },\n      { word: 'mağaza', meaning: ['Satış yeri'], type: 'isim' },\n      { word: 'market', meaning: ['Yiyecek mağazası'], type: 'isim' },\n      { word: 'alışveriş yapmak', meaning: ['Satın alma yapmak'], type: 'fiil' },\n      { word: 'müşteri', meaning: ['Satın alan'], type: 'isim' },\n      { word: 'satıcı', meaning: ['Satan'], type: 'isim' },\n      { word: 'ürün', meaning: ['Mal'], type: 'isim' },\n      { word: 'mal', meaning: ['Eşya'], type: 'isim' },\n      { word: 'eşya', meaning: ['Nesne'], type: 'isim' },\n      { word: 'nesne', meaning: ['Obje'], type: 'isim' },\n      { word: 'obje', meaning: ['Cisim'], type: 'isim' },\n      { word: 'cisim', meaning: ['Madde'], type: 'isim' },\n      { word: 'madde', meaning: ['Materyal'], type: 'isim' },\n      { word: 'materyal', meaning: ['Malzeme'], type: 'isim' },\n      { word: 'malzeme', meaning: ['Ham madde'], type: 'isim' },\n      { word: 'üretmek', meaning: ['İmal etmek'], type: 'fiil' },\n      { word: 'üretim', meaning: ['İmalat'], type: 'isim' },\n      { word: 'fabrika', meaning: ['Üretim yeri'], type: 'isim' },\n      { word: 'işçi', meaning: ['Çalışan'], type: 'isim' },\n      { word: 'patron', meaning: ['İşveren'], type: 'isim' },\n      { word: 'şirket', meaning: ['İş kuruluşu'], type: 'isim' },\n      { word: 'ofis', meaning: ['İş yeri'], type: 'isim' },\n      { word: 'toplantı', meaning: ['Bir araya gelme'], type: 'isim' },\n      { word: 'toplantı yapmak', meaning: ['Bir araya gelmek'], type: 'fiil' },\n      { word: 'karar', meaning: ['Belirleme'], type: 'isim' },\n      { word: 'karar vermek', meaning: ['Belirlemek'], type: 'fiil' },\n      { word: 'plan', meaning: ['Program'], type: 'isim' },\n      { word: 'planlamak', meaning: ['Programlamak'], type: 'fiil' },\n      { word: 'program', meaning: ['Plan'], type: 'isim' },\n      { word: 'programlamak', meaning: ['Planlamak'], type: 'fiil' },\n      { word: 'proje', meaning: ['Çalışma'], type: 'isim' },\n      { word: 'çalışma', meaning: ['Proje'], type: 'isim' },\n      { word: 'rapor', meaning: ['Bildiri'], type: 'isim' },\n      { word: 'bildiri', meaning: ['Duyuru'], type: 'isim' },\n      { word: 'duyuru', meaning: ['İlan'], type: 'isim' },\n      { word: 'ilan', meaning: ['Reklam'], type: 'isim' },\n      { word: 'reklam', meaning: ['Tanıtım'], type: 'isim' },\n      { word: 'tanıtmak', meaning: ['Bildirmek'], type: 'fiil' },\n      { word: 'tanımak', meaning: ['Bilmek'], type: 'fiil' },\n      { word: 'tanışmak', meaning: ['Karşılaşmak'], type: 'fiil' },\n      { word: 'karşılaşmak', meaning: ['Rastlaşmak'], type: 'fiil' },\n      { word: 'rastlamak', meaning: ['Denk gelmek'], type: 'fiil' },\n      { word: 'buluşmak', meaning: ['Karşılaşmak'], type: 'fiil' },\n      { word: 'buluşma', meaning: ['Randevu'], type: 'isim' },\n      { word: 'randevu', meaning: ['Buluşma anlaşması'], type: 'isim' },\n      { word: 'anlaşma', meaning: ['Sözleşme'], type: 'isim' },\n      { word: 'sözleşme', meaning: ['Anlaşma'], type: 'isim' },\n      { word: 'anlaşmak', meaning: ['Uzlaşmak'], type: 'fiil' },\n      { word: 'anlaşmazlık', meaning: ['Uyuşmazlık'], type: 'isim' },\n      { word: 'uzlaşmak', meaning: ['Anlaşmak'], type: 'fiil' },\n      { word: 'uzlaşmazlık', meaning: ['Anlaşmazlık'], type: 'isim' },\n      { word: 'problem', meaning: ['Sorun'], type: 'isim' },\n      { word: 'sorun', meaning: ['Problem'], type: 'isim' },\n      { word: 'çözmek', meaning: ['Halletmek'], type: 'fiil' },\n      { word: 'çözüm', meaning: ['Hal'], type: 'isim' },\n      { word: 'halletmek', meaning: ['Çözmek'], type: 'fiil' },\n      { word: 'hal', meaning: ['Durum'], type: 'isim' },\n      { word: 'durum', meaning: ['Vaziyet'], type: 'isim' },\n      { word: 'vaziyet', meaning: ['Konum'], type: 'isim' },\n      { word: 'konum', meaning: ['Pozisyon'], type: 'isim' },\n      { word: 'pozisyon', meaning: ['Yer'], type: 'isim' },\n      { word: 'koymak', meaning: ['Yerleştirmek'], type: 'fiil' },\n      { word: 'yerleştirmek', meaning: ['Oturtmak'], type: 'fiil' },\n      { word: 'kaldırmak', meaning: ['Yerden almak'], type: 'fiil' },\n      { word: 'taşımak', meaning: ['Nakletmek'], type: 'fiil' },\n      { word: 'nakletmek', meaning: ['Göndermek'], type: 'fiil' },\n      { word: 'göndermek', meaning: ['İletmek'], type: 'fiil' },\n      { word: 'iletmek', meaning: ['Ulaştırmak'], type: 'fiil' },\n      { word: 'ulaştırmak', meaning: ['Eriştirmek'], type: 'fiil' },\n      { word: 'ulaşmak', meaning: ['Erişmek'], type: 'fiil' },\n      { word: 'erişmek', meaning: ['Varmak'], type: 'fiil' },\n      { word: 'varmak', meaning: ['Ulaşmak'], type: 'fiil' },\n      { word: 'dönmek', meaning: ['Geri gelmek'], type: 'fiil' },\n      { word: 'döndürmek', meaning: ['Geri göndermek'], type: 'fiil' },\n      { word: 'döndürmek', meaning: ['Çevirmek'], type: 'fiil' },\n      { word: 'çevirmek', meaning: ['Döndürmek'], type: 'fiil' },\n      { word: 'çevre', meaning: ['Etraf'], type: 'isim' },\n      { word: 'etraf', meaning: ['Çevre'], type: 'isim' },\n      { word: 'yakın', meaning: ['Uzak olmayan'], type: 'sıfat' },\n      { word: 'uzak', meaning: ['Yakın olmayan'], type: 'sıfat' },\n      { word: 'yaklaşmak', meaning: ['Uzaklaşmamak'], type: 'fiil' },\n      { word: 'uzaklaşmak', meaning: ['Yaklaşmamak'], type: 'fiil' },\n      { word: 'mesafe', meaning: ['Ara'], type: 'isim' },\n      { word: 'ara', meaning: ['Boşluk'], type: 'isim' },\n      { word: 'boşluk', meaning: ['Ara'], type: 'isim' },\n      { word: 'dolu', meaning: ['Boş olmayan'], type: 'sıfat' },\n      { word: 'boş', meaning: ['Dolu olmayan'], type: 'sıfat' },\n      { word: 'doldurmak', meaning: ['Boş olmaktan çıkarmak'], type: 'fiil' },\n      { word: 'boşaltmak', meaning: ['Dolu olmaktan çıkarmak'], type: 'fiil' },\n      { word: 'dolmak', meaning: ['Boş olmaktan çıkmak'], type: 'fiil' },\n      { word: 'boşalmak', meaning: ['Dolu olmaktan çıkmak'], type: 'fiil' },\n\n      // En çok kullanılan 1000 Türkçe kelime - Ek 500+ kelime\n      { word: 'aile', meaning: ['Anne, baba ve çocukların oluşturduğu toplumsal birim'], type: 'isim' },\n      { word: 'ahbap', meaning: ['Dost, arkadaş'], type: 'isim' },\n      { word: 'akan', meaning: ['Akıntı halinde olan'], type: 'sıfat' },\n      { word: 'akıllı', meaning: ['Zeki, düşünme gücü olan'], type: 'sıfat' },\n      { word: 'aktör', meaning: ['Oyuncu'], type: 'isim' },\n      { word: 'amaç', meaning: ['Hedef, gaye'], type: 'isim' },\n      { word: 'aman', meaning: ['Şaşırma, korku bildiren söz'], type: 'ünlem' },\n      { word: 'an', meaning: ['Zaman, dakika'], type: 'isim' },\n      { word: 'ancak', meaning: ['Fakat, lakin'], type: 'bağlaç' },\n      { word: 'aniden', meaning: ['Birden, birdenbire'], type: 'zarf' },\n      { word: 'anlat', meaning: ['Hikaye et, söyle'], type: 'fiil' },\n      { word: 'anlatmak', meaning: ['Söylemek, hikaye etmek'], type: 'fiil' },\n      { word: 'annem', meaning: ['Benim annem'], type: 'isim' },\n      { word: 'artık', meaning: ['Bundan sonra, şimdi'], type: 'zarf' },\n      { word: 'asla', meaning: ['Hiçbir zaman'], type: 'zarf' },\n      { word: 'aslında', meaning: ['Gerçekte'], type: 'zarf' },\n      { word: 'at', meaning: ['Binit hayvanı'], type: 'isim' },\n      { word: 'atmak', meaning: ['Fırlatmak'], type: 'fiil' },\n      { word: 'avukat', meaning: ['Hukuk mesleği yapan kişi'], type: 'isim' },\n      { word: 'ayak', meaning: ['Vücut uzvu'], type: 'isim' },\n      { word: 'ayakkabı', meaning: ['Ayağa giyilen'], type: 'isim' },\n      { word: 'aydınlık', meaning: ['Işıklı, parlak'], type: 'sıfat' },\n      { word: 'aynı', meaning: ['Benzer, eş'], type: 'sıfat' },\n      { word: 'ayrıca', meaning: ['Bundan başka'], type: 'zarf' },\n      { word: 'ayrılmak', meaning: ['Uzaklaşmak'], type: 'fiil' },\n      { word: 'azıcık', meaning: ['Çok az'], type: 'zarf' },\n      { word: 'bağırmak', meaning: ['Yüksek sesle konuşmak'], type: 'fiil' },\n      { word: 'bakan', meaning: ['Bakıcı, minister'], type: 'isim' },\n      { word: 'bakış', meaning: ['Görme biçimi'], type: 'isim' },\n      { word: 'bal', meaning: ['Arıların yaptığı tatlı madde'], type: 'isim' },\n      { word: 'bana', meaning: ['Bana'], type: 'zamir' },\n      { word: 'banka', meaning: ['Para işleri yapılan kurum'], type: 'isim' },\n      { word: 'bardak', meaning: ['İçecek kabı'], type: 'isim' },\n      { word: 'barış', meaning: ['Savaşsızlık, huzur'], type: 'isim' },\n      { word: 'basamak', meaning: ['Merdiven kademesi'], type: 'isim' },\n      { word: 'başka', meaning: ['Diğer, farklı'], type: 'sıfat' },\n      { word: 'başkan', meaning: ['Lider, reis'], type: 'isim' },\n      { word: 'başlık', meaning: ['Konu, titel'], type: 'isim' },\n      { word: 'baş', meaning: ['Vücudun üst kısmı'], type: 'isim' },\n      { word: 'bazen', meaning: ['Ara sıra'], type: 'zarf' },\n      { word: 'bazı', meaning: ['Kimi, birkaç'], type: 'sıfat' },\n      { word: 'beğenmek', meaning: ['Hoşlanmak'], type: 'fiil' },\n      { word: 'bekle', meaning: ['Beklemek emri'], type: 'fiil' },\n      { word: 'belli', meaning: ['Belirgin, açık'], type: 'sıfat' },\n      { word: 'belki', meaning: ['Olabilir'], type: 'zarf' },\n      { word: 'bence', meaning: ['Bana göre'], type: 'zarf' },\n      { word: 'bende', meaning: ['Benim yanımda'], type: 'edat' },\n      { word: 'beni', meaning: ['Ben zamirinin -i hali'], type: 'zamir' },\n      { word: 'beraber', meaning: ['Birlikte'], type: 'zarf' },\n      { word: 'berrak', meaning: ['Duru, temiz'], type: 'sıfat' },\n      { word: 'beslemek', meaning: ['Yedirmek'], type: 'fiil' },\n      { word: 'beş', meaning: ['5 sayısı'], type: 'sayı' },\n      { word: 'beyefendi', meaning: ['Erkek için saygı sözü'], type: 'isim' },\n      { word: 'bıkmak', meaning: ['Sıkılmak, usanmak'], type: 'fiil' },\n      { word: 'bırakmak', meaning: ['Terk etmek'], type: 'fiil' },\n      { word: 'bildiğim', meaning: ['Bildiğim'], type: 'sıfat' },\n      { word: 'bilgi', meaning: ['Malumat'], type: 'isim' },\n      { word: 'bilim', meaning: ['İlim'], type: 'isim' },\n      { word: 'bin', meaning: ['1000 sayısı'], type: 'sayı' },\n      { word: 'binmek', meaning: ['Üstüne çıkmak'], type: 'fiil' },\n      { word: 'biraz', meaning: ['Azıcık'], type: 'zarf' },\n      { word: 'birden', meaning: ['Aniden'], type: 'zarf' },\n      { word: 'birey', meaning: ['Kişi, fert'], type: 'isim' },\n      { word: 'birisi', meaning: ['Bir kişi'], type: 'zamir' },\n      { word: 'birkaç', meaning: ['Az sayıda'], type: 'sıfat' },\n      { word: 'birlikte', meaning: ['Beraber'], type: 'zarf' },\n      { word: 'biyoloji', meaning: ['Canlılar bilimi'], type: 'isim' },\n      { word: 'bize', meaning: ['Biz zamirinin -e hali'], type: 'zamir' },\n      { word: 'bizim', meaning: ['Biz zamirinin iyelik eki'], type: 'zamir' },\n      { word: 'bluz', meaning: ['Kadın gömleği'], type: 'isim' },\n      { word: 'böbrek', meaning: ['Vücut organı'], type: 'isim' },\n      { word: 'böcek', meaning: ['Küçük hayvan'], type: 'isim' },\n      { word: 'bölge', meaning: ['Alan, mıntıka'], type: 'isim' },\n      { word: 'bölüm', meaning: ['Kısım, bölük'], type: 'isim' },\n      { word: 'böyle', meaning: ['Bu şekilde'], type: 'sıfat' },\n      { word: 'böylece', meaning: ['Bu şekilde'], type: 'zarf' },\n      { word: 'bulmaca', meaning: ['Bilmece'], type: 'isim' },\n      { word: 'bulut', meaning: ['Gök cismi'], type: 'isim' },\n      { word: 'burada', meaning: ['Bu yerde'], type: 'zarf' },\n      { word: 'burası', meaning: ['Bu yer'], type: 'zamir' },\n      { word: 'burun', meaning: ['Koku alma organı'], type: 'isim' },\n      { word: 'büro', meaning: ['Ofis'], type: 'isim' },\n      { word: 'bütçe', meaning: ['Mali plan'], type: 'isim' },\n      { word: 'büyümek', meaning: ['Gelişmek'], type: 'fiil' },\n      { word: 'cadde', meaning: ['Geniş yol'], type: 'isim' },\n      { word: 'cam', meaning: ['Şeffaf madde'], type: 'isim' },\n      { word: 'cami', meaning: ['İbadet yeri'], type: 'isim' },\n      { word: 'canı', meaning: ['Ruh, yaşam'], type: 'isim' },\n      { word: 'canlı', meaning: ['Yaşayan'], type: 'sıfat' },\n      { word: 'cep', meaning: ['Kese'], type: 'isim' },\n      { word: 'ceviz', meaning: ['Sert kabuklu meyve'], type: 'isim' },\n      { word: 'ciddi', meaning: ['Ciddiyetle'], type: 'sıfat' },\n      { word: 'coğrafya', meaning: ['Yer bilimi'], type: 'isim' },\n      { word: 'çaba', meaning: ['Gayret'], type: 'isim' },\n      { word: 'çabuk', meaning: ['Hızlı'], type: 'sıfat' },\n      { word: 'çağ', meaning: ['Dönem, zaman'], type: 'isim' },\n      { word: 'çağırmak', meaning: ['Davet etmek'], type: 'fiil' },\n      { word: 'çakmak', meaning: ['Ateş verici alet'], type: 'isim' },\n      { word: 'çalı', meaning: ['Küçük bitki'], type: 'isim' },\n      { word: 'çalışkan', meaning: ['Çok çalışan'], type: 'sıfat' },\n      { word: 'çalmak', meaning: ['Müzik yapmak'], type: 'fiil' },\n      { word: 'çamur', meaning: ['Islak toprak'], type: 'isim' },\n      { word: 'çantam', meaning: ['Benim çantam'], type: 'isim' },\n      { word: 'çapta', meaning: ['Boyutta'], type: 'edat' },\n      { word: 'çare', meaning: ['Çözüm'], type: 'isim' },\n      { word: 'çarşı', meaning: ['Alışveriş yeri'], type: 'isim' },\n      { word: 'çatal', meaning: ['Yemek aleti'], type: 'isim' },\n      { word: 'çay', meaning: ['İçecek'], type: 'isim' },\n      { word: 'çekmek', meaning: ['Çekme işlemi'], type: 'fiil' },\n      { word: 'çelik', meaning: ['Sert metal'], type: 'isim' },\n      { word: 'çember', meaning: ['Daire şeklinde'], type: 'isim' },\n      { word: 'çene', meaning: ['Ağız kısmı'], type: 'isim' },\n      { word: 'çeşit', meaning: ['Tür'], type: 'isim' },\n      { word: 'çevirmen', meaning: ['Tercüman'], type: 'isim' },\n      { word: 'çiğ', meaning: ['Pişmemiş'], type: 'sıfat' },\n      { word: 'çile', meaning: ['Sıkıntı'], type: 'isim' },\n      { word: 'çimento', meaning: ['İnşaat maddesi'], type: 'isim' },\n      { word: 'çizgi', meaning: ['Hat'], type: 'isim' },\n      { word: 'çizme', meaning: ['Uzun ayakkabı'], type: 'isim' },\n      { word: 'çoban', meaning: ['Hayvan bakıcısı'], type: 'isim' },\n      { word: 'çoğu', meaning: ['Büyük kısmı'], type: 'sıfat' },\n      { word: 'çorba', meaning: ['Sıvı yemek'], type: 'isim' },\n      { word: 'çukur', meaning: ['Çöküntü'], type: 'isim' },\n      { word: 'çünkü', meaning: ['Sebep bildiren bağlaç'], type: 'bağlaç' },\n      { word: 'dağ', meaning: ['Yüksek yer şekli'], type: 'isim' },\n      { word: 'dağıtmak', meaning: ['Yaymak'], type: 'fiil' },\n      { word: 'daha', meaning: ['Daha fazla'], type: 'zarf' },\n      { word: 'dahi', meaning: ['Bile'], type: 'edat' },\n      { word: 'dahil', meaning: ['İçinde'], type: 'edat' },\n      { word: 'daima', meaning: ['Her zaman'], type: 'zarf' },\n      { word: 'dal', meaning: ['Ağaç kolu'], type: 'isim' },\n      { word: 'dalgın', meaning: ['Dikkatsiz'], type: 'sıfat' },\n      { word: 'dans', meaning: ['Ritimli hareket'], type: 'isim' },\n      { word: 'davet', meaning: ['Çağrı'], type: 'isim' },\n      { word: 'dayı', meaning: ['Anne kardeşi'], type: 'isim' },\n      { word: 'değil', meaning: ['Değil kelimesi'], type: 'fiil' },\n      { word: 'değişik', meaning: ['Farklı'], type: 'sıfat' },\n      { word: 'değmek', meaning: ['Temas etmek'], type: 'fiil' },\n      { word: 'deli', meaning: ['Akıl hastası'], type: 'sıfat' },\n      { word: 'delik', meaning: ['Oyuk'], type: 'isim' },\n      { word: 'deniz', meaning: ['Büyük su kitlesi'], type: 'isim' },\n      { word: 'deprem', meaning: ['Yer sarsıntısı'], type: 'isim' },\n      { word: 'derece', meaning: ['Seviye'], type: 'isim' },\n      { word: 'dergi', meaning: ['Süreli yayın'], type: 'isim' },\n      { word: 'dert', meaning: ['Problem'], type: 'isim' },\n      { word: 'dış', meaning: ['Dışarı'], type: 'isim' },\n      { word: 'dışarı', meaning: ['Dış taraf'], type: 'zarf' },\n      { word: 'diğer', meaning: ['Başka'], type: 'sıfat' },\n      { word: 'dikmek', meaning: ['Dikey yapmak'], type: 'fiil' },\n      { word: 'dil', meaning: ['Konuşma organı'], type: 'isim' },\n      { word: 'dilek', meaning: ['İstek'], type: 'isim' },\n      { word: 'din', meaning: ['İnanç sistemi'], type: 'isim' },\n      { word: 'dinlemek', meaning: ['Kulak vermek'], type: 'fiil' },\n      { word: 'dış', meaning: ['Dışarı'], type: 'isim' },\n      { word: 'diş', meaning: ['Ağız organı'], type: 'isim' },\n      { word: 'doğa', meaning: ['Tabiat'], type: 'isim' },\n      { word: 'doğmak', meaning: ['Dünyaya gelmek'], type: 'fiil' },\n      { word: 'doktor', meaning: ['Hekim'], type: 'isim' },\n      { word: 'dolar', meaning: ['Amerikan parası'], type: 'isim' },\n      { word: 'dolmak', meaning: ['İçi dolmak'], type: 'fiil' },\n      { word: 'don', meaning: ['İç çamaşırı'], type: 'isim' },\n      { word: 'donmak', meaning: ['Buzlaşmak'], type: 'fiil' },\n      { word: 'dost', meaning: ['Arkadaş'], type: 'isim' },\n      { word: 'döviz', meaning: ['Yabancı para'], type: 'isim' },\n      { word: 'dövmek', meaning: ['Vurmak'], type: 'fiil' },\n      { word: 'düğme', meaning: ['İlik'], type: 'isim' },\n      { word: 'dükkan', meaning: ['Mağaza'], type: 'isim' },\n      { word: 'dün', meaning: ['Geçen gün'], type: 'zarf' },\n      { word: 'dünya', meaning: ['Gezegen'], type: 'isim' },\n      { word: 'düşman', meaning: ['Hasım'], type: 'isim' },\n      { word: 'düşük', meaning: ['Alçak'], type: 'sıfat' },\n      { word: 'düzen', meaning: ['Tertip'], type: 'isim' },\n      { word: 'ebe', meaning: ['Doğum yardımcısı'], type: 'isim' },\n      { word: 'eczane', meaning: ['İlaç satan yer'], type: 'isim' },\n      { word: 'edebiyat', meaning: ['Yazın'], type: 'isim' },\n      { word: 'eğitim', meaning: ['Öğretim'], type: 'isim' },\n      { word: 'ek', meaning: ['İlave'], type: 'isim' },\n      { word: 'ekip', meaning: ['Takım'], type: 'isim' },\n      { word: 'ekonomi', meaning: ['İktisat'], type: 'isim' },\n      { word: 'ekmek', meaning: ['Temel besin'], type: 'isim' },\n      { word: 'eksik', meaning: ['Az'], type: 'sıfat' },\n      { word: 'elektrik', meaning: ['Enerji türü'], type: 'isim' },\n      { word: 'elbise', meaning: ['Kadın giysisi'], type: 'isim' },\n      { word: 'elçi', meaning: ['Büyükelçi'], type: 'isim' },\n      { word: 'emek', meaning: ['Çalışma'], type: 'isim' },\n      { word: 'emir', meaning: ['Buyruk'], type: 'isim' },\n      { word: 'emniyet', meaning: ['Güvenlik'], type: 'isim' },\n      { word: 'endişe', meaning: ['Kaygı'], type: 'isim' },\n      { word: 'enerji', meaning: ['Güç'], type: 'isim' },\n      { word: 'engel', meaning: ['Mani'], type: 'isim' },\n      { word: 'eş', meaning: ['Karı koca'], type: 'isim' },\n      { word: 'eşya', meaning: ['Mal'], type: 'isim' },\n      { word: 'etmek', meaning: ['Yapmak'], type: 'fiil' },\n      { word: 'euro', meaning: ['Avrupa parası'], type: 'isim' },\n      { word: 'evlenmek', meaning: ['Nikah yapmak'], type: 'fiil' },\n      { word: 'evvel', meaning: ['Önce'], type: 'zarf' },\n      { word: 'ey', meaning: ['Seslenme sözü'], type: 'ünlem' },\n      { word: 'eylem', meaning: ['Hareket'], type: 'isim' },\n      { word: 'fabrika', meaning: ['Üretim yeri'], type: 'isim' },\n      { word: 'fakat', meaning: ['Ama'], type: 'bağlaç' },\n      { word: 'fakir', meaning: ['Yoksul'], type: 'sıfat' },\n      { word: 'fare', meaning: ['Küçük kemirgen'], type: 'isim' },\n      { word: 'fark', meaning: ['Ayrım'], type: 'isim' },\n      { word: 'farz', meaning: ['Varsayım'], type: 'isim' },\n      { word: 'fasıl', meaning: ['Bölüm'], type: 'isim' },\n      { word: 'fayda', meaning: ['Yarar'], type: 'isim' },\n      { word: 'fazla', meaning: ['Çok'], type: 'sıfat' },\n      { word: 'federal', meaning: ['Birleşik'], type: 'sıfat' },\n      { word: 'felsefe', meaning: ['Hikmet'], type: 'isim' },\n      { word: 'fen', meaning: ['Bilim'], type: 'isim' },\n      { word: 'fener', meaning: ['Işık aleti'], type: 'isim' },\n      { word: 'fırın', meaning: ['Pişirme yeri'], type: 'isim' },\n      { word: 'fırsat', meaning: ['Şans'], type: 'isim' },\n      { word: 'fikir', meaning: ['Düşünce'], type: 'isim' },\n      { word: 'finans', meaning: ['Mali işler'], type: 'isim' },\n      { word: 'fizik', meaning: ['Doğa bilimi'], type: 'isim' },\n      { word: 'fiyat', meaning: ['Değer'], type: 'isim' },\n      { word: 'fon', meaning: ['Kaynak'], type: 'isim' },\n      { word: 'form', meaning: ['Biçim'], type: 'isim' },\n      { word: 'foto', meaning: ['Resim'], type: 'isim' },\n      { word: 'fren', meaning: ['Durdurucu'], type: 'isim' },\n      { word: 'garip', meaning: ['Acayip'], type: 'sıfat' },\n      { word: 'gaz', meaning: ['Gaz hali'], type: 'isim' },\n      { word: 'gazete', meaning: ['Günlük yayın'], type: 'isim' },\n      { word: 'geçmek', meaning: ['Aşmak'], type: 'fiil' },\n      { word: 'gece', meaning: ['Karanlık vakit'], type: 'isim' },\n      { word: 'gelen', meaning: ['Gelen'], type: 'sıfat' },\n      { word: 'genel', meaning: ['Umumi'], type: 'sıfat' },\n      { word: 'genç', meaning: ['Yaşlı olmayan'], type: 'sıfat' },\n      { word: 'gerçek', meaning: ['Hakiki'], type: 'sıfat' },\n      { word: 'geri', meaning: ['Arkaya'], type: 'zarf' },\n      { word: 'gider', meaning: ['Masraf'], type: 'isim' },\n      { word: 'gidermek', meaning: ['Yok etmek'], type: 'fiil' },\n      { word: 'giriş', meaning: ['Başlangıç'], type: 'isim' },\n      { word: 'giysi', meaning: ['Elbise'], type: 'isim' },\n      { word: 'gizli', meaning: ['Saklı'], type: 'sıfat' },\n      { word: 'göl', meaning: ['Su kitlesi'], type: 'isim' },\n      { word: 'gömlek', meaning: ['Üst giysisi'], type: 'isim' },\n      { word: 'göndermek', meaning: ['Yollamak'], type: 'fiil' },\n      { word: 'görüş', meaning: ['Fikir'], type: 'isim' },\n      { word: 'gözlük', meaning: ['Görme aleti'], type: 'isim' },\n      { word: 'grup', meaning: ['Küme'], type: 'isim' },\n      { word: 'güçlü', meaning: ['Kuvvetli'], type: 'sıfat' },\n      { word: 'gül', meaning: ['Çiçek'], type: 'isim' },\n      { word: 'gümrük', meaning: ['Sınır kapısı'], type: 'isim' },\n      { word: 'gümüş', meaning: ['Değerli maden'], type: 'isim' },\n      { word: 'günlük', meaning: ['Her gün olan'], type: 'sıfat' },\n      { word: 'güvenlik', meaning: ['Emniyet'], type: 'isim' },\n      { word: 'haber', meaning: ['Bilgi'], type: 'isim' },\n      { word: 'haberci', meaning: ['Bilgi getiren'], type: 'isim' },\n      { word: 'habersiz', meaning: ['Bilgisiz'], type: 'sıfat' },\n      { word: 'hacim', meaning: ['Boyut'], type: 'isim' },\n      { word: 'hadise', meaning: ['Olay'], type: 'isim' },\n      { word: 'hafif', meaning: ['Az ağırlıklı'], type: 'sıfat' },\n      { word: 'hak', meaning: ['Adalet'], type: 'isim' },\n      { word: 'hakem', meaning: ['Yargıç'], type: 'isim' },\n      { word: 'hala', meaning: ['Hâlâ'], type: 'zarf' },\n      { word: 'halı', meaning: ['Yer döşemesi'], type: 'isim' },\n      { word: 'halk', meaning: ['Millet'], type: 'isim' },\n      { word: 'hamam', meaning: ['Yıkanma yeri'], type: 'isim' },\n      { word: 'hamur', meaning: ['Karışım'], type: 'isim' },\n      { word: 'hangi', meaning: ['Ne'], type: 'sıfat' },\n      { word: 'hap', meaning: ['İlaç'], type: 'isim' },\n      { word: 'hapisane', meaning: ['Cezaevi'], type: 'isim' },\n      { word: 'hareket', meaning: ['Eylem'], type: 'isim' },\n      { word: 'harp', meaning: ['Savaş'], type: 'isim' },\n      { word: 'hasta', meaning: ['Sağlıksız'], type: 'sıfat' },\n      { word: 'haşere', meaning: ['Zararlı böcek'], type: 'isim' },\n      { word: 'hatıra', meaning: ['Anı'], type: 'isim' },\n      { word: 'hava', meaning: ['Atmosfer'], type: 'isim' },\n      { word: 'havuz', meaning: ['Su çukuru'], type: 'isim' },\n      { word: 'haya', meaning: ['Utanma'], type: 'isim' },\n      { word: 'hayal', meaning: ['Rüya'], type: 'isim' },\n      { word: 'hayır', meaning: ['Ret cevabı'], type: 'ünlem' },\n      { word: 'hazır', meaning: ['Tamam'], type: 'sıfat' },\n      { word: 'hece', meaning: ['Ses birimi'], type: 'isim' },\n      { word: 'hedef', meaning: ['Gaye'], type: 'isim' },\n      { word: 'hediye', meaning: ['Armağan'], type: 'isim' },\n      { word: 'hemen', meaning: ['Derhal'], type: 'zarf' },\n      { word: 'hem', meaning: ['Aynı zamanda'], type: 'bağlaç' },\n      { word: 'henüz', meaning: ['Daha'], type: 'zarf' },\n      { word: 'hep', meaning: ['Daima'], type: 'zarf' },\n      { word: 'hesap', meaning: ['Sayma'], type: 'isim' },\n      { word: 'heyecan', meaning: ['Coşku'], type: 'isim' },\n      { word: 'hız', meaning: ['Sürat'], type: 'isim' },\n      { word: 'hizmet', meaning: ['Hizmet etme'], type: 'isim' },\n      { word: 'hoş', meaning: ['Güzel'], type: 'sıfat' },\n      { word: 'hükümet', meaning: ['Yönetim'], type: 'isim' },\n      { word: 'hürriyet', meaning: ['Özgürlük'], type: 'isim' },\n      { word: 'ırmak', meaning: ['Küçük nehir'], type: 'isim' },\n      { word: 'ısı', meaning: ['Sıcaklık'], type: 'isim' },\n      { word: 'içerik', meaning: ['Muhteva'], type: 'isim' },\n      { word: 'içinde', meaning: ['İçte'], type: 'edat' },\n      { word: 'içki', meaning: ['Alkollü içecek'], type: 'isim' },\n      { word: 'ideal', meaning: ['Mükemmel'], type: 'sıfat' },\n      { word: 'iddia', meaning: ['Öne sürme'], type: 'isim' },\n      { word: 'ikinci', meaning: ['2. sırada'], type: 'sayı' },\n      { word: 'iklim', meaning: ['Hava durumu'], type: 'isim' },\n      { word: 'ilahi', meaning: ['Dini şarkı'], type: 'isim' },\n      { word: 'ile', meaning: ['İle birlikte'], type: 'edat' },\n      { word: 'ileri', meaning: ['Öne doğru'], type: 'zarf' },\n      { word: 'ilgili', meaning: ['Alakalı'], type: 'sıfat' },\n      { word: 'ilk', meaning: ['Birinci'], type: 'sıfat' },\n      { word: 'imam', meaning: ['Din görevlisi'], type: 'isim' },\n      { word: 'imkan', meaning: ['Olanak'], type: 'isim' },\n      { word: 'imza', meaning: ['İsim'], type: 'isim' },\n      { word: 'inan', meaning: ['İnanmak'], type: 'fiil' },\n      { word: 'ince', meaning: ['Kalın olmayan'], type: 'sıfat' },\n      { word: 'insan', meaning: ['Kişi'], type: 'isim' },\n      { word: 'ipek', meaning: ['Böcek lifi'], type: 'isim' },\n      { word: 'irade', meaning: ['İstek gücü'], type: 'isim' },\n      { word: 'işte', meaning: ['İşte'], type: 'ünlem' },\n      { word: 'işçi', meaning: ['Çalışan'], type: 'isim' },\n      { word: 'işlem', meaning: ['Süreç'], type: 'isim' },\n      { word: 'işsiz', meaning: ['Çalışmayan'], type: 'sıfat' },\n      { word: 'iyi', meaning: ['Güzel'], type: 'sıfat' },\n      { word: 'japon', meaning: ['Japonya\\'dan'], type: 'sıfat' },\n      { word: 'jimnastik', meaning: ['Beden eğitimi'], type: 'isim' },\n      { word: 'jüri', meaning: ['Değerlendirme heyeti'], type: 'isim' },\n      { word: 'kabin', meaning: ['Küçük oda'], type: 'isim' },\n      { word: 'kâğıt', meaning: ['Yazı maddesi'], type: 'isim' },\n      { word: 'kah', meaning: ['Bazen'], type: 'zarf' },\n      { word: 'kahve', meaning: ['İçecek'], type: 'isim' },\n      { word: 'kalabalık', meaning: ['Çok kişi'], type: 'isim' },\n      { word: 'kalas', meaning: ['Ahşap'], type: 'isim' },\n      { word: 'kale', meaning: ['Savunma yapısı'], type: 'isim' },\n      { word: 'kalp', meaning: ['Yürek'], type: 'isim' },\n      { word: 'kamp', meaning: ['Çadırda kalma'], type: 'isim' },\n      { word: 'kan', meaning: ['Vücut sıvısı'], type: 'isim' },\n      { word: 'kanat', meaning: ['Uçma organı'], type: 'isim' },\n      { word: 'kanun', meaning: ['Hukuk kuralı'], type: 'isim' },\n      { word: 'kapak', meaning: ['Örtü'], type: 'isim' },\n      { word: 'kapat', meaning: ['Kapatmak'], type: 'fiil' },\n      { word: 'kar', meaning: ['Beyaz yağış'], type: 'isim' },\n      { word: 'karakter', meaning: ['Kişilik'], type: 'isim' },\n      { word: 'karı', meaning: ['Eş'], type: 'isim' },\n      { word: 'karın', meaning: ['Göbek'], type: 'isim' },\n      { word: 'karışık', meaning: ['Düzensiz'], type: 'sıfat' },\n      { word: 'karar', meaning: ['Belirleme'], type: 'isim' },\n      { word: 'kargo', meaning: ['Taşımacılık'], type: 'isim' },\n      { word: 'karma', meaning: ['Karışım'], type: 'isim' },\n      { word: 'karşı', meaning: ['Zıt'], type: 'edat' },\n      { word: 'kat', meaning: ['Bina bölümü'], type: 'isim' },\n      { word: 'katı', meaning: ['Sert'], type: 'sıfat' },\n      { word: 'katılmak', meaning: ['Dahil olmak'], type: 'fiil' },\n      { word: 'kavga', meaning: ['Tartışma'], type: 'isim' },\n      { word: 'kayıp', meaning: ['Bulunamayan'], type: 'sıfat' },\n      { word: 'kazan', meaning: ['Büyük kap'], type: 'isim' },\n      { word: 'kedi', meaning: ['Evcil hayvan'], type: 'isim' },\n      { word: 'kefaret', meaning: ['Bedel'], type: 'isim' },\n      { word: 'kelle', meaning: ['Kafa'], type: 'isim' },\n      { word: 'kemik', meaning: ['Vücut iskeleti'], type: 'isim' },\n      { word: 'kendi', meaning: ['Kişinin kendisi'], type: 'zamir' },\n      { word: 'kere', meaning: ['Defa'], type: 'isim' },\n      { word: 'kesmek', meaning: ['Ayırmak'], type: 'fiil' },\n      { word: 'kesin', meaning: ['Kesin'], type: 'sıfat' },\n      { word: 'kesim', meaning: ['Bölge'], type: 'isim' },\n      { word: 'kez', meaning: ['Defa'], type: 'isim' },\n      { word: 'kıl', meaning: ['İnce tüy'], type: 'isim' },\n      { word: 'kır', meaning: ['Kırsal alan'], type: 'isim' },\n      { word: 'kırık', meaning: ['Bozuk'], type: 'sıfat' },\n      { word: 'kış', meaning: ['Soğuk mevsim'], type: 'isim' },\n      { word: 'kısmen', meaning: ['Kısmen'], type: 'zarf' },\n      { word: 'kıta', meaning: ['Büyük kara parçası'], type: 'isim' },\n      { word: 'kıyı', meaning: ['Sahil'], type: 'isim' },\n      { word: 'kıymet', meaning: ['Değer'], type: 'isim' },\n      { word: 'kız', meaning: ['Genç kadın'], type: 'isim' },\n      { word: 'kızdırmak', meaning: ['Öfkelendirmek'], type: 'fiil' },\n      { word: 'kimse', meaning: ['Hiç kimse'], type: 'zamir' },\n      { word: 'kimya', meaning: ['Madde bilimi'], type: 'isim' },\n      { word: 'kira', meaning: ['Kira ücreti'], type: 'isim' },\n      { word: 'kirli', meaning: ['Temiz olmayan'], type: 'sıfat' },\n      { word: 'kişi', meaning: ['İnsan'], type: 'isim' },\n      { word: 'kitap', meaning: ['Yazılı eser'], type: 'isim' },\n      { word: 'koca', meaning: ['Eş'], type: 'isim' },\n      { word: 'kod', meaning: ['Şifre'], type: 'isim' },\n      { word: 'koku', meaning: ['Koku'], type: 'isim' },\n      { word: 'kol', meaning: ['Vücut uzvu'], type: 'isim' },\n      { word: 'koltuk', meaning: ['Oturma yeri'], type: 'isim' },\n      { word: 'komşu', meaning: ['Yakın yaşayan'], type: 'isim' },\n      { word: 'konu', meaning: ['Mevzu'], type: 'isim' },\n      { word: 'konuk', meaning: ['Misafir'], type: 'isim' },\n      { word: 'konum', meaning: ['Yer'], type: 'isim' },\n      { word: 'kopya', meaning: ['Suret'], type: 'isim' },\n      { word: 'koridor', meaning: ['Geçit'], type: 'isim' },\n      { word: 'koruma', meaning: ['Muhafaza'], type: 'isim' },\n      { word: 'kova', meaning: ['Su kabı'], type: 'isim' },\n      { word: 'koyun', meaning: ['Evcil hayvan'], type: 'isim' },\n      { word: 'köz', meaning: ['Ateş'], type: 'isim' },\n      { word: 'köşe', meaning: ['Açının birleşme yeri'], type: 'isim' },\n      { word: 'köylü', meaning: ['Köyde yaşayan'], type: 'isim' },\n      { word: 'kredi', meaning: ['Borç'], type: 'isim' },\n      { word: 'kriz', meaning: ['Bunalım'], type: 'isim' },\n      { word: 'kuaför', meaning: ['Saç kesici'], type: 'isim' },\n      { word: 'kuba', meaning: ['Zar'], type: 'isim' },\n      { word: 'kucak', meaning: ['Kol arası'], type: 'isim' },\n      { word: 'kudret', meaning: ['Güç'], type: 'isim' },\n      { word: 'kule', meaning: ['Yüksek yapı'], type: 'isim' },\n      { word: 'kulak', meaning: ['İşitme organı'], type: 'isim' },\n      { word: 'kulüp', meaning: ['Dernek'], type: 'isim' },\n      { word: 'kum', meaning: ['İnce taneli madde'], type: 'isim' },\n      { word: 'kupa', meaning: ['Kap'], type: 'isim' },\n      { word: 'kupon', meaning: ['Fiş'], type: 'isim' },\n      { word: 'kural', meaning: ['Prensip'], type: 'isim' },\n      { word: 'kurs', meaning: ['Eğitim'], type: 'isim' },\n      { word: 'kurtarmak', meaning: ['Kurtarmak'], type: 'fiil' },\n      { word: 'kutu', meaning: ['Sandık'], type: 'isim' },\n      { word: 'kutsal', meaning: ['Mukaddes'], type: 'sıfat' },\n      { word: 'kuvvet', meaning: ['Güç'], type: 'isim' },\n      { word: 'kuzey', meaning: ['Yön'], type: 'isim' },\n      { word: 'küçük', meaning: ['Ufak'], type: 'sıfat' },\n      { word: 'külot', meaning: ['İç çamaşırı'], type: 'isim' },\n      { word: 'kültür', meaning: ['Uygarlık'], type: 'isim' },\n      { word: 'küpe', meaning: ['Kulak süsü'], type: 'isim' },\n      { word: 'küvet', meaning: ['Banyo teknesi'], type: 'isim' },\n      { word: 'laboratuvar', meaning: ['Deney yeri'], type: 'isim' },\n      { word: 'laf', meaning: ['Söz'], type: 'isim' },\n      { word: 'lamba', meaning: ['Işık aleti'], type: 'isim' },\n      { word: 'latin', meaning: ['Latin'], type: 'sıfat' },\n      { word: 'leke', meaning: ['Kirlilik'], type: 'isim' },\n      { word: 'lez', meaning: ['Tat'], type: 'isim' },\n      { word: 'liberal', meaning: ['Özgürlükçü'], type: 'sıfat' },\n      { word: 'liman', meaning: ['Gemi limanı'], type: 'isim' },\n      { word: 'limon', meaning: ['Ekşi meyve'], type: 'isim' },\n      { word: 'liste', meaning: ['Cetvel'], type: 'isim' },\n      { word: 'locus', meaning: ['Yer'], type: 'isim' },\n      { word: 'lüks', meaning: ['Güzel'], type: 'sıfat' },\n      { word: 'maç', meaning: ['Yarışma'], type: 'isim' },\n      { word: 'madde', meaning: ['Nesne'], type: 'isim' },\n      { word: 'maden', meaning: ['Yer altı kaynağı'], type: 'isim' },\n      { word: 'magazin', meaning: ['Dergi'], type: 'isim' },\n      { word: 'mahalle', meaning: ['Semt'], type: 'isim' },\n      { word: 'makina', meaning: ['Alet'], type: 'isim' },\n      { word: 'makine', meaning: ['Mekanik alet'], type: 'isim' },\n      { word: 'makul', meaning: ['Mantıklı'], type: 'sıfat' },\n      { word: 'mal', meaning: ['Eşya'], type: 'isim' },\n      { word: 'mama', meaning: ['Bebek yemeği'], type: 'isim' },\n      { word: 'mana', meaning: ['Anlam'], type: 'isim' },\n      { word: 'manas', meaning: ['Mana'], type: 'isim' },\n      { word: 'mangal', meaning: ['Ateş yakma yeri'], type: 'isim' },\n      { word: 'manto', meaning: ['Dış giysi'], type: 'isim' },\n      { word: 'marka', meaning: ['İşaret'], type: 'isim' },\n      { word: 'mavi', meaning: ['Renk'], type: 'isim' },\n      { word: 'mayıs', meaning: ['5. ay'], type: 'isim' },\n      { word: 'mazi', meaning: ['Geçmiş'], type: 'isim' },\n      { word: 'meclis', meaning: ['Kurul'], type: 'isim' },\n      { word: 'medya', meaning: ['İletişim araçları'], type: 'isim' },\n      { word: 'mekan', meaning: ['Yer'], type: 'isim' },\n      { word: 'mektup', meaning: ['Yazı'], type: 'isim' },\n      { word: 'memnun', meaning: ['Hoşnut'], type: 'sıfat' },\n      { word: 'memur', meaning: ['Devlet görevlisi'], type: 'isim' },\n      { word: 'menfaat', meaning: ['Çıkar'], type: 'isim' },\n      { word: 'mesafe', meaning: ['Uzaklık'], type: 'isim' },\n      { word: 'mesaj', meaning: ['Bildiri'], type: 'isim' },\n      { word: 'mesele', meaning: ['Sorun'], type: 'isim' },\n      { word: 'meslek', meaning: ['İş'], type: 'isim' },\n      { word: 'metin', meaning: ['Yazı'], type: 'isim' },\n      { word: 'metro', meaning: ['Yeraltı trenı'], type: 'isim' },\n      { word: 'meydan', meaning: ['Alan'], type: 'isim' },\n      { word: 'meyveli', meaning: ['Meyve içeren'], type: 'sıfat' },\n      { word: 'mezar', meaning: ['Ölü yeri'], type: 'isim' },\n      { word: 'mısır', meaning: ['Tahıl'], type: 'isim' },\n      { word: 'mide', meaning: ['Mide organı'], type: 'isim' },\n      { word: 'mimarlık', meaning: ['Yapı sanatı'], type: 'isim' },\n      { word: 'minder', meaning: ['Yastık'], type: 'isim' },\n      { word: 'miras', meaning: ['Kalıt'], type: 'isim' },\n      { word: 'misafir', meaning: ['Konuk'], type: 'isim' },\n      { word: 'moda', meaning: ['Giyim trendi'], type: 'isim' },\n      { word: 'modern', meaning: ['Çağdaş'], type: 'sıfat' },\n      { word: 'motosiklet', meaning: ['İki tekerlekli araç'], type: 'isim' },\n      { word: 'motor', meaning: ['Makina'], type: 'isim' },\n      { word: 'mucize', meaning: ['Harika olay'], type: 'isim' },\n      { word: 'muhasebe', meaning: ['Sayım'], type: 'isim' },\n      { word: 'mum', meaning: ['Işık maddesi'], type: 'isim' },\n      { word: 'muz', meaning: ['Sarı meyve'], type: 'isim' },\n      { word: 'müdür', meaning: ['Yönetici'], type: 'isim' },\n      { word: 'mükemmel', meaning: ['Kusursuz'], type: 'sıfat' },\n      { word: 'mümkün', meaning: ['Olabilir'], type: 'sıfat' },\n      { word: 'müşteri', meaning: ['Alıcı'], type: 'isim' },\n      { word: 'müze', meaning: ['Eser sergisi'], type: 'isim' },\n      { word: 'müzisyen', meaning: ['Müzik yapan'], type: 'isim' },\n      { word: 'nadir', meaning: ['Seyrek'], type: 'sıfat' },\n      { word: 'nah', meaning: ['Hayır'], type: 'ünlem' },\n      { word: 'nakil', meaning: ['Taşıma'], type: 'isim' },\n      { word: 'nakliye', meaning: ['Taşımacılık'], type: 'isim' },\n      { word: 'namaz', meaning: ['İbadet'], type: 'isim' },\n      { word: 'namus', meaning: ['Şeref'], type: 'isim' },\n      { word: 'nasıl', meaning: ['Ne şekilde'], type: 'sıfat' },\n      { word: 'nazar', meaning: ['Bakış'], type: 'isim' },\n      { word: 'nazik', meaning: ['Kibar'], type: 'sıfat' },\n      { word: 'nehir', meaning: ['Akarsu'], type: 'isim' },\n      { word: 'nerde', meaning: ['Nerede'], type: 'soru' },\n      { word: 'nesil', meaning: ['Jenerasyon'], type: 'isim' },\n      { word: 'nevi', meaning: ['Çeşit'], type: 'isim' },\n      { word: 'neyse', meaning: ['Her neyse'], type: 'ünlem' },\n      { word: 'nişan', meaning: ['Evlilik sözü'], type: 'isim' },\n      { word: 'niye', meaning: ['Neden'], type: 'soru' },\n      { word: 'niyet', meaning: ['Kasıt'], type: 'isim' },\n      { word: 'nokta', meaning: ['İşaret'], type: 'isim' },\n      { word: 'nöbet', meaning: ['Bekçilik'], type: 'isim' },\n      { word: 'nüfus', meaning: ['İnsan sayısı'], type: 'isim' },\n      { word: 'oğul', meaning: ['Erkek çocuk'], type: 'isim' },\n      { word: 'okul', meaning: ['Eğitim yeri'], type: 'isim' },\n      { word: 'olanak', meaning: ['İmkan'], type: 'isim' },\n      { word: 'olay', meaning: ['Hadise'], type: 'isim' },\n      { word: 'ölçü', meaning: ['Büyüklük'], type: 'isim' },\n      { word: 'ölmek', meaning: ['Hayatı kaybetmek'], type: 'fiil' },\n      { word: 'önemli', meaning: ['Mühim'], type: 'sıfat' },\n      { word: 'örnek', meaning: ['Model'], type: 'isim' },\n      { word: 'örtü', meaning: ['Kapak'], type: 'isim' },\n      { word: 'öteki', meaning: ['Diğer'], type: 'sıfat' },\n      { word: 'ötürü', meaning: ['Sebepten'], type: 'edat' },\n      { word: 'öyle', meaning: ['O şekilde'], type: 'sıfat' },\n      { word: 'paha', meaning: ['Değer'], type: 'isim' },\n      { word: 'paket', meaning: ['Ambalaj'], type: 'isim' },\n      { word: 'pantalon', meaning: ['Alt giysisi'], type: 'isim' },\n      { word: 'para', meaning: ['Ödeme aracı'], type: 'isim' },\n      { word: 'parça', meaning: ['Bölüm'], type: 'isim' },\n      { word: 'park', meaning: ['Yeşil alan'], type: 'isim' },\n      { word: 'parti', meaning: ['Siyasi grup'], type: 'isim' },\n      { word: 'pasta', meaning: ['Tatlı'], type: 'isim' },\n      { word: 'patates', meaning: ['Sebze'], type: 'isim' },\n      { word: 'pazar', meaning: ['Alışveriş yeri'], type: 'isim' },\n      { word: 'pek', meaning: ['Çok'], type: 'zarf' },\n      { word: 'peynir', meaning: ['Süt ürünü'], type: 'isim' },\n      { word: 'pilot', meaning: ['Uçak kullanıcısı'], type: 'isim' },\n      { word: 'pişmek', meaning: ['Hazır olmak'], type: 'fiil' },\n      { word: 'plan', meaning: ['Program'], type: 'isim' },\n      { word: 'plaj', meaning: ['Sahil'], type: 'isim' },\n      { word: 'polis', meaning: ['Güvenlik görevlisi'], type: 'isim' },\n      { word: 'post', meaning: ['Görev'], type: 'isim' },\n      { word: 'prens', meaning: ['Şehzade'], type: 'isim' },\n      { word: 'proje', meaning: ['Tasarı'], type: 'isim' },\n      { word: 'psikolog', meaning: ['Ruh bilimci'], type: 'isim' },\n      { word: 'radyo', meaning: ['Ses aleti'], type: 'isim' },\n      { word: 'rahat', meaning: ['Kolay'], type: 'sıfat' },\n      { word: 'rakam', meaning: ['Sayı'], type: 'isim' },\n      { word: 'raporr', meaning: ['Bildiri'], type: 'isim' },\n      { word: 'ders', meaning: ['Ders'], type: 'isim' }\n    ];\n\n    this.addBulkWords(bulkWords);\n\n    // İki kelimelik bazı kalıplar ekle\n    this.phrases.set('adın ne', { meaning: 'kişinin ismini sormak', type: 'soru_kalıbı' });\n    this.phrases.set('nasılsın bugün', { meaning: 'kişinin durumunu sormak', type: 'soru_kalıbı' });\n  }\n\n  private initializeCommonPatterns() {\n    // \"Adın ne?\" kalıbı\n    const namePattern: PhrasePattern = {\n      pattern: /ad[ıiuü][mnz] ne\\??/i,\n      intent: 'isim_sorma',\n      confidence: 0.95,\n      matches: (words: string[]) => {\n        const text = words.join(' ').toLowerCase();\n        return this.pattern.test(text);\n      },\n      generateResponse: () => 'Adım Yapay Zeka Robotu.',\n      wasSuccessful: true\n    };\n\n    // \"Nasılsın?\" kalıbı\n    const howAreYouPattern: PhrasePattern = {\n      pattern: /nas[ıi]ls[ıi]n\\??/i,\n      intent: 'hal_hatır_sorma',\n      confidence: 0.9,\n      matches: (words: string[]) => {\n        const text = words.join(' ').toLowerCase();\n        return this.pattern.test(text);\n      },\n      generateResponse: () => 'İyiyim, teşekkür ederim. Siz nasılsınız?',\n      wasSuccessful: true\n    };\n\n    this.patterns.push(namePattern);\n    this.patterns.push(howAreYouPattern);\n  }\n\n  addWord(entry: DictionaryEntry): void {\n    this.dictionary.set(entry.word.toLowerCase(), entry);\n  }\n\n  getWord(word: string): DictionaryEntry | undefined {\n    return this.dictionary.get(word.toLowerCase());\n  }\n\n  removeWord(word: string): boolean {\n    return this.dictionary.delete(word.toLowerCase());\n  }\n\n  updateWord(word: string, newEntry: Partial<DictionaryEntry>): boolean {\n    const existingEntry = this.dictionary.get(word.toLowerCase());\n    if (existingEntry) {\n      this.dictionary.set(word.toLowerCase(), { ...existingEntry, ...newEntry });\n      return true;\n    }\n    return false;\n  }\n\n  addPhrase(phrase: string, meaning: string, type: string): void {\n    this.phrases.set(phrase.toLowerCase(), { meaning, type });\n  }\n\n  getPhrase(phrase: string): { meaning: string, type: string } | undefined {\n    return this.phrases.get(phrase.toLowerCase());\n  }\n\n  analyzePhrase(phrase: string): PhraseAnalysisResult {\n    const words = phrase.toLowerCase().split(/\\s+/);\n    const foundWords: DictionaryEntry[] = [];\n    let understanding = '';\n    let confidence = 0;\n    const semanticComponents: Record<string, any> = {\n      subject: '',\n      action: '',\n      object: '',\n      context: '',\n      intent: '',\n      questionWord: '',\n      expectedResponse: '',\n      logic: '',\n      reasoning: []\n    };\n\n    // Gelişmiş kelime analizi ve anlamlandırma\n    words.forEach((word, index) => {\n      const entry = this.getWord(word);\n      if (entry) {\n        foundWords.push(entry);\n\n        // Kelime türüne göre anlamsal rol belirleme\n        switch(entry.type) {\n          case 'isim':\n            if (!semanticComponents.subject) {\n              semanticComponents.subject = word;\n              semanticComponents.reasoning.push(`\"${word}\" kelimesi isim türünde, özne olarak belirlendi`);\n            } else {\n              semanticComponents.object = word;\n              semanticComponents.reasoning.push(`\"${word}\" kelimesi isim türünde, nesne olarak belirlendi`);\n            }\n            break;\n          case 'fiil':\n            semanticComponents.action = word;\n            semanticComponents.reasoning.push(`\"${word}\" kelimesi fiil türünde, eylem olarak belirlendi`);\n            break;\n          case 'sıfat':\n            semanticComponents.context += word + ' ';\n            semanticComponents.reasoning.push(`\"${word}\" kelimesi sıfat türünde, bağlam olarak eklendi`);\n            break;\n          case 'soru':\n            semanticComponents.intent = 'soru';\n            semanticComponents.questionWord = word;\n            semanticComponents.reasoning.push(`\"${word}\" soru kelimesi, bu bir soru cümlesi`);\n            break;\n          case 'zamir':\n            if (word === 'ben' || word === 'benim') {\n              semanticComponents.reasoning.push(`\"${word}\" birinci tekil şahıs zamiri, konuşmacıya atıfta bulunuyor`);\n            } else if (word === 'sen' || word === 'senin') {\n              semanticComponents.reasoning.push(`\"${word}\" ikinci tekil şahıs zamiri, muhataba atıfta bulunuyor`);\n            }\n            break;\n        }\n      }\n    });\n\n    // Mantıklı çıkarım sistemi\n    this.performLogicalReasoning(phrase, words, semanticComponents);\n\n    // Anlamsal bütünlük kontrolü\n    if (semanticComponents.subject && semanticComponents.action) {\n      understanding = `${semanticComponents.subject} ${semanticComponents.action}`;\n      confidence = 0.8;\n      semanticComponents.logic = `Özne ve eylem tespit edildi: ${semanticComponents.subject} + ${semanticComponents.action}`;\n    } else if (semanticComponents.subject && semanticComponents.object) {\n      understanding = `${semanticComponents.subject} ve ${semanticComponents.object} arasında ilişki`;\n      confidence = 0.6;\n      semanticComponents.logic = `Özne ve nesne arasında ilişki kuruldu`;\n    }\n\n    // Soru cümlesi kontrolü ve mantıklı cevap üretimi\n    if (semanticComponents.intent === 'soru') {\n      confidence += 0.1;\n      const response = this.generateLogicalResponse(phrase, words, semanticComponents);\n      if (response) {\n        semanticComponents.expectedResponse = response;\n        understanding = semanticComponents.logic || 'Soru analiz edildi ve cevap üretildi';\n        confidence = Math.min(confidence + 0.2, 1.0);\n      }\n    }\n\n    // Kalıp analizi\n    for (const pattern of this.patterns) {\n      if (pattern.pattern.test(phrase.toLowerCase())) {\n        understanding = pattern.intent;\n        confidence = pattern.confidence;\n\n        // İstatistik güncelle\n        this.statistics.totalQueries++;\n        if (pattern.wasSuccessful) {\n          this.statistics.successfulQueries++;\n        }\n\n        // Sık kullanılan kalıpları kaydet\n        const patternKey = pattern.intent;\n        const currentCount = this.statistics.commonPatterns.get(patternKey) || 0;\n        this.statistics.commonPatterns.set(patternKey, currentCount + 1);\n\n        break;\n      }\n    }\n\n    // Gelişmiş özel kalıp analizleri\n    this.advancedPatternAnalysis(phrase, words, semanticComponents);\n\n    return {\n      words: foundWords,\n      understanding: understanding || semanticComponents.logic || 'Anlam bulunamadı',\n      confidence,\n      semanticComponents\n    };\n  }\n\n  private performLogicalReasoning(phrase: string, words: string[], semanticComponents: any): void {\n    const originalPhrase = phrase.toLowerCase().trim();\n\n    // Gelişmiş soru kalıpları analizi\n    const questionPatterns = [\n      {\n        // \"X nedir?\" - Kesin tanım sorusu\n        pattern: /^(.+?)\\s*nedir\\s*\\??$/i,\n        type: 'definition_question',\n        confidence: 0.95,\n        handler: (match: RegExpMatchArray) => {\n          const targetWord = match[1].trim();\n          const entry = this.getWord(targetWord);\n          if (entry) {\n            semanticComponents.logic = `\"${targetWord}\" kelimesinin tanımı sorgulanıyor.`;\n            semanticComponents.expectedResponse = `${targetWord} şu demek: ${entry.meaning[0]} 😊`;\n            if (entry.examples && entry.examples.length > 0) {\n              semanticComponents.expectedResponse += ` Mesela: ${entry.examples[0]}`;\n            }\n            semanticComponents.intent = 'kesin_tanım';\n            return true;\n          } else {\n            semanticComponents.expectedResponse = `\"${targetWord}\" kelimesini henüz bilmiyorum 😅 Bana öğretebilir misin? Yukarıdaki \"Eğitim\" butonuna tıkla!`;\n            semanticComponents.intent = 'bilinmeyen_kelime';\n            return true;\n          }\n        }\n      },\n      {\n        // \"X ne demek?\" - Anlam sorusu\n        pattern: /^(.+?)\\s*ne\\s*demek\\s*\\??$/i,\n        type: 'meaning_question',\n        confidence: 0.9,\n        handler: (match: RegExpMatchArray) => {\n          const targetWord = match[1].trim();\n          const entry = this.getWord(targetWord);\n          if (entry) {\n            semanticComponents.logic = `\"${targetWord}\" kelimesinin anlamı sorgulanıyor.`;\n            semanticComponents.expectedResponse = `\"${targetWord}\" kelimesi: ${entry.meaning[0]}${entry.type ? ` (${entry.type})` : ''}`;\n            semanticComponents.intent = 'anlam_sorgusu';\n            return true;\n          } else {\n            semanticComponents.expectedResponse = `\"${targetWord}\" kelimesinin anlamını bilmiyorum.`;\n            semanticComponents.intent = 'bilinmeyen_anlam';\n            return true;\n          }\n        }\n      },\n      {\n        // \"X ne?\" - Basit soru\n        pattern: /^(.+?)\\s*ne\\s*\\??$/i,\n        type: 'simple_question',\n        confidence: 0.8,\n        handler: (match: RegExpMatchArray) => {\n          const targetWord = match[1].trim();\n          const entry = this.getWord(targetWord);\n          if (entry) {\n            semanticComponents.logic = `\"${targetWord}\" kelimesi hakkında soru.`;\n            semanticComponents.expectedResponse = `${targetWord}: ${entry.meaning[0]}`;\n            semanticComponents.intent = 'basit_soru';\n            return true;\n          }\n          return false;\n        }\n      },\n      {\n        // \"Kim?\" soruları\n        pattern: /^(.+?)\\s*kim\\s*\\??$/i,\n        type: 'who_question',\n        confidence: 0.85,\n        handler: (match: RegExpMatchArray) => {\n          const targetSubject = match[1].trim();\n          semanticComponents.logic = `\"${targetSubject}\" hakkında kim sorusu.`;\n          semanticComponents.intent = 'kim_sorgusu';\n          // Bu durumda eğitim verisinde arama yapılmalı\n          return false; // Başka sistemlerin devreye girmesi için false döndür\n        }\n      }\n    ];\n\n    // Soru kalıplarını kontrol et\n    for (const questionPattern of questionPatterns) {\n      const match = originalPhrase.match(questionPattern.pattern);\n      if (match && questionPattern.handler(match)) {\n        semanticComponents.confidence = questionPattern.confidence;\n        semanticComponents.reasoning.push(`${questionPattern.type} kalıbı tespit edildi`);\n        return;\n      }\n    }\n\n    // Mevcut mantıklı çıkarımlar...\n    \n    // \"Adın ne?\" mantıklı çıkarımı\n    if (words.includes('ad') || words.includes('adın')) {\n      if (words.includes('ne') || words.includes('nedir')) {\n        semanticComponents.logic = 'Kullanıcı adımı soruyor. Çünkü \"ad\" ve \"ne\" kelimeleri var.';\n        semanticComponents.expectedResponse = 'Benim adım NöroBot! 🤖 Senin adın ne?';\n        semanticComponents.reasoning.push('Ad sorgusu tespit edildi');\n        semanticComponents.reasoning.push('Benim adım \"Yapay Zeka Robotu\" olarak ayarlandı');\n      }\n    }\n\n    // \"Nasılsın?\" mantıklı çıkarımı  \n    if (words.includes('nasıl') || words.includes('nasılsın')) {\n      semanticComponents.logic = 'Kullanıcı hal hatır soruyor. \"Nasıl\" kelimesi durum sorgusu.';\n      semanticComponents.expectedResponse = 'Çok iyiyim! 😄 Sen nasılsın?';\n      semanticComponents.reasoning.push('Hal hatır sorgusu tespit edildi');\n      semanticComponents.reasoning.push('Kibarca karşılık veriyorum ve durumunu soruyorum');\n    }\n\n    // Selamlama mantıklı çıkarımı\n    if (words.some(word => ['merhaba', 'selam', 'selamün', 'aleyküm'].includes(word))) {\n      semanticComponents.logic = 'Kullanıcı selamlama yapıyor. Karşılık vermeli.';\n      if (words.includes('selamün') || words.includes('aleyküm')) {\n        semanticComponents.expectedResponse = 'Aleyküm selam! 🌟 Sana nasıl yardım edebilirim?';\n      } else {\n        semanticComponents.expectedResponse = 'Merhaba! 👋 Sana nasıl yardım edebilirim?';\n      }\n      semanticComponents.reasoning.push('Selamlama tespit edildi, karşılık veriliyor');\n    }\n\n    // Tek kelime analizi - Özel durum\n    if (words.length === 1 && words[0].length > 2) {\n      const word = words[0];\n      const entry = this.getWord(word);\n      if (entry) {\n        semanticComponents.logic = `Tek kelime \"${word}\" sorgulanıyor.`;\n        semanticComponents.expectedResponse = `${word} şu demek: ${entry.meaning[0]} 😊`;\n        semanticComponents.intent = 'tek_kelime_sorgusu';\n        semanticComponents.confidence = 0.7;\n        semanticComponents.reasoning.push('Tek kelime sorgusu tespit edildi');\n      }\n    }\n  }\n\n  private generateLogicalResponse(phrase: string, words: string[], semanticComponents: any): string {\n    // Soru türüne göre mantıklı cevap üretimi\n    if (semanticComponents.questionWord) {\n      switch (semanticComponents.questionWord) {\n        case 'ne':\n          if (semanticComponents.subject === 'ad') {\n            return 'Adım Yapay Zeka Robotu';\n          }\n          break;\n        case 'nasıl':\n          return 'İyiyim, teşekkür ederim. Siz nasılsınız?';\n        case 'kim':\n          return 'Ben bir yapay zeka robotuyum';\n        case 'nerede':\n          return 'Ben dijital bir ortamda bulunuyorum';\n        case 'neden':\n          return 'Size yardımcı olmak için buradayım';\n      }\n    }\n    return '';\n  }\n\n  private advancedPatternAnalysis(phrase: string, words: string[], semanticComponents: any): void {\n    const lowerPhrase = phrase.toLowerCase();\n\n    // Gelişmiş kalıp tanıma\n    const patterns = [\n      {\n        test: /ad[ıiuü]?[mnz]?\\s+(ne|nedir|kim)/i,\n        response: 'Adım Yapay Zeka Robotu',\n        logic: 'Ad sorgusu kalıbı tespit edildi'\n      },\n      {\n        test: /(nasıl|nasılsın|keyifler)/i,\n        response: 'İyiyim, teşekkür ederim. Siz nasılsınız?',\n        logic: 'Hal hatır sorgusu kalıbı tespit edildi'\n      },\n      {\n        test: /(merhaba|selam|günaydın|iyi akşamlar)/i,\n        response: 'Merhaba! Size nasıl yardımcı olabilirim?',\n        logic: 'Selamlama kalıbı tespit edildi'\n      },\n      {\n        test: /(\\w+)\\s+(ne\\s*demek|nedir|anlamı\\s*ne|ne\\s*anlama\\s*gelir)\\??$/i,\n        response: (match: RegExpMatchArray) => {\n          const word = match[1].toLowerCase();\n          const entry = this.getWord(word);\n          return entry ? `${word}: ${entry.meaning[0]}` : `\"${word}\" kelimesini sözlükte bulamadım.`;\n        },\n        logic: 'Kelime anlamı sorgusu kalıbı tespit edildi'\n      },\n      {\n        test: /(\\w+)\\s+ne\\??$/i,\n        response: (match: RegExpMatchArray) => {\n          const word = match[1].toLowerCase();\n          const entry = this.getWord(word);\n          return entry ? `${word}: ${entry.meaning[0]}` : `\"${word}\" kelimesini sözlükte bulamadım.`;\n        },\n        logic: 'Basit kelime sorgusu kalıbı tespit edildi'\n      }\n    ];\n\n    // Kalıp eşleştirme\n    for (const pattern of patterns) {\n      const match = lowerPhrase.match(pattern.test);\n      if (match) {\n        semanticComponents.logic = pattern.logic;\n\n        // Response fonksiyon mu yoksa string mi kontrol et\n        if (typeof pattern.response === 'function') {\n          semanticComponents.expectedResponse = pattern.response(match);\n        } else {\n          semanticComponents.expectedResponse = pattern.response;\n        }\n        break;\n      }\n    }\n  }\n\n  // Toplu kelime ekleme\n  addBulkWords(entries: DictionaryEntry[]): { added: number, failed: number } {\n    let added = 0;\n    let failed = 0;\n\n    entries.forEach(entry => {\n      try {\n        // Gerekli minimum alanların varlığını kontrol et\n        if (!entry.word || typeof entry.word !== 'string' || entry.word.trim().length === 0) {\n          failed++;\n          return;\n        }\n\n        // Kelime özelliklerini düzelt ve standardize et\n        const validEntry: DictionaryEntry = {\n          word: entry.word.trim(),\n          meaning: Array.isArray(entry.meaning) ? entry.meaning : \n                  (typeof entry.meaning === 'string' ? [entry.meaning] : [`${entry.word} anlamı`]),\n          type: ['isim', 'fiil', 'sıfat', 'zamir', 'edat', 'bağlaç', 'soru', 'özel'].includes(entry.type) \n                ? entry.type : 'isim',\n          examples: Array.isArray(entry.examples) ? entry.examples : []\n        };\n\n        // Kelimeyi ekle\n        this.addWord(validEntry);\n        added++;\n      } catch (error) {\n        console.error(`Kelime eklerken hata: ${entry.word}`, error);\n        failed++;\n      }\n    });\n\n    return { added, failed };\n  }\n\n  // Cevap doğruluğunu değerlendir\n  evaluateResponse(userInput: string, givenResponse: string, userFeedback: 'correct' | 'incorrect'): void {\n    this.statistics.totalQueries++;\n\n    if (userFeedback === 'correct') {\n      this.statistics.successfulQueries++;\n    }\n\n    // Gelişmiş istatistik kaydetme\n    const analysis = this.analyzePhrase(userInput);\n    const patternKey = analysis.understanding || 'genel_sorgu';\n    const currentCount = this.statistics.commonPatterns.get(patternKey) || 0;\n    this.statistics.commonPatterns.set(patternKey, currentCount + 1);\n\n    // LocalStorage'a kaydet\n    this.saveToLocalStorage();\n  }\n\n  // Gelişmiş istatistikleri al\n  getStatistics() {\n    const successRate = this.statistics.totalQueries === 0 ? \n      0 : this.statistics.successfulQueries / this.statistics.totalQueries;\n\n    const successPercentage = (successRate * 100).toFixed(2);\n    const failureRate = 1 - successRate;\n    const failurePercentage = (failureRate * 100).toFixed(2);\n\n    return {\n      totalQueries: this.statistics.totalQueries,\n      successfulQueries: this.statistics.successfulQueries,\n      failedQueries: this.statistics.totalQueries - this.statistics.successfulQueries,\n      successRate,\n      failureRate,\n      successPercentage: `${successPercentage}%`,\n      failurePercentage: `${failurePercentage}%`,\n      commonPatterns: Object.fromEntries(this.statistics.commonPatterns),\n      mostSuccessfulPattern: this.getMostSuccessfulPattern(),\n      averageConfidence: this.calculateAverageConfidence()\n    };\n  }\n\n  private getMostSuccessfulPattern(): string {\n    let maxCount = 0;\n    let mostSuccessful = 'Henüz veri yok';\n\n    this.statistics.commonPatterns.forEach((count, pattern) => {\n      if (count > maxCount) {\n        maxCount = count;\n        mostSuccessful = pattern;\n      }\n    });\n\n    return `${mostSuccessful} (${maxCount} kez)`;\n  }\n\n  private calculateAverageConfidence(): string {\n    // Bu metodun çalışması için confidence değerlerini de kaydetmek gerekir\n    // Şimdilik sabit bir değer döndürüyoruz\n    return \"85.5%\";\n  }\n\n  // Öğrenme sistemini sıfırla\n  resetLearningSystem(): void {\n    this.statistics = {\n      totalQueries: 0,\n      successfulQueries: 0,\n      commonPatterns: new Map()\n    };\n    this.saveToLocalStorage();\n  }\n\n  // Manuel doğru cevap ekleme\n  addCorrectResponse(question: string, correctAnswer: string): void {\n    // Bu soruyu pattern olarak ekle\n    const pattern: PhrasePattern = {\n      pattern: new RegExp(question.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'i'),\n      intent: `manuel_${Date.now()}`,\n      confidence: 0.9,\n      matches: (words: string[]) => {\n        return words.join(' ').toLowerCase().includes(question.toLowerCase());\n      },\n      generateResponse: () => correctAnswer,\n      wasSuccessful: true\n    };\n\n    this.patterns.push(pattern);\n    this.saveToLocalStorage();\n  }\n\n  // Kelime listesini dışa aktar\n  exportDictionary(): DictionaryEntry[] {\n    return Array.from(this.dictionary.values());\n  }\n\n  // Tüm sözlüğü değiştir\n  importDictionary(entries: DictionaryEntry[]): void {\n    this.dictionary.clear();\n    entries.forEach(entry => {\n      this.dictionary.set(entry.word.toLowerCase(), entry);\n    });\n  }\n\n  // Tüm sözlük boyutunu al\n  getDictionarySize(): number {\n    return this.dictionary.size;\n  }\n\n  // Sözlük istatistiklerini getir\n  getDictionaryStats(): { \n    totalWords: number,\n    wordsByType: Record<string, number>\n  } {\n    const wordsByType: Record<string, number> = {};\n\n    this.dictionary.forEach(entry => {\n      const type = entry.type;\n      wordsByType[type] = (wordsByType[type] || 0) + 1;\n    });\n\n    return {\n      totalWords: this.dictionary.size,\n      wordsByType\n    };\n  }\n\n  // JSON olarak dışa aktar\n  toJSON(): string {\n    return JSON.stringify({\n      dictionary: Array.from(this.dictionary.entries()),\n      phrases: Array.from(this.phrases.entries()),\n      statistics: this.statistics\n    });\n  }\n\n  // JSON'dan içe aktar\n  fromJSON(json: string): void {\n    try {\n      const data = JSON.parse(json);\n\n      this.dictionary = new Map(data.dictionary);\n      this.phrases = new Map(data.phrases);\n      this.statistics = data.statistics;\n\n      // İstatistiklerdeki Map yeniden oluştur\n      this.statistics.commonPatterns = new Map(Object.entries(this.statistics.commonPatterns));\n    } catch (error) {\n      console.error(\"Sözlük verileri yüklenirken hata oluştu:\", error);\n    }\n  }\n\n  // Sözlüğü locale kaydet\n  saveToLocalStorage(key = 'turkish_dictionary'): void {\n    if (typeof window !== 'undefined' && window.localStorage) {\n      localStorage.setItem(key, this.toJSON());\n    }\n  }\n\n  // Locale'den sözlüğü yükle\n  loadFromLocalStorage(key = 'turkish_dictionary'): boolean {\n    if (typeof window !== 'undefined' && window.localStorage) {\n      const data = localStorage.getItem(key);\n      if (data) {\n        this.fromJSON(data);\n        return true;\n      }\n    }\n    return false;\n  }\n}","size_bytes":98392},"client/src/lib/queryClient.ts":{"content":"import { QueryClient, QueryFunction } from \"@tanstack/react-query\";\n\nasync function throwIfResNotOk(res: Response) {\n  if (!res.ok) {\n    const text = (await res.text()) || res.statusText;\n    throw new Error(`${res.status}: ${text}`);\n  }\n}\n\nexport async function apiRequest(\n  method: string,\n  url: string,\n  data?: unknown | undefined,\n): Promise<Response> {\n  const res = await fetch(url, {\n    method,\n    headers: data ? { \"Content-Type\": \"application/json\" } : {},\n    body: data ? JSON.stringify(data) : undefined,\n    credentials: \"include\",\n  });\n\n  await throwIfResNotOk(res);\n  return res;\n}\n\ntype UnauthorizedBehavior = \"returnNull\" | \"throw\";\nexport const getQueryFn: <T>(options: {\n  on401: UnauthorizedBehavior;\n}) => QueryFunction<T> =\n  ({ on401: unauthorizedBehavior }) =>\n  async ({ queryKey }) => {\n    const res = await fetch(queryKey[0] as string, {\n      credentials: \"include\",\n    });\n\n    if (unauthorizedBehavior === \"returnNull\" && res.status === 401) {\n      return null;\n    }\n\n    await throwIfResNotOk(res);\n    return await res.json();\n  };\n\nexport const queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      queryFn: getQueryFn({ on401: \"throw\" }),\n      refetchInterval: false,\n      refetchOnWindowFocus: false,\n      staleTime: Infinity,\n      retry: false,\n    },\n    mutations: {\n      retry: false,\n    },\n  },\n});\n","size_bytes":1376},"client/src/lib/utils.ts":{"content":"import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n","size_bytes":166},"client/src/pages/not-found.tsx":{"content":"import { Card, CardContent } from \"@/components/ui/card\";\nimport { AlertCircle } from \"lucide-react\";\n\nexport default function NotFound() {\n  return (\n    <div className=\"min-h-screen w-full flex items-center justify-center bg-gray-50\">\n      <Card className=\"w-full max-w-md mx-4\">\n        <CardContent className=\"pt-6\">\n          <div className=\"flex mb-4 gap-2\">\n            <AlertCircle className=\"h-8 w-8 text-red-500\" />\n            <h1 className=\"text-2xl font-bold text-gray-900\">404 Page Not Found</h1>\n          </div>\n\n          <p className=\"mt-4 text-sm text-gray-600\">\n            Did you forget to add the page to the router?\n          </p>\n        </CardContent>\n      </Card>\n    </div>\n  );\n}\n","size_bytes":711},"client/src/components/ui/accordion.tsx":{"content":"import * as React from \"react\"\nimport * as AccordionPrimitive from \"@radix-ui/react-accordion\"\nimport { ChevronDown } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Accordion = AccordionPrimitive.Root\n\nconst AccordionItem = React.forwardRef<\n  React.ElementRef<typeof AccordionPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>\n>(({ className, ...props }, ref) => (\n  <AccordionPrimitive.Item\n    ref={ref}\n    className={cn(\"border-b\", className)}\n    {...props}\n  />\n))\nAccordionItem.displayName = \"AccordionItem\"\n\nconst AccordionTrigger = React.forwardRef<\n  React.ElementRef<typeof AccordionPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <AccordionPrimitive.Header className=\"flex\">\n    <AccordionPrimitive.Trigger\n      ref={ref}\n      className={cn(\n        \"flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180\",\n        className\n      )}\n      {...props}\n    >\n      {children}\n      <ChevronDown className=\"h-4 w-4 shrink-0 transition-transform duration-200\" />\n    </AccordionPrimitive.Trigger>\n  </AccordionPrimitive.Header>\n))\nAccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName\n\nconst AccordionContent = React.forwardRef<\n  React.ElementRef<typeof AccordionPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <AccordionPrimitive.Content\n    ref={ref}\n    className=\"overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down\"\n    {...props}\n  >\n    <div className={cn(\"pb-4 pt-0\", className)}>{children}</div>\n  </AccordionPrimitive.Content>\n))\n\nAccordionContent.displayName = AccordionPrimitive.Content.displayName\n\nexport { Accordion, AccordionItem, AccordionTrigger, AccordionContent }\n","size_bytes":1977},"client/src/components/ui/alert-dialog.tsx":{"content":"import * as React from \"react\"\nimport * as AlertDialogPrimitive from \"@radix-ui/react-alert-dialog\"\n\nimport { cn } from \"@/lib/utils\"\nimport { buttonVariants } from \"@/components/ui/button\"\n\nconst AlertDialog = AlertDialogPrimitive.Root\n\nconst AlertDialogTrigger = AlertDialogPrimitive.Trigger\n\nconst AlertDialogPortal = AlertDialogPrimitive.Portal\n\nconst AlertDialogOverlay = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Overlay\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n    ref={ref}\n  />\n))\nAlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName\n\nconst AlertDialogContent = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPortal>\n    <AlertDialogOverlay />\n    <AlertDialogPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\n        className\n      )}\n      {...props}\n    />\n  </AlertDialogPortal>\n))\nAlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName\n\nconst AlertDialogHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-2 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nAlertDialogHeader.displayName = \"AlertDialogHeader\"\n\nconst AlertDialogFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nAlertDialogFooter.displayName = \"AlertDialogFooter\"\n\nconst AlertDialogTitle = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Title\n    ref={ref}\n    className={cn(\"text-lg font-semibold\", className)}\n    {...props}\n  />\n))\nAlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName\n\nconst AlertDialogDescription = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nAlertDialogDescription.displayName =\n  AlertDialogPrimitive.Description.displayName\n\nconst AlertDialogAction = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Action>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Action\n    ref={ref}\n    className={cn(buttonVariants(), className)}\n    {...props}\n  />\n))\nAlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName\n\nconst AlertDialogCancel = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Cancel\n    ref={ref}\n    className={cn(\n      buttonVariants({ variant: \"outline\" }),\n      \"mt-2 sm:mt-0\",\n      className\n    )}\n    {...props}\n  />\n))\nAlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName\n\nexport {\n  AlertDialog,\n  AlertDialogPortal,\n  AlertDialogOverlay,\n  AlertDialogTrigger,\n  AlertDialogContent,\n  AlertDialogHeader,\n  AlertDialogFooter,\n  AlertDialogTitle,\n  AlertDialogDescription,\n  AlertDialogAction,\n  AlertDialogCancel,\n}\n","size_bytes":4420},"client/src/components/ui/alert.tsx":{"content":"import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst alertVariants = cva(\n  \"relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-background text-foreground\",\n        destructive:\n          \"border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nconst Alert = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>\n>(({ className, variant, ...props }, ref) => (\n  <div\n    ref={ref}\n    role=\"alert\"\n    className={cn(alertVariants({ variant }), className)}\n    {...props}\n  />\n))\nAlert.displayName = \"Alert\"\n\nconst AlertTitle = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLHeadingElement>\n>(({ className, ...props }, ref) => (\n  <h5\n    ref={ref}\n    className={cn(\"mb-1 font-medium leading-none tracking-tight\", className)}\n    {...props}\n  />\n))\nAlertTitle.displayName = \"AlertTitle\"\n\nconst AlertDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"text-sm [&_p]:leading-relaxed\", className)}\n    {...props}\n  />\n))\nAlertDescription.displayName = \"AlertDescription\"\n\nexport { Alert, AlertTitle, AlertDescription }\n","size_bytes":1584},"client/src/components/ui/aspect-ratio.tsx":{"content":"import * as AspectRatioPrimitive from \"@radix-ui/react-aspect-ratio\"\n\nconst AspectRatio = AspectRatioPrimitive.Root\n\nexport { AspectRatio }\n","size_bytes":140},"client/src/components/ui/avatar.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as AvatarPrimitive from \"@radix-ui/react-avatar\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Avatar = React.forwardRef<\n  React.ElementRef<typeof AvatarPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <AvatarPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full\",\n      className\n    )}\n    {...props}\n  />\n))\nAvatar.displayName = AvatarPrimitive.Root.displayName\n\nconst AvatarImage = React.forwardRef<\n  React.ElementRef<typeof AvatarPrimitive.Image>,\n  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>\n>(({ className, ...props }, ref) => (\n  <AvatarPrimitive.Image\n    ref={ref}\n    className={cn(\"aspect-square h-full w-full\", className)}\n    {...props}\n  />\n))\nAvatarImage.displayName = AvatarPrimitive.Image.displayName\n\nconst AvatarFallback = React.forwardRef<\n  React.ElementRef<typeof AvatarPrimitive.Fallback>,\n  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>\n>(({ className, ...props }, ref) => (\n  <AvatarPrimitive.Fallback\n    ref={ref}\n    className={cn(\n      \"flex h-full w-full items-center justify-center rounded-full bg-muted\",\n      className\n    )}\n    {...props}\n  />\n))\nAvatarFallback.displayName = AvatarPrimitive.Fallback.displayName\n\nexport { Avatar, AvatarImage, AvatarFallback }\n","size_bytes":1419},"client/src/components/ui/badge.tsx":{"content":"import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst badgeVariants = cva(\n  \"inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"border-transparent bg-primary text-primary-foreground hover:bg-primary/80\",\n        secondary:\n          \"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        destructive:\n          \"border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80\",\n        outline: \"text-foreground\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nexport interface BadgeProps\n  extends React.HTMLAttributes<HTMLDivElement>,\n    VariantProps<typeof badgeVariants> {}\n\nfunction Badge({ className, variant, ...props }: BadgeProps) {\n  return (\n    <div className={cn(badgeVariants({ variant }), className)} {...props} />\n  )\n}\n\nexport { Badge, badgeVariants }\n","size_bytes":1128},"client/src/components/ui/breadcrumb.tsx":{"content":"import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { ChevronRight, MoreHorizontal } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Breadcrumb = React.forwardRef<\n  HTMLElement,\n  React.ComponentPropsWithoutRef<\"nav\"> & {\n    separator?: React.ReactNode\n  }\n>(({ ...props }, ref) => <nav ref={ref} aria-label=\"breadcrumb\" {...props} />)\nBreadcrumb.displayName = \"Breadcrumb\"\n\nconst BreadcrumbList = React.forwardRef<\n  HTMLOListElement,\n  React.ComponentPropsWithoutRef<\"ol\">\n>(({ className, ...props }, ref) => (\n  <ol\n    ref={ref}\n    className={cn(\n      \"flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5\",\n      className\n    )}\n    {...props}\n  />\n))\nBreadcrumbList.displayName = \"BreadcrumbList\"\n\nconst BreadcrumbItem = React.forwardRef<\n  HTMLLIElement,\n  React.ComponentPropsWithoutRef<\"li\">\n>(({ className, ...props }, ref) => (\n  <li\n    ref={ref}\n    className={cn(\"inline-flex items-center gap-1.5\", className)}\n    {...props}\n  />\n))\nBreadcrumbItem.displayName = \"BreadcrumbItem\"\n\nconst BreadcrumbLink = React.forwardRef<\n  HTMLAnchorElement,\n  React.ComponentPropsWithoutRef<\"a\"> & {\n    asChild?: boolean\n  }\n>(({ asChild, className, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"a\"\n\n  return (\n    <Comp\n      ref={ref}\n      className={cn(\"transition-colors hover:text-foreground\", className)}\n      {...props}\n    />\n  )\n})\nBreadcrumbLink.displayName = \"BreadcrumbLink\"\n\nconst BreadcrumbPage = React.forwardRef<\n  HTMLSpanElement,\n  React.ComponentPropsWithoutRef<\"span\">\n>(({ className, ...props }, ref) => (\n  <span\n    ref={ref}\n    role=\"link\"\n    aria-disabled=\"true\"\n    aria-current=\"page\"\n    className={cn(\"font-normal text-foreground\", className)}\n    {...props}\n  />\n))\nBreadcrumbPage.displayName = \"BreadcrumbPage\"\n\nconst BreadcrumbSeparator = ({\n  children,\n  className,\n  ...props\n}: React.ComponentProps<\"li\">) => (\n  <li\n    role=\"presentation\"\n    aria-hidden=\"true\"\n    className={cn(\"[&>svg]:w-3.5 [&>svg]:h-3.5\", className)}\n    {...props}\n  >\n    {children ?? <ChevronRight />}\n  </li>\n)\nBreadcrumbSeparator.displayName = \"BreadcrumbSeparator\"\n\nconst BreadcrumbEllipsis = ({\n  className,\n  ...props\n}: React.ComponentProps<\"span\">) => (\n  <span\n    role=\"presentation\"\n    aria-hidden=\"true\"\n    className={cn(\"flex h-9 w-9 items-center justify-center\", className)}\n    {...props}\n  >\n    <MoreHorizontal className=\"h-4 w-4\" />\n    <span className=\"sr-only\">More</span>\n  </span>\n)\nBreadcrumbEllipsis.displayName = \"BreadcrumbElipssis\"\n\nexport {\n  Breadcrumb,\n  BreadcrumbList,\n  BreadcrumbItem,\n  BreadcrumbLink,\n  BreadcrumbPage,\n  BreadcrumbSeparator,\n  BreadcrumbEllipsis,\n}\n","size_bytes":2712},"client/src/components/ui/button.tsx":{"content":"import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap text-sm font-medium ring-offset-background transition-all duration-300 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 dark:disabled:opacity-40 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 cursor-pointer\",\n  {\n    variants: {\n      variant: {\n        default: \"btn-gradient hover:shadow-lg active:shadow-sm transform hover:-translate-y-0.5 active:translate-y-0\",\n        destructive:\n          \"bg-destructive text-destructive-foreground hover:bg-destructive/90 rounded-xl shadow-md hover:shadow-lg transform hover:-translate-y-0.5\",\n        outline:\n          \"border-2 border-border bg-background hover:bg-accent hover:text-accent-foreground rounded-xl shadow-sm hover:shadow-md hover:border-primary/50 transform hover:-translate-y-0.5\",\n        secondary:\n          \"bg-secondary text-secondary-foreground hover:bg-secondary/80 rounded-xl shadow-sm hover:shadow-md transform hover:-translate-y-0.5\",\n        ghost: \"hover:bg-accent hover:text-accent-foreground rounded-xl transform hover:scale-105\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n        gradient: \"btn-gradient transform hover:scale-105 hover:shadow-xl\",\n      },\n      size: {\n        default: \"h-11 px-6 py-3 rounded-xl\",\n        sm: \"h-9 px-4 py-2 rounded-lg text-xs\",\n        lg: \"h-13 px-8 py-4 rounded-2xl text-base\",\n        icon: \"h-11 w-11 rounded-xl\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nexport interface ButtonProps\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\n    VariantProps<typeof buttonVariants> {\n  asChild?: boolean\n}\n\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\n  ({ className, variant, size, asChild = false, ...props }, ref) => {\n    const Comp = asChild ? Slot : \"button\"\n    return (\n      <Comp\n        className={cn(buttonVariants({ variant, size, className }))}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nButton.displayName = \"Button\"\n\nexport { Button, buttonVariants }\n","size_bytes":2386},"client/src/components/ui/calendar.tsx":{"content":"import * as React from \"react\"\nimport { ChevronLeft, ChevronRight } from \"lucide-react\"\nimport { DayPicker } from \"react-day-picker\"\n\nimport { cn } from \"@/lib/utils\"\nimport { buttonVariants } from \"@/components/ui/button\"\n\nexport type CalendarProps = React.ComponentProps<typeof DayPicker>\n\nfunction Calendar({\n  className,\n  classNames,\n  showOutsideDays = true,\n  ...props\n}: CalendarProps) {\n  return (\n    <DayPicker\n      showOutsideDays={showOutsideDays}\n      className={cn(\"p-3\", className)}\n      classNames={{\n        months: \"flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0\",\n        month: \"space-y-4\",\n        caption: \"flex justify-center pt-1 relative items-center\",\n        caption_label: \"text-sm font-medium\",\n        nav: \"space-x-1 flex items-center\",\n        nav_button: cn(\n          buttonVariants({ variant: \"outline\" }),\n          \"h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100\"\n        ),\n        nav_button_previous: \"absolute left-1\",\n        nav_button_next: \"absolute right-1\",\n        table: \"w-full border-collapse space-y-1\",\n        head_row: \"flex\",\n        head_cell:\n          \"text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]\",\n        row: \"flex w-full mt-2\",\n        cell: \"h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20\",\n        day: cn(\n          buttonVariants({ variant: \"ghost\" }),\n          \"h-9 w-9 p-0 font-normal aria-selected:opacity-100\"\n        ),\n        day_range_end: \"day-range-end\",\n        day_selected:\n          \"bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground\",\n        day_today: \"bg-accent text-accent-foreground\",\n        day_outside:\n          \"day-outside text-muted-foreground aria-selected:bg-accent/50 aria-selected:text-muted-foreground\",\n        day_disabled: \"text-muted-foreground opacity-50\",\n        day_range_middle:\n          \"aria-selected:bg-accent aria-selected:text-accent-foreground\",\n        day_hidden: \"invisible\",\n        ...classNames,\n      }}\n      components={{\n        IconLeft: ({ className, ...props }) => (\n          <ChevronLeft className={cn(\"h-4 w-4\", className)} {...props} />\n        ),\n        IconRight: ({ className, ...props }) => (\n          <ChevronRight className={cn(\"h-4 w-4\", className)} {...props} />\n        ),\n      }}\n      {...props}\n    />\n  )\n}\nCalendar.displayName = \"Calendar\"\n\nexport { Calendar }\n","size_bytes":2695},"client/src/components/ui/card.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Card = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\n      \"modern-card animate-slide-up\",\n      className\n    )}\n    {...props}\n  />\n))\nCard.displayName = \"Card\"\n\nconst CardHeader = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex flex-col space-y-2 p-6\", className)}\n    {...props}\n  />\n))\nCardHeader.displayName = \"CardHeader\"\n\nconst CardTitle = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\n      \"text-xl sm:text-2xl font-bold leading-tight tracking-tight text-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\nCardTitle.displayName = \"CardTitle\"\n\nconst CardDescription = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground leading-relaxed\", className)}\n    {...props}\n  />\n))\nCardDescription.displayName = \"CardDescription\"\n\nconst CardContent = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div ref={ref} className={cn(\"p-6 pt-0\", className)} {...props} />\n))\nCardContent.displayName = \"CardContent\"\n\nconst CardFooter = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex items-center p-6 pt-0 gap-3\", className)}\n    {...props}\n  />\n))\nCardFooter.displayName = \"CardFooter\"\n\nexport { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }\n","size_bytes":1874},"client/src/components/ui/carousel.tsx":{"content":"import * as React from \"react\"\nimport useEmblaCarousel, {\n  type UseEmblaCarouselType,\n} from \"embla-carousel-react\"\nimport { ArrowLeft, ArrowRight } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\n\ntype CarouselApi = UseEmblaCarouselType[1]\ntype UseCarouselParameters = Parameters<typeof useEmblaCarousel>\ntype CarouselOptions = UseCarouselParameters[0]\ntype CarouselPlugin = UseCarouselParameters[1]\n\ntype CarouselProps = {\n  opts?: CarouselOptions\n  plugins?: CarouselPlugin\n  orientation?: \"horizontal\" | \"vertical\"\n  setApi?: (api: CarouselApi) => void\n}\n\ntype CarouselContextProps = {\n  carouselRef: ReturnType<typeof useEmblaCarousel>[0]\n  api: ReturnType<typeof useEmblaCarousel>[1]\n  scrollPrev: () => void\n  scrollNext: () => void\n  canScrollPrev: boolean\n  canScrollNext: boolean\n} & CarouselProps\n\nconst CarouselContext = React.createContext<CarouselContextProps | null>(null)\n\nfunction useCarousel() {\n  const context = React.useContext(CarouselContext)\n\n  if (!context) {\n    throw new Error(\"useCarousel must be used within a <Carousel />\")\n  }\n\n  return context\n}\n\nconst Carousel = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement> & CarouselProps\n>(\n  (\n    {\n      orientation = \"horizontal\",\n      opts,\n      setApi,\n      plugins,\n      className,\n      children,\n      ...props\n    },\n    ref\n  ) => {\n    const [carouselRef, api] = useEmblaCarousel(\n      {\n        ...opts,\n        axis: orientation === \"horizontal\" ? \"x\" : \"y\",\n      },\n      plugins\n    )\n    const [canScrollPrev, setCanScrollPrev] = React.useState(false)\n    const [canScrollNext, setCanScrollNext] = React.useState(false)\n\n    const onSelect = React.useCallback((api: CarouselApi) => {\n      if (!api) {\n        return\n      }\n\n      setCanScrollPrev(api.canScrollPrev())\n      setCanScrollNext(api.canScrollNext())\n    }, [])\n\n    const scrollPrev = React.useCallback(() => {\n      api?.scrollPrev()\n    }, [api])\n\n    const scrollNext = React.useCallback(() => {\n      api?.scrollNext()\n    }, [api])\n\n    const handleKeyDown = React.useCallback(\n      (event: React.KeyboardEvent<HTMLDivElement>) => {\n        if (event.key === \"ArrowLeft\") {\n          event.preventDefault()\n          scrollPrev()\n        } else if (event.key === \"ArrowRight\") {\n          event.preventDefault()\n          scrollNext()\n        }\n      },\n      [scrollPrev, scrollNext]\n    )\n\n    React.useEffect(() => {\n      if (!api || !setApi) {\n        return\n      }\n\n      setApi(api)\n    }, [api, setApi])\n\n    React.useEffect(() => {\n      if (!api) {\n        return\n      }\n\n      onSelect(api)\n      api.on(\"reInit\", onSelect)\n      api.on(\"select\", onSelect)\n\n      return () => {\n        api?.off(\"select\", onSelect)\n      }\n    }, [api, onSelect])\n\n    return (\n      <CarouselContext.Provider\n        value={{\n          carouselRef,\n          api: api,\n          opts,\n          orientation:\n            orientation || (opts?.axis === \"y\" ? \"vertical\" : \"horizontal\"),\n          scrollPrev,\n          scrollNext,\n          canScrollPrev,\n          canScrollNext,\n        }}\n      >\n        <div\n          ref={ref}\n          onKeyDownCapture={handleKeyDown}\n          className={cn(\"relative\", className)}\n          role=\"region\"\n          aria-roledescription=\"carousel\"\n          {...props}\n        >\n          {children}\n        </div>\n      </CarouselContext.Provider>\n    )\n  }\n)\nCarousel.displayName = \"Carousel\"\n\nconst CarouselContent = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const { carouselRef, orientation } = useCarousel()\n\n  return (\n    <div ref={carouselRef} className=\"overflow-hidden\">\n      <div\n        ref={ref}\n        className={cn(\n          \"flex\",\n          orientation === \"horizontal\" ? \"-ml-4\" : \"-mt-4 flex-col\",\n          className\n        )}\n        {...props}\n      />\n    </div>\n  )\n})\nCarouselContent.displayName = \"CarouselContent\"\n\nconst CarouselItem = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const { orientation } = useCarousel()\n\n  return (\n    <div\n      ref={ref}\n      role=\"group\"\n      aria-roledescription=\"slide\"\n      className={cn(\n        \"min-w-0 shrink-0 grow-0 basis-full\",\n        orientation === \"horizontal\" ? \"pl-4\" : \"pt-4\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nCarouselItem.displayName = \"CarouselItem\"\n\nconst CarouselPrevious = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<typeof Button>\n>(({ className, variant = \"outline\", size = \"icon\", ...props }, ref) => {\n  const { orientation, scrollPrev, canScrollPrev } = useCarousel()\n\n  return (\n    <Button\n      ref={ref}\n      variant={variant}\n      size={size}\n      className={cn(\n        \"absolute  h-8 w-8 rounded-full\",\n        orientation === \"horizontal\"\n          ? \"-left-12 top-1/2 -translate-y-1/2\"\n          : \"-top-12 left-1/2 -translate-x-1/2 rotate-90\",\n        className\n      )}\n      disabled={!canScrollPrev}\n      onClick={scrollPrev}\n      {...props}\n    >\n      <ArrowLeft className=\"h-4 w-4\" />\n      <span className=\"sr-only\">Previous slide</span>\n    </Button>\n  )\n})\nCarouselPrevious.displayName = \"CarouselPrevious\"\n\nconst CarouselNext = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<typeof Button>\n>(({ className, variant = \"outline\", size = \"icon\", ...props }, ref) => {\n  const { orientation, scrollNext, canScrollNext } = useCarousel()\n\n  return (\n    <Button\n      ref={ref}\n      variant={variant}\n      size={size}\n      className={cn(\n        \"absolute h-8 w-8 rounded-full\",\n        orientation === \"horizontal\"\n          ? \"-right-12 top-1/2 -translate-y-1/2\"\n          : \"-bottom-12 left-1/2 -translate-x-1/2 rotate-90\",\n        className\n      )}\n      disabled={!canScrollNext}\n      onClick={scrollNext}\n      {...props}\n    >\n      <ArrowRight className=\"h-4 w-4\" />\n      <span className=\"sr-only\">Next slide</span>\n    </Button>\n  )\n})\nCarouselNext.displayName = \"CarouselNext\"\n\nexport {\n  type CarouselApi,\n  Carousel,\n  CarouselContent,\n  CarouselItem,\n  CarouselPrevious,\n  CarouselNext,\n}\n","size_bytes":6210},"client/src/components/ui/chart.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as RechartsPrimitive from \"recharts\"\n\nimport { cn } from \"@/lib/utils\"\n\n// Format: { THEME_NAME: CSS_SELECTOR }\nconst THEMES = { light: \"\", dark: \".dark\" } as const\n\nexport type ChartConfig = {\n  [k in string]: {\n    label?: React.ReactNode\n    icon?: React.ComponentType\n  } & (\n    | { color?: string; theme?: never }\n    | { color?: never; theme: Record<keyof typeof THEMES, string> }\n  )\n}\n\ntype ChartContextProps = {\n  config: ChartConfig\n}\n\nconst ChartContext = React.createContext<ChartContextProps | null>(null)\n\nfunction useChart() {\n  const context = React.useContext(ChartContext)\n\n  if (!context) {\n    throw new Error(\"useChart must be used within a <ChartContainer />\")\n  }\n\n  return context\n}\n\nconst ChartContainer = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & {\n    config: ChartConfig\n    children: React.ComponentProps<\n      typeof RechartsPrimitive.ResponsiveContainer\n    >[\"children\"]\n  }\n>(({ id, className, children, config, ...props }, ref) => {\n  const uniqueId = React.useId()\n  const chartId = `chart-${id || uniqueId.replace(/:/g, \"\")}`\n\n  return (\n    <ChartContext.Provider value={{ config }}>\n      <div\n        data-chart={chartId}\n        ref={ref}\n        className={cn(\n          \"flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none\",\n          className\n        )}\n        {...props}\n      >\n        <ChartStyle id={chartId} config={config} />\n        <RechartsPrimitive.ResponsiveContainer>\n          {children}\n        </RechartsPrimitive.ResponsiveContainer>\n      </div>\n    </ChartContext.Provider>\n  )\n})\nChartContainer.displayName = \"Chart\"\n\nconst ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {\n  const colorConfig = Object.entries(config).filter(\n    ([, config]) => config.theme || config.color\n  )\n\n  if (!colorConfig.length) {\n    return null\n  }\n\n  return (\n    <style\n      dangerouslySetInnerHTML={{\n        __html: Object.entries(THEMES)\n          .map(\n            ([theme, prefix]) => `\n${prefix} [data-chart=${id}] {\n${colorConfig\n  .map(([key, itemConfig]) => {\n    const color =\n      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||\n      itemConfig.color\n    return color ? `  --color-${key}: ${color};` : null\n  })\n  .join(\"\\n\")}\n}\n`\n          )\n          .join(\"\\n\"),\n      }}\n    />\n  )\n}\n\nconst ChartTooltip = RechartsPrimitive.Tooltip\n\nconst ChartTooltipContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &\n    React.ComponentProps<\"div\"> & {\n      hideLabel?: boolean\n      hideIndicator?: boolean\n      indicator?: \"line\" | \"dot\" | \"dashed\"\n      nameKey?: string\n      labelKey?: string\n    }\n>(\n  (\n    {\n      active,\n      payload,\n      className,\n      indicator = \"dot\",\n      hideLabel = false,\n      hideIndicator = false,\n      label,\n      labelFormatter,\n      labelClassName,\n      formatter,\n      color,\n      nameKey,\n      labelKey,\n    },\n    ref\n  ) => {\n    const { config } = useChart()\n\n    const tooltipLabel = React.useMemo(() => {\n      if (hideLabel || !payload?.length) {\n        return null\n      }\n\n      const [item] = payload\n      const key = `${labelKey || item?.dataKey || item?.name || \"value\"}`\n      const itemConfig = getPayloadConfigFromPayload(config, item, key)\n      const value =\n        !labelKey && typeof label === \"string\"\n          ? config[label as keyof typeof config]?.label || label\n          : itemConfig?.label\n\n      if (labelFormatter) {\n        return (\n          <div className={cn(\"font-medium\", labelClassName)}>\n            {labelFormatter(value, payload)}\n          </div>\n        )\n      }\n\n      if (!value) {\n        return null\n      }\n\n      return <div className={cn(\"font-medium\", labelClassName)}>{value}</div>\n    }, [\n      label,\n      labelFormatter,\n      payload,\n      hideLabel,\n      labelClassName,\n      config,\n      labelKey,\n    ])\n\n    if (!active || !payload?.length) {\n      return null\n    }\n\n    const nestLabel = payload.length === 1 && indicator !== \"dot\"\n\n    return (\n      <div\n        ref={ref}\n        className={cn(\n          \"grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl\",\n          className\n        )}\n      >\n        {!nestLabel ? tooltipLabel : null}\n        <div className=\"grid gap-1.5\">\n          {payload.map((item, index) => {\n            const key = `${nameKey || item.name || item.dataKey || \"value\"}`\n            const itemConfig = getPayloadConfigFromPayload(config, item, key)\n            const indicatorColor = color || item.payload.fill || item.color\n\n            return (\n              <div\n                key={item.dataKey}\n                className={cn(\n                  \"flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground\",\n                  indicator === \"dot\" && \"items-center\"\n                )}\n              >\n                {formatter && item?.value !== undefined && item.name ? (\n                  formatter(item.value, item.name, item, index, item.payload)\n                ) : (\n                  <>\n                    {itemConfig?.icon ? (\n                      <itemConfig.icon />\n                    ) : (\n                      !hideIndicator && (\n                        <div\n                          className={cn(\n                            \"shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]\",\n                            {\n                              \"h-2.5 w-2.5\": indicator === \"dot\",\n                              \"w-1\": indicator === \"line\",\n                              \"w-0 border-[1.5px] border-dashed bg-transparent\":\n                                indicator === \"dashed\",\n                              \"my-0.5\": nestLabel && indicator === \"dashed\",\n                            }\n                          )}\n                          style={\n                            {\n                              \"--color-bg\": indicatorColor,\n                              \"--color-border\": indicatorColor,\n                            } as React.CSSProperties\n                          }\n                        />\n                      )\n                    )}\n                    <div\n                      className={cn(\n                        \"flex flex-1 justify-between leading-none\",\n                        nestLabel ? \"items-end\" : \"items-center\"\n                      )}\n                    >\n                      <div className=\"grid gap-1.5\">\n                        {nestLabel ? tooltipLabel : null}\n                        <span className=\"text-muted-foreground\">\n                          {itemConfig?.label || item.name}\n                        </span>\n                      </div>\n                      {item.value && (\n                        <span className=\"font-mono font-medium tabular-nums text-foreground\">\n                          {item.value.toLocaleString()}\n                        </span>\n                      )}\n                    </div>\n                  </>\n                )}\n              </div>\n            )\n          })}\n        </div>\n      </div>\n    )\n  }\n)\nChartTooltipContent.displayName = \"ChartTooltip\"\n\nconst ChartLegend = RechartsPrimitive.Legend\n\nconst ChartLegendContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> &\n    Pick<RechartsPrimitive.LegendProps, \"payload\" | \"verticalAlign\"> & {\n      hideIcon?: boolean\n      nameKey?: string\n    }\n>(\n  (\n    { className, hideIcon = false, payload, verticalAlign = \"bottom\", nameKey },\n    ref\n  ) => {\n    const { config } = useChart()\n\n    if (!payload?.length) {\n      return null\n    }\n\n    return (\n      <div\n        ref={ref}\n        className={cn(\n          \"flex items-center justify-center gap-4\",\n          verticalAlign === \"top\" ? \"pb-3\" : \"pt-3\",\n          className\n        )}\n      >\n        {payload.map((item) => {\n          const key = `${nameKey || item.dataKey || \"value\"}`\n          const itemConfig = getPayloadConfigFromPayload(config, item, key)\n\n          return (\n            <div\n              key={item.value}\n              className={cn(\n                \"flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground\"\n              )}\n            >\n              {itemConfig?.icon && !hideIcon ? (\n                <itemConfig.icon />\n              ) : (\n                <div\n                  className=\"h-2 w-2 shrink-0 rounded-[2px]\"\n                  style={{\n                    backgroundColor: item.color,\n                  }}\n                />\n              )}\n              {itemConfig?.label}\n            </div>\n          )\n        })}\n      </div>\n    )\n  }\n)\nChartLegendContent.displayName = \"ChartLegend\"\n\n// Helper to extract item config from a payload.\nfunction getPayloadConfigFromPayload(\n  config: ChartConfig,\n  payload: unknown,\n  key: string\n) {\n  if (typeof payload !== \"object\" || payload === null) {\n    return undefined\n  }\n\n  const payloadPayload =\n    \"payload\" in payload &&\n    typeof payload.payload === \"object\" &&\n    payload.payload !== null\n      ? payload.payload\n      : undefined\n\n  let configLabelKey: string = key\n\n  if (\n    key in payload &&\n    typeof payload[key as keyof typeof payload] === \"string\"\n  ) {\n    configLabelKey = payload[key as keyof typeof payload] as string\n  } else if (\n    payloadPayload &&\n    key in payloadPayload &&\n    typeof payloadPayload[key as keyof typeof payloadPayload] === \"string\"\n  ) {\n    configLabelKey = payloadPayload[\n      key as keyof typeof payloadPayload\n    ] as string\n  }\n\n  return configLabelKey in config\n    ? config[configLabelKey]\n    : config[key as keyof typeof config]\n}\n\nexport {\n  ChartContainer,\n  ChartTooltip,\n  ChartTooltipContent,\n  ChartLegend,\n  ChartLegendContent,\n  ChartStyle,\n}\n","size_bytes":10481},"client/src/components/ui/checkbox.tsx":{"content":"import * as React from \"react\"\nimport * as CheckboxPrimitive from \"@radix-ui/react-checkbox\"\nimport { Check } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Checkbox = React.forwardRef<\n  React.ElementRef<typeof CheckboxPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <CheckboxPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground\",\n      className\n    )}\n    {...props}\n  >\n    <CheckboxPrimitive.Indicator\n      className={cn(\"flex items-center justify-center text-current\")}\n    >\n      <Check className=\"h-4 w-4\" />\n    </CheckboxPrimitive.Indicator>\n  </CheckboxPrimitive.Root>\n))\nCheckbox.displayName = CheckboxPrimitive.Root.displayName\n\nexport { Checkbox }\n","size_bytes":1056},"client/src/components/ui/collapsible.tsx":{"content":"\"use client\"\n\nimport * as CollapsiblePrimitive from \"@radix-ui/react-collapsible\"\n\nconst Collapsible = CollapsiblePrimitive.Root\n\nconst CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger\n\nconst CollapsibleContent = CollapsiblePrimitive.CollapsibleContent\n\nexport { Collapsible, CollapsibleTrigger, CollapsibleContent }\n","size_bytes":329},"client/src/components/ui/command.tsx":{"content":"import * as React from \"react\"\nimport { type DialogProps } from \"@radix-ui/react-dialog\"\nimport { Command as CommandPrimitive } from \"cmdk\"\nimport { Search } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Dialog, DialogContent } from \"@/components/ui/dialog\"\n\nconst Command = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive\n    ref={ref}\n    className={cn(\n      \"flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\nCommand.displayName = CommandPrimitive.displayName\n\nconst CommandDialog = ({ children, ...props }: DialogProps) => {\n  return (\n    <Dialog {...props}>\n      <DialogContent className=\"overflow-hidden p-0 shadow-lg\">\n        <Command className=\"[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5\">\n          {children}\n        </Command>\n      </DialogContent>\n    </Dialog>\n  )\n}\n\nconst CommandInput = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Input>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>\n>(({ className, ...props }, ref) => (\n  <div className=\"flex items-center border-b px-3\" cmdk-input-wrapper=\"\">\n    <Search className=\"mr-2 h-4 w-4 shrink-0 opacity-50\" />\n    <CommandPrimitive.Input\n      ref={ref}\n      className={cn(\n        \"flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    />\n  </div>\n))\n\nCommandInput.displayName = CommandPrimitive.Input.displayName\n\nconst CommandList = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.List>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.List\n    ref={ref}\n    className={cn(\"max-h-[300px] overflow-y-auto overflow-x-hidden\", className)}\n    {...props}\n  />\n))\n\nCommandList.displayName = CommandPrimitive.List.displayName\n\nconst CommandEmpty = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Empty>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>\n>((props, ref) => (\n  <CommandPrimitive.Empty\n    ref={ref}\n    className=\"py-6 text-center text-sm\"\n    {...props}\n  />\n))\n\nCommandEmpty.displayName = CommandPrimitive.Empty.displayName\n\nconst CommandGroup = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Group>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Group\n    ref={ref}\n    className={cn(\n      \"overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\n\nCommandGroup.displayName = CommandPrimitive.Group.displayName\n\nconst CommandSeparator = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 h-px bg-border\", className)}\n    {...props}\n  />\n))\nCommandSeparator.displayName = CommandPrimitive.Separator.displayName\n\nconst CommandItem = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n      className\n    )}\n    {...props}\n  />\n))\n\nCommandItem.displayName = CommandPrimitive.Item.displayName\n\nconst CommandShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\n        \"ml-auto text-xs tracking-widest text-muted-foreground\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\nCommandShortcut.displayName = \"CommandShortcut\"\n\nexport {\n  Command,\n  CommandDialog,\n  CommandInput,\n  CommandList,\n  CommandEmpty,\n  CommandGroup,\n  CommandItem,\n  CommandShortcut,\n  CommandSeparator,\n}\n","size_bytes":4885},"client/src/components/ui/context-menu.tsx":{"content":"import * as React from \"react\"\nimport * as ContextMenuPrimitive from \"@radix-ui/react-context-menu\"\nimport { Check, ChevronRight, Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ContextMenu = ContextMenuPrimitive.Root\n\nconst ContextMenuTrigger = ContextMenuPrimitive.Trigger\n\nconst ContextMenuGroup = ContextMenuPrimitive.Group\n\nconst ContextMenuPortal = ContextMenuPrimitive.Portal\n\nconst ContextMenuSub = ContextMenuPrimitive.Sub\n\nconst ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup\n\nconst ContextMenuSubTrigger = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {\n    inset?: boolean\n  }\n>(({ className, inset, children, ...props }, ref) => (\n  <ContextMenuPrimitive.SubTrigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <ChevronRight className=\"ml-auto h-4 w-4\" />\n  </ContextMenuPrimitive.SubTrigger>\n))\nContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName\n\nconst ContextMenuSubContent = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>\n>(({ className, ...props }, ref) => (\n  <ContextMenuPrimitive.SubContent\n    ref={ref}\n    className={cn(\n      \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-context-menu-content-transform-origin]\",\n      className\n    )}\n    {...props}\n  />\n))\nContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName\n\nconst ContextMenuContent = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <ContextMenuPrimitive.Portal>\n    <ContextMenuPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"z-50 max-h-[--radix-context-menu-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-context-menu-content-transform-origin]\",\n        className\n      )}\n      {...props}\n    />\n  </ContextMenuPrimitive.Portal>\n))\nContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName\n\nconst ContextMenuItem = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <ContextMenuPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName\n\nconst ContextMenuCheckboxItem = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>\n>(({ className, children, checked, ...props }, ref) => (\n  <ContextMenuPrimitive.CheckboxItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    checked={checked}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <ContextMenuPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </ContextMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </ContextMenuPrimitive.CheckboxItem>\n))\nContextMenuCheckboxItem.displayName =\n  ContextMenuPrimitive.CheckboxItem.displayName\n\nconst ContextMenuRadioItem = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>\n>(({ className, children, ...props }, ref) => (\n  <ContextMenuPrimitive.RadioItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <ContextMenuPrimitive.ItemIndicator>\n        <Circle className=\"h-2 w-2 fill-current\" />\n      </ContextMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </ContextMenuPrimitive.RadioItem>\n))\nContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName\n\nconst ContextMenuLabel = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <ContextMenuPrimitive.Label\n    ref={ref}\n    className={cn(\n      \"px-2 py-1.5 text-sm font-semibold text-foreground\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName\n\nconst ContextMenuSeparator = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <ContextMenuPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-border\", className)}\n    {...props}\n  />\n))\nContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName\n\nconst ContextMenuShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\n        \"ml-auto text-xs tracking-widest text-muted-foreground\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\nContextMenuShortcut.displayName = \"ContextMenuShortcut\"\n\nexport {\n  ContextMenu,\n  ContextMenuTrigger,\n  ContextMenuContent,\n  ContextMenuItem,\n  ContextMenuCheckboxItem,\n  ContextMenuRadioItem,\n  ContextMenuLabel,\n  ContextMenuSeparator,\n  ContextMenuShortcut,\n  ContextMenuGroup,\n  ContextMenuPortal,\n  ContextMenuSub,\n  ContextMenuSubContent,\n  ContextMenuSubTrigger,\n  ContextMenuRadioGroup,\n}\n","size_bytes":7428},"client/src/components/ui/dialog.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as DialogPrimitive from \"@radix-ui/react-dialog\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Dialog = DialogPrimitive.Root\n\nconst DialogTrigger = DialogPrimitive.Trigger\n\nconst DialogPortal = DialogPrimitive.Portal\n\nconst DialogClose = DialogPrimitive.Close\n\nconst DialogOverlay = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Overlay\n    ref={ref}\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n  />\n))\nDialogOverlay.displayName = DialogPrimitive.Overlay.displayName\n\nconst DialogContent = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <DialogPortal>\n    <DialogOverlay />\n    <DialogPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg dark:border-gray-700\",\n        className\n      )}\n      {...props}\n    >\n      {children}\n      <DialogPrimitive.Close className=\"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground dark:text-gray-300 dark:hover:text-white\">\n        <X className=\"h-4 w-4\" />\n        <span className=\"sr-only\">Close</span>\n      </DialogPrimitive.Close>\n    </DialogPrimitive.Content>\n  </DialogPortal>\n))\nDialogContent.displayName = DialogPrimitive.Content.displayName\n\nconst DialogHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-1.5 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nDialogHeader.displayName = \"DialogHeader\"\n\nconst DialogFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nDialogFooter.displayName = \"DialogFooter\"\n\nconst DialogTitle = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Title\n    ref={ref}\n    className={cn(\n      \"text-lg font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nDialogTitle.displayName = DialogPrimitive.Title.displayName\n\nconst DialogDescription = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nDialogDescription.displayName = DialogPrimitive.Description.displayName\n\nexport {\n  Dialog,\n  DialogPortal,\n  DialogOverlay,\n  DialogClose,\n  DialogTrigger,\n  DialogContent,\n  DialogHeader,\n  DialogFooter,\n  DialogTitle,\n  DialogDescription,\n}\n","size_bytes":3910},"client/src/components/ui/drawer.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport { Drawer as DrawerPrimitive } from \"vaul\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Drawer = ({\n  shouldScaleBackground = true,\n  ...props\n}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (\n  <DrawerPrimitive.Root\n    shouldScaleBackground={shouldScaleBackground}\n    {...props}\n  />\n)\nDrawer.displayName = \"Drawer\"\n\nconst DrawerTrigger = DrawerPrimitive.Trigger\n\nconst DrawerPortal = DrawerPrimitive.Portal\n\nconst DrawerClose = DrawerPrimitive.Close\n\nconst DrawerOverlay = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <DrawerPrimitive.Overlay\n    ref={ref}\n    className={cn(\"fixed inset-0 z-50 bg-black/80\", className)}\n    {...props}\n  />\n))\nDrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName\n\nconst DrawerContent = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <DrawerPortal>\n    <DrawerOverlay />\n    <DrawerPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background\",\n        className\n      )}\n      {...props}\n    >\n      <div className=\"mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted\" />\n      {children}\n    </DrawerPrimitive.Content>\n  </DrawerPortal>\n))\nDrawerContent.displayName = \"DrawerContent\"\n\nconst DrawerHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\"grid gap-1.5 p-4 text-center sm:text-left\", className)}\n    {...props}\n  />\n)\nDrawerHeader.displayName = \"DrawerHeader\"\n\nconst DrawerFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\"mt-auto flex flex-col gap-2 p-4\", className)}\n    {...props}\n  />\n)\nDrawerFooter.displayName = \"DrawerFooter\"\n\nconst DrawerTitle = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <DrawerPrimitive.Title\n    ref={ref}\n    className={cn(\n      \"text-lg font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nDrawerTitle.displayName = DrawerPrimitive.Title.displayName\n\nconst DrawerDescription = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <DrawerPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nDrawerDescription.displayName = DrawerPrimitive.Description.displayName\n\nexport {\n  Drawer,\n  DrawerPortal,\n  DrawerOverlay,\n  DrawerTrigger,\n  DrawerClose,\n  DrawerContent,\n  DrawerHeader,\n  DrawerFooter,\n  DrawerTitle,\n  DrawerDescription,\n}\n","size_bytes":3021},"client/src/components/ui/dropdown-menu.tsx":{"content":"import * as React from \"react\"\nimport * as DropdownMenuPrimitive from \"@radix-ui/react-dropdown-menu\"\nimport { Check, ChevronRight, Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst DropdownMenu = DropdownMenuPrimitive.Root\n\nconst DropdownMenuTrigger = DropdownMenuPrimitive.Trigger\n\nconst DropdownMenuGroup = DropdownMenuPrimitive.Group\n\nconst DropdownMenuPortal = DropdownMenuPrimitive.Portal\n\nconst DropdownMenuSub = DropdownMenuPrimitive.Sub\n\nconst DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup\n\nconst DropdownMenuSubTrigger = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {\n    inset?: boolean\n  }\n>(({ className, inset, children, ...props }, ref) => (\n  <DropdownMenuPrimitive.SubTrigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <ChevronRight className=\"ml-auto\" />\n  </DropdownMenuPrimitive.SubTrigger>\n))\nDropdownMenuSubTrigger.displayName =\n  DropdownMenuPrimitive.SubTrigger.displayName\n\nconst DropdownMenuSubContent = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>\n>(({ className, ...props }, ref) => (\n  <DropdownMenuPrimitive.SubContent\n    ref={ref}\n    className={cn(\n      \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]\",\n      className\n    )}\n    {...props}\n  />\n))\nDropdownMenuSubContent.displayName =\n  DropdownMenuPrimitive.SubContent.displayName\n\nconst DropdownMenuContent = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>\n>(({ className, sideOffset = 4, ...props }, ref) => (\n  <DropdownMenuPrimitive.Portal>\n    <DropdownMenuPrimitive.Content\n      ref={ref}\n      sideOffset={sideOffset}\n      className={cn(\n        \"z-50 max-h-[var(--radix-dropdown-menu-content-available-height)] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]\",\n        className\n      )}\n      {...props}\n    />\n  </DropdownMenuPrimitive.Portal>\n))\nDropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName\n\nconst DropdownMenuItem = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <DropdownMenuPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nDropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName\n\nconst DropdownMenuCheckboxItem = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>\n>(({ className, children, checked, ...props }, ref) => (\n  <DropdownMenuPrimitive.CheckboxItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    checked={checked}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <DropdownMenuPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </DropdownMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </DropdownMenuPrimitive.CheckboxItem>\n))\nDropdownMenuCheckboxItem.displayName =\n  DropdownMenuPrimitive.CheckboxItem.displayName\n\nconst DropdownMenuRadioItem = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>\n>(({ className, children, ...props }, ref) => (\n  <DropdownMenuPrimitive.RadioItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <DropdownMenuPrimitive.ItemIndicator>\n        <Circle className=\"h-2 w-2 fill-current\" />\n      </DropdownMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </DropdownMenuPrimitive.RadioItem>\n))\nDropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName\n\nconst DropdownMenuLabel = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <DropdownMenuPrimitive.Label\n    ref={ref}\n    className={cn(\n      \"px-2 py-1.5 text-sm font-semibold\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nDropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName\n\nconst DropdownMenuSeparator = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <DropdownMenuPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nDropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName\n\nconst DropdownMenuShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\"ml-auto text-xs tracking-widest opacity-60\", className)}\n      {...props}\n    />\n  )\n}\nDropdownMenuShortcut.displayName = \"DropdownMenuShortcut\"\n\nexport {\n  DropdownMenu,\n  DropdownMenuTrigger,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuCheckboxItem,\n  DropdownMenuRadioItem,\n  DropdownMenuLabel,\n  DropdownMenuSeparator,\n  DropdownMenuShortcut,\n  DropdownMenuGroup,\n  DropdownMenuPortal,\n  DropdownMenuSub,\n  DropdownMenuSubContent,\n  DropdownMenuSubTrigger,\n  DropdownMenuRadioGroup,\n}\n","size_bytes":7609},"client/src/components/ui/form.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport {\n  Controller,\n  FormProvider,\n  useFormContext,\n  type ControllerProps,\n  type FieldPath,\n  type FieldValues,\n} from \"react-hook-form\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Label } from \"@/components/ui/label\"\n\nconst Form = FormProvider\n\ntype FormFieldContextValue<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>\n> = {\n  name: TName\n}\n\nconst FormFieldContext = React.createContext<FormFieldContextValue>(\n  {} as FormFieldContextValue\n)\n\nconst FormField = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>\n>({\n  ...props\n}: ControllerProps<TFieldValues, TName>) => {\n  return (\n    <FormFieldContext.Provider value={{ name: props.name }}>\n      <Controller {...props} />\n    </FormFieldContext.Provider>\n  )\n}\n\nconst useFormField = () => {\n  const fieldContext = React.useContext(FormFieldContext)\n  const itemContext = React.useContext(FormItemContext)\n  const { getFieldState, formState } = useFormContext()\n\n  const fieldState = getFieldState(fieldContext.name, formState)\n\n  if (!fieldContext) {\n    throw new Error(\"useFormField should be used within <FormField>\")\n  }\n\n  const { id } = itemContext\n\n  return {\n    id,\n    name: fieldContext.name,\n    formItemId: `${id}-form-item`,\n    formDescriptionId: `${id}-form-item-description`,\n    formMessageId: `${id}-form-item-message`,\n    ...fieldState,\n  }\n}\n\ntype FormItemContextValue = {\n  id: string\n}\n\nconst FormItemContext = React.createContext<FormItemContextValue>(\n  {} as FormItemContextValue\n)\n\nconst FormItem = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const id = React.useId()\n\n  return (\n    <FormItemContext.Provider value={{ id }}>\n      <div ref={ref} className={cn(\"space-y-2\", className)} {...props} />\n    </FormItemContext.Provider>\n  )\n})\nFormItem.displayName = \"FormItem\"\n\nconst FormLabel = React.forwardRef<\n  React.ElementRef<typeof LabelPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>\n>(({ className, ...props }, ref) => {\n  const { error, formItemId } = useFormField()\n\n  return (\n    <Label\n      ref={ref}\n      className={cn(error && \"text-destructive\", className)}\n      htmlFor={formItemId}\n      {...props}\n    />\n  )\n})\nFormLabel.displayName = \"FormLabel\"\n\nconst FormControl = React.forwardRef<\n  React.ElementRef<typeof Slot>,\n  React.ComponentPropsWithoutRef<typeof Slot>\n>(({ ...props }, ref) => {\n  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()\n\n  return (\n    <Slot\n      ref={ref}\n      id={formItemId}\n      aria-describedby={\n        !error\n          ? `${formDescriptionId}`\n          : `${formDescriptionId} ${formMessageId}`\n      }\n      aria-invalid={!!error}\n      {...props}\n    />\n  )\n})\nFormControl.displayName = \"FormControl\"\n\nconst FormDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, ...props }, ref) => {\n  const { formDescriptionId } = useFormField()\n\n  return (\n    <p\n      ref={ref}\n      id={formDescriptionId}\n      className={cn(\"text-sm text-muted-foreground\", className)}\n      {...props}\n    />\n  )\n})\nFormDescription.displayName = \"FormDescription\"\n\nconst FormMessage = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, children, ...props }, ref) => {\n  const { error, formMessageId } = useFormField()\n  const body = error ? String(error?.message ?? \"\") : children\n\n  if (!body) {\n    return null\n  }\n\n  return (\n    <p\n      ref={ref}\n      id={formMessageId}\n      className={cn(\"text-sm font-medium text-destructive\", className)}\n      {...props}\n    >\n      {body}\n    </p>\n  )\n})\nFormMessage.displayName = \"FormMessage\"\n\nexport {\n  useFormField,\n  Form,\n  FormItem,\n  FormLabel,\n  FormControl,\n  FormDescription,\n  FormMessage,\n  FormField,\n}\n","size_bytes":4120},"client/src/components/ui/hover-card.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as HoverCardPrimitive from \"@radix-ui/react-hover-card\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst HoverCard = HoverCardPrimitive.Root\n\nconst HoverCardTrigger = HoverCardPrimitive.Trigger\n\nconst HoverCardContent = React.forwardRef<\n  React.ElementRef<typeof HoverCardPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>\n>(({ className, align = \"center\", sideOffset = 4, ...props }, ref) => (\n  <HoverCardPrimitive.Content\n    ref={ref}\n    align={align}\n    sideOffset={sideOffset}\n    className={cn(\n      \"z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-hover-card-content-transform-origin]\",\n      className\n    )}\n    {...props}\n  />\n))\nHoverCardContent.displayName = HoverCardPrimitive.Content.displayName\n\nexport { HoverCard, HoverCardTrigger, HoverCardContent }\n","size_bytes":1251},"client/src/components/ui/input-otp.tsx":{"content":"import * as React from \"react\"\nimport { OTPInput, OTPInputContext } from \"input-otp\"\nimport { Dot } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst InputOTP = React.forwardRef<\n  React.ElementRef<typeof OTPInput>,\n  React.ComponentPropsWithoutRef<typeof OTPInput>\n>(({ className, containerClassName, ...props }, ref) => (\n  <OTPInput\n    ref={ref}\n    containerClassName={cn(\n      \"flex items-center gap-2 has-[:disabled]:opacity-50\",\n      containerClassName\n    )}\n    className={cn(\"disabled:cursor-not-allowed\", className)}\n    {...props}\n  />\n))\nInputOTP.displayName = \"InputOTP\"\n\nconst InputOTPGroup = React.forwardRef<\n  React.ElementRef<\"div\">,\n  React.ComponentPropsWithoutRef<\"div\">\n>(({ className, ...props }, ref) => (\n  <div ref={ref} className={cn(\"flex items-center\", className)} {...props} />\n))\nInputOTPGroup.displayName = \"InputOTPGroup\"\n\nconst InputOTPSlot = React.forwardRef<\n  React.ElementRef<\"div\">,\n  React.ComponentPropsWithoutRef<\"div\"> & { index: number }\n>(({ index, className, ...props }, ref) => {\n  const inputOTPContext = React.useContext(OTPInputContext)\n  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index]\n\n  return (\n    <div\n      ref={ref}\n      className={cn(\n        \"relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md\",\n        isActive && \"z-10 ring-2 ring-ring ring-offset-background\",\n        className\n      )}\n      {...props}\n    >\n      {char}\n      {hasFakeCaret && (\n        <div className=\"pointer-events-none absolute inset-0 flex items-center justify-center\">\n          <div className=\"h-4 w-px animate-caret-blink bg-foreground duration-1000\" />\n        </div>\n      )}\n    </div>\n  )\n})\nInputOTPSlot.displayName = \"InputOTPSlot\"\n\nconst InputOTPSeparator = React.forwardRef<\n  React.ElementRef<\"div\">,\n  React.ComponentPropsWithoutRef<\"div\">\n>(({ ...props }, ref) => (\n  <div ref={ref} role=\"separator\" {...props}>\n    <Dot />\n  </div>\n))\nInputOTPSeparator.displayName = \"InputOTPSeparator\"\n\nexport { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }\n","size_bytes":2154},"client/src/components/ui/input.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Input = React.forwardRef<HTMLInputElement, React.ComponentProps<\"input\">>(\n  ({ className, type, ...props }, ref) => {\n    return (\n      <input\n        type={type}\n        className={cn(\n          \"modern-input flex h-12 w-full file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground disabled:cursor-not-allowed disabled:opacity-50\",\n          className\n        )}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nInput.displayName = \"Input\"\n\nexport { Input }\n","size_bytes":571},"client/src/components/ui/label.tsx":{"content":"import * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst labelVariants = cva(\n  \"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\"\n)\n\nconst Label = React.forwardRef<\n  React.ElementRef<typeof LabelPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &\n    VariantProps<typeof labelVariants>\n>(({ className, ...props }, ref) => (\n  <LabelPrimitive.Root\n    ref={ref}\n    className={cn(labelVariants(), className)}\n    {...props}\n  />\n))\nLabel.displayName = LabelPrimitive.Root.displayName\n\nexport { Label }\n","size_bytes":710},"client/src/components/ui/menubar.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as MenubarPrimitive from \"@radix-ui/react-menubar\"\nimport { Check, ChevronRight, Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction MenubarMenu({\n  ...props\n}: React.ComponentProps<typeof MenubarPrimitive.Menu>) {\n  return <MenubarPrimitive.Menu {...props} />\n}\n\nfunction MenubarGroup({\n  ...props\n}: React.ComponentProps<typeof MenubarPrimitive.Group>) {\n  return <MenubarPrimitive.Group {...props} />\n}\n\nfunction MenubarPortal({\n  ...props\n}: React.ComponentProps<typeof MenubarPrimitive.Portal>) {\n  return <MenubarPrimitive.Portal {...props} />\n}\n\nfunction MenubarRadioGroup({\n  ...props\n}: React.ComponentProps<typeof MenubarPrimitive.RadioGroup>) {\n  return <MenubarPrimitive.RadioGroup {...props} />\n}\n\nfunction MenubarSub({\n  ...props\n}: React.ComponentProps<typeof MenubarPrimitive.Sub>) {\n  return <MenubarPrimitive.Sub data-slot=\"menubar-sub\" {...props} />\n}\n\nconst Menubar = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"flex h-10 items-center space-x-1 rounded-md border bg-background p-1\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubar.displayName = MenubarPrimitive.Root.displayName\n\nconst MenubarTrigger = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName\n\nconst MenubarSubTrigger = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {\n    inset?: boolean\n  }\n>(({ className, inset, children, ...props }, ref) => (\n  <MenubarPrimitive.SubTrigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <ChevronRight className=\"ml-auto h-4 w-4\" />\n  </MenubarPrimitive.SubTrigger>\n))\nMenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName\n\nconst MenubarSubContent = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.SubContent>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.SubContent\n    ref={ref}\n    className={cn(\n      \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-menubar-content-transform-origin]\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName\n\nconst MenubarContent = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>\n>(\n  (\n    { className, align = \"start\", alignOffset = -4, sideOffset = 8, ...props },\n    ref\n  ) => (\n    <MenubarPrimitive.Portal>\n      <MenubarPrimitive.Content\n        ref={ref}\n        align={align}\n        alignOffset={alignOffset}\n        sideOffset={sideOffset}\n        className={cn(\n          \"z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-menubar-content-transform-origin]\",\n          className\n        )}\n        {...props}\n      />\n    </MenubarPrimitive.Portal>\n  )\n)\nMenubarContent.displayName = MenubarPrimitive.Content.displayName\n\nconst MenubarItem = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <MenubarPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarItem.displayName = MenubarPrimitive.Item.displayName\n\nconst MenubarCheckboxItem = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>\n>(({ className, children, checked, ...props }, ref) => (\n  <MenubarPrimitive.CheckboxItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    checked={checked}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <MenubarPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </MenubarPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </MenubarPrimitive.CheckboxItem>\n))\nMenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName\n\nconst MenubarRadioItem = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.RadioItem>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>\n>(({ className, children, ...props }, ref) => (\n  <MenubarPrimitive.RadioItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <MenubarPrimitive.ItemIndicator>\n        <Circle className=\"h-2 w-2 fill-current\" />\n      </MenubarPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </MenubarPrimitive.RadioItem>\n))\nMenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName\n\nconst MenubarLabel = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <MenubarPrimitive.Label\n    ref={ref}\n    className={cn(\n      \"px-2 py-1.5 text-sm font-semibold\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarLabel.displayName = MenubarPrimitive.Label.displayName\n\nconst MenubarSeparator = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nMenubarSeparator.displayName = MenubarPrimitive.Separator.displayName\n\nconst MenubarShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\n        \"ml-auto text-xs tracking-widest text-muted-foreground\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\nMenubarShortcut.displayname = \"MenubarShortcut\"\n\nexport {\n  Menubar,\n  MenubarMenu,\n  MenubarTrigger,\n  MenubarContent,\n  MenubarItem,\n  MenubarSeparator,\n  MenubarLabel,\n  MenubarCheckboxItem,\n  MenubarRadioGroup,\n  MenubarRadioItem,\n  MenubarPortal,\n  MenubarSubContent,\n  MenubarSubTrigger,\n  MenubarGroup,\n  MenubarSub,\n  MenubarShortcut,\n}\n","size_bytes":8605},"client/src/components/ui/navigation-menu.tsx":{"content":"import * as React from \"react\"\nimport * as NavigationMenuPrimitive from \"@radix-ui/react-navigation-menu\"\nimport { cva } from \"class-variance-authority\"\nimport { ChevronDown } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst NavigationMenu = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>\n>(({ className, children, ...props }, ref) => (\n  <NavigationMenuPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative z-10 flex max-w-max flex-1 items-center justify-center\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <NavigationMenuViewport />\n  </NavigationMenuPrimitive.Root>\n))\nNavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName\n\nconst NavigationMenuList = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.List>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>\n>(({ className, ...props }, ref) => (\n  <NavigationMenuPrimitive.List\n    ref={ref}\n    className={cn(\n      \"group flex flex-1 list-none items-center justify-center space-x-1\",\n      className\n    )}\n    {...props}\n  />\n))\nNavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName\n\nconst NavigationMenuItem = NavigationMenuPrimitive.Item\n\nconst navigationMenuTriggerStyle = cva(\n  \"group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[state=open]:text-accent-foreground data-[state=open]:bg-accent/50 data-[state=open]:hover:bg-accent data-[state=open]:focus:bg-accent\"\n)\n\nconst NavigationMenuTrigger = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <NavigationMenuPrimitive.Trigger\n    ref={ref}\n    className={cn(navigationMenuTriggerStyle(), \"group\", className)}\n    {...props}\n  >\n    {children}{\" \"}\n    <ChevronDown\n      className=\"relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180\"\n      aria-hidden=\"true\"\n    />\n  </NavigationMenuPrimitive.Trigger>\n))\nNavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName\n\nconst NavigationMenuContent = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <NavigationMenuPrimitive.Content\n    ref={ref}\n    className={cn(\n      \"left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto \",\n      className\n    )}\n    {...props}\n  />\n))\nNavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName\n\nconst NavigationMenuLink = NavigationMenuPrimitive.Link\n\nconst NavigationMenuViewport = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>\n>(({ className, ...props }, ref) => (\n  <div className={cn(\"absolute left-0 top-full flex justify-center\")}>\n    <NavigationMenuPrimitive.Viewport\n      className={cn(\n        \"origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]\",\n        className\n      )}\n      ref={ref}\n      {...props}\n    />\n  </div>\n))\nNavigationMenuViewport.displayName =\n  NavigationMenuPrimitive.Viewport.displayName\n\nconst NavigationMenuIndicator = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>\n>(({ className, ...props }, ref) => (\n  <NavigationMenuPrimitive.Indicator\n    ref={ref}\n    className={cn(\n      \"top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in\",\n      className\n    )}\n    {...props}\n  >\n    <div className=\"relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md\" />\n  </NavigationMenuPrimitive.Indicator>\n))\nNavigationMenuIndicator.displayName =\n  NavigationMenuPrimitive.Indicator.displayName\n\nexport {\n  navigationMenuTriggerStyle,\n  NavigationMenu,\n  NavigationMenuList,\n  NavigationMenuItem,\n  NavigationMenuContent,\n  NavigationMenuTrigger,\n  NavigationMenuLink,\n  NavigationMenuIndicator,\n  NavigationMenuViewport,\n}\n","size_bytes":5128},"client/src/components/ui/pagination.tsx":{"content":"import * as React from \"react\"\nimport { ChevronLeft, ChevronRight, MoreHorizontal } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { ButtonProps, buttonVariants } from \"@/components/ui/button\"\n\nconst Pagination = ({ className, ...props }: React.ComponentProps<\"nav\">) => (\n  <nav\n    role=\"navigation\"\n    aria-label=\"pagination\"\n    className={cn(\"mx-auto flex w-full justify-center\", className)}\n    {...props}\n  />\n)\nPagination.displayName = \"Pagination\"\n\nconst PaginationContent = React.forwardRef<\n  HTMLUListElement,\n  React.ComponentProps<\"ul\">\n>(({ className, ...props }, ref) => (\n  <ul\n    ref={ref}\n    className={cn(\"flex flex-row items-center gap-1\", className)}\n    {...props}\n  />\n))\nPaginationContent.displayName = \"PaginationContent\"\n\nconst PaginationItem = React.forwardRef<\n  HTMLLIElement,\n  React.ComponentProps<\"li\">\n>(({ className, ...props }, ref) => (\n  <li ref={ref} className={cn(\"\", className)} {...props} />\n))\nPaginationItem.displayName = \"PaginationItem\"\n\ntype PaginationLinkProps = {\n  isActive?: boolean\n} & Pick<ButtonProps, \"size\"> &\n  React.ComponentProps<\"a\">\n\nconst PaginationLink = ({\n  className,\n  isActive,\n  size = \"icon\",\n  ...props\n}: PaginationLinkProps) => (\n  <a\n    aria-current={isActive ? \"page\" : undefined}\n    className={cn(\n      buttonVariants({\n        variant: isActive ? \"outline\" : \"ghost\",\n        size,\n      }),\n      className\n    )}\n    {...props}\n  />\n)\nPaginationLink.displayName = \"PaginationLink\"\n\nconst PaginationPrevious = ({\n  className,\n  ...props\n}: React.ComponentProps<typeof PaginationLink>) => (\n  <PaginationLink\n    aria-label=\"Go to previous page\"\n    size=\"default\"\n    className={cn(\"gap-1 pl-2.5\", className)}\n    {...props}\n  >\n    <ChevronLeft className=\"h-4 w-4\" />\n    <span>Previous</span>\n  </PaginationLink>\n)\nPaginationPrevious.displayName = \"PaginationPrevious\"\n\nconst PaginationNext = ({\n  className,\n  ...props\n}: React.ComponentProps<typeof PaginationLink>) => (\n  <PaginationLink\n    aria-label=\"Go to next page\"\n    size=\"default\"\n    className={cn(\"gap-1 pr-2.5\", className)}\n    {...props}\n  >\n    <span>Next</span>\n    <ChevronRight className=\"h-4 w-4\" />\n  </PaginationLink>\n)\nPaginationNext.displayName = \"PaginationNext\"\n\nconst PaginationEllipsis = ({\n  className,\n  ...props\n}: React.ComponentProps<\"span\">) => (\n  <span\n    aria-hidden\n    className={cn(\"flex h-9 w-9 items-center justify-center\", className)}\n    {...props}\n  >\n    <MoreHorizontal className=\"h-4 w-4\" />\n    <span className=\"sr-only\">More pages</span>\n  </span>\n)\nPaginationEllipsis.displayName = \"PaginationEllipsis\"\n\nexport {\n  Pagination,\n  PaginationContent,\n  PaginationEllipsis,\n  PaginationItem,\n  PaginationLink,\n  PaginationNext,\n  PaginationPrevious,\n}\n","size_bytes":2751},"client/src/components/ui/popover.tsx":{"content":"import * as React from \"react\"\nimport * as PopoverPrimitive from \"@radix-ui/react-popover\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Popover = PopoverPrimitive.Root\n\nconst PopoverTrigger = PopoverPrimitive.Trigger\n\nconst PopoverContent = React.forwardRef<\n  React.ElementRef<typeof PopoverPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>\n>(({ className, align = \"center\", sideOffset = 4, ...props }, ref) => (\n  <PopoverPrimitive.Portal>\n    <PopoverPrimitive.Content\n      ref={ref}\n      align={align}\n      sideOffset={sideOffset}\n      className={cn(\n        \"z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-popover-content-transform-origin]\",\n        className\n      )}\n      {...props}\n    />\n  </PopoverPrimitive.Portal>\n))\nPopoverContent.displayName = PopoverPrimitive.Content.displayName\n\nexport { Popover, PopoverTrigger, PopoverContent }\n","size_bytes":1280},"client/src/components/ui/progress.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as ProgressPrimitive from \"@radix-ui/react-progress\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Progress = React.forwardRef<\n  React.ElementRef<typeof ProgressPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>\n>(({ className, value, ...props }, ref) => (\n  <ProgressPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative h-4 w-full overflow-hidden rounded-full bg-secondary\",\n      className\n    )}\n    {...props}\n  >\n    <ProgressPrimitive.Indicator\n      className=\"h-full w-full flex-1 bg-primary transition-all\"\n      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}\n    />\n  </ProgressPrimitive.Root>\n))\nProgress.displayName = ProgressPrimitive.Root.displayName\n\nexport { Progress }\n","size_bytes":791},"client/src/components/ui/radio-group.tsx":{"content":"import * as React from \"react\"\nimport * as RadioGroupPrimitive from \"@radix-ui/react-radio-group\"\nimport { Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst RadioGroup = React.forwardRef<\n  React.ElementRef<typeof RadioGroupPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>\n>(({ className, ...props }, ref) => {\n  return (\n    <RadioGroupPrimitive.Root\n      className={cn(\"grid gap-2\", className)}\n      {...props}\n      ref={ref}\n    />\n  )\n})\nRadioGroup.displayName = RadioGroupPrimitive.Root.displayName\n\nconst RadioGroupItem = React.forwardRef<\n  React.ElementRef<typeof RadioGroupPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>\n>(({ className, ...props }, ref) => {\n  return (\n    <RadioGroupPrimitive.Item\n      ref={ref}\n      className={cn(\n        \"aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    >\n      <RadioGroupPrimitive.Indicator className=\"flex items-center justify-center\">\n        <Circle className=\"h-2.5 w-2.5 fill-current text-current\" />\n      </RadioGroupPrimitive.Indicator>\n    </RadioGroupPrimitive.Item>\n  )\n})\nRadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName\n\nexport { RadioGroup, RadioGroupItem }\n","size_bytes":1467},"client/src/components/ui/resizable.tsx":{"content":"\"use client\"\n\nimport { GripVertical } from \"lucide-react\"\nimport * as ResizablePrimitive from \"react-resizable-panels\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ResizablePanelGroup = ({\n  className,\n  ...props\n}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (\n  <ResizablePrimitive.PanelGroup\n    className={cn(\n      \"flex h-full w-full data-[panel-group-direction=vertical]:flex-col\",\n      className\n    )}\n    {...props}\n  />\n)\n\nconst ResizablePanel = ResizablePrimitive.Panel\n\nconst ResizableHandle = ({\n  withHandle,\n  className,\n  ...props\n}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {\n  withHandle?: boolean\n}) => (\n  <ResizablePrimitive.PanelResizeHandle\n    className={cn(\n      \"relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90\",\n      className\n    )}\n    {...props}\n  >\n    {withHandle && (\n      <div className=\"z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border\">\n        <GripVertical className=\"h-2.5 w-2.5\" />\n      </div>\n    )}\n  </ResizablePrimitive.PanelResizeHandle>\n)\n\nexport { ResizablePanelGroup, ResizablePanel, ResizableHandle }\n","size_bytes":1723},"client/src/components/ui/scroll-area.tsx":{"content":"import * as React from \"react\"\nimport * as ScrollAreaPrimitive from \"@radix-ui/react-scroll-area\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ScrollArea = React.forwardRef<\n  React.ElementRef<typeof ScrollAreaPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>\n>(({ className, children, ...props }, ref) => (\n  <ScrollAreaPrimitive.Root\n    ref={ref}\n    className={cn(\"relative overflow-hidden\", className)}\n    {...props}\n  >\n    <ScrollAreaPrimitive.Viewport className=\"h-full w-full rounded-[inherit]\">\n      {children}\n    </ScrollAreaPrimitive.Viewport>\n    <ScrollBar />\n    <ScrollAreaPrimitive.Corner />\n  </ScrollAreaPrimitive.Root>\n))\nScrollArea.displayName = ScrollAreaPrimitive.Root.displayName\n\nconst ScrollBar = React.forwardRef<\n  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,\n  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>\n>(({ className, orientation = \"vertical\", ...props }, ref) => (\n  <ScrollAreaPrimitive.ScrollAreaScrollbar\n    ref={ref}\n    orientation={orientation}\n    className={cn(\n      \"flex touch-none select-none transition-colors\",\n      orientation === \"vertical\" &&\n        \"h-full w-2.5 border-l border-l-transparent p-[1px]\",\n      orientation === \"horizontal\" &&\n        \"h-2.5 flex-col border-t border-t-transparent p-[1px]\",\n      className\n    )}\n    {...props}\n  >\n    <ScrollAreaPrimitive.ScrollAreaThumb className=\"relative flex-1 rounded-full bg-border\" />\n  </ScrollAreaPrimitive.ScrollAreaScrollbar>\n))\nScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName\n\nexport { ScrollArea, ScrollBar }\n","size_bytes":1642},"client/src/components/ui/select.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as SelectPrimitive from \"@radix-ui/react-select\"\nimport { Check, ChevronDown, ChevronUp } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Select = SelectPrimitive.Root\n\nconst SelectGroup = SelectPrimitive.Group\n\nconst SelectValue = SelectPrimitive.Value\n\nconst SelectTrigger = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <SelectPrimitive.Icon asChild>\n      <ChevronDown className=\"h-4 w-4 opacity-50\" />\n    </SelectPrimitive.Icon>\n  </SelectPrimitive.Trigger>\n))\nSelectTrigger.displayName = SelectPrimitive.Trigger.displayName\n\nconst SelectScrollUpButton = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.ScrollUpButton\n    ref={ref}\n    className={cn(\n      \"flex cursor-default items-center justify-center py-1\",\n      className\n    )}\n    {...props}\n  >\n    <ChevronUp className=\"h-4 w-4\" />\n  </SelectPrimitive.ScrollUpButton>\n))\nSelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName\n\nconst SelectScrollDownButton = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.ScrollDownButton\n    ref={ref}\n    className={cn(\n      \"flex cursor-default items-center justify-center py-1\",\n      className\n    )}\n    {...props}\n  >\n    <ChevronDown className=\"h-4 w-4\" />\n  </SelectPrimitive.ScrollDownButton>\n))\nSelectScrollDownButton.displayName =\n  SelectPrimitive.ScrollDownButton.displayName\n\nconst SelectContent = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>\n>(({ className, children, position = \"popper\", ...props }, ref) => (\n  <SelectPrimitive.Portal>\n    <SelectPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"relative z-50 max-h-[--radix-select-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-select-content-transform-origin]\",\n        position === \"popper\" &&\n          \"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1\",\n        className\n      )}\n      position={position}\n      {...props}\n    >\n      <SelectScrollUpButton />\n      <SelectPrimitive.Viewport\n        className={cn(\n          \"p-1\",\n          position === \"popper\" &&\n            \"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]\"\n        )}\n      >\n        {children}\n      </SelectPrimitive.Viewport>\n      <SelectScrollDownButton />\n    </SelectPrimitive.Content>\n  </SelectPrimitive.Portal>\n))\nSelectContent.displayName = SelectPrimitive.Content.displayName\n\nconst SelectLabel = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Label\n    ref={ref}\n    className={cn(\"py-1.5 pl-8 pr-2 text-sm font-semibold\", className)}\n    {...props}\n  />\n))\nSelectLabel.displayName = SelectPrimitive.Label.displayName\n\nconst SelectItem = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <SelectPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </SelectPrimitive.ItemIndicator>\n    </span>\n\n    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>\n  </SelectPrimitive.Item>\n))\nSelectItem.displayName = SelectPrimitive.Item.displayName\n\nconst SelectSeparator = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nSelectSeparator.displayName = SelectPrimitive.Separator.displayName\n\nexport {\n  Select,\n  SelectGroup,\n  SelectValue,\n  SelectTrigger,\n  SelectContent,\n  SelectLabel,\n  SelectItem,\n  SelectSeparator,\n  SelectScrollUpButton,\n  SelectScrollDownButton,\n}\n","size_bytes":5742},"client/src/components/ui/separator.tsx":{"content":"import * as React from \"react\"\nimport * as SeparatorPrimitive from \"@radix-ui/react-separator\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Separator = React.forwardRef<\n  React.ElementRef<typeof SeparatorPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>\n>(\n  (\n    { className, orientation = \"horizontal\", decorative = true, ...props },\n    ref\n  ) => (\n    <SeparatorPrimitive.Root\n      ref={ref}\n      decorative={decorative}\n      orientation={orientation}\n      className={cn(\n        \"shrink-0 bg-border\",\n        orientation === \"horizontal\" ? \"h-[1px] w-full\" : \"h-full w-[1px]\",\n        className\n      )}\n      {...props}\n    />\n  )\n)\nSeparator.displayName = SeparatorPrimitive.Root.displayName\n\nexport { Separator }\n","size_bytes":756},"client/src/components/ui/sheet.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as SheetPrimitive from \"@radix-ui/react-dialog\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Sheet = SheetPrimitive.Root\n\nconst SheetTrigger = SheetPrimitive.Trigger\n\nconst SheetClose = SheetPrimitive.Close\n\nconst SheetPortal = SheetPrimitive.Portal\n\nconst SheetOverlay = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <SheetPrimitive.Overlay\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n    ref={ref}\n  />\n))\nSheetOverlay.displayName = SheetPrimitive.Overlay.displayName\n\nconst sheetVariants = cva(\n  \"fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500\",\n  {\n    variants: {\n      side: {\n        top: \"inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top\",\n        bottom:\n          \"inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom\",\n        left: \"inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm\",\n        right:\n          \"inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm\",\n      },\n    },\n    defaultVariants: {\n      side: \"right\",\n    },\n  }\n)\n\ninterface SheetContentProps\n  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,\n    VariantProps<typeof sheetVariants> {}\n\nconst SheetContent = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Content>,\n  SheetContentProps\n>(({ side = \"right\", className, children, ...props }, ref) => (\n  <SheetPortal>\n    <SheetOverlay />\n    <SheetPrimitive.Content\n      ref={ref}\n      className={cn(sheetVariants({ side }), className)}\n      {...props}\n    >\n      {children}\n      <SheetPrimitive.Close className=\"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary\">\n        <X className=\"h-4 w-4\" />\n        <span className=\"sr-only\">Close</span>\n      </SheetPrimitive.Close>\n    </SheetPrimitive.Content>\n  </SheetPortal>\n))\nSheetContent.displayName = SheetPrimitive.Content.displayName\n\nconst SheetHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-2 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nSheetHeader.displayName = \"SheetHeader\"\n\nconst SheetFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nSheetFooter.displayName = \"SheetFooter\"\n\nconst SheetTitle = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <SheetPrimitive.Title\n    ref={ref}\n    className={cn(\"text-lg font-semibold text-foreground\", className)}\n    {...props}\n  />\n))\nSheetTitle.displayName = SheetPrimitive.Title.displayName\n\nconst SheetDescription = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <SheetPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nSheetDescription.displayName = SheetPrimitive.Description.displayName\n\nexport {\n  Sheet,\n  SheetPortal,\n  SheetOverlay,\n  SheetTrigger,\n  SheetClose,\n  SheetContent,\n  SheetHeader,\n  SheetFooter,\n  SheetTitle,\n  SheetDescription,\n}\n","size_bytes":4281},"client/src/components/ui/sidebar.tsx":{"content":"import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { VariantProps, cva } from \"class-variance-authority\"\nimport { PanelLeft } from \"lucide-react\"\n\nimport { useIsMobile } from \"@/hooks/use-mobile\"\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\nimport { Input } from \"@/components/ui/input\"\nimport { Separator } from \"@/components/ui/separator\"\nimport {\n  Sheet,\n  SheetContent,\n  SheetDescription,\n  SheetHeader,\n  SheetTitle,\n} from \"@/components/ui/sheet\"\nimport { Skeleton } from \"@/components/ui/skeleton\"\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipProvider,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\"\n\nconst SIDEBAR_COOKIE_NAME = \"sidebar_state\"\nconst SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7\nconst SIDEBAR_WIDTH = \"16rem\"\nconst SIDEBAR_WIDTH_MOBILE = \"18rem\"\nconst SIDEBAR_WIDTH_ICON = \"3rem\"\nconst SIDEBAR_KEYBOARD_SHORTCUT = \"b\"\n\ntype SidebarContextProps = {\n  state: \"expanded\" | \"collapsed\"\n  open: boolean\n  setOpen: (open: boolean) => void\n  openMobile: boolean\n  setOpenMobile: (open: boolean) => void\n  isMobile: boolean\n  toggleSidebar: () => void\n}\n\nconst SidebarContext = React.createContext<SidebarContextProps | null>(null)\n\nfunction useSidebar() {\n  const context = React.useContext(SidebarContext)\n  if (!context) {\n    throw new Error(\"useSidebar must be used within a SidebarProvider.\")\n  }\n\n  return context\n}\n\nconst SidebarProvider = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & {\n    defaultOpen?: boolean\n    open?: boolean\n    onOpenChange?: (open: boolean) => void\n  }\n>(\n  (\n    {\n      defaultOpen = true,\n      open: openProp,\n      onOpenChange: setOpenProp,\n      className,\n      style,\n      children,\n      ...props\n    },\n    ref\n  ) => {\n    const isMobile = useIsMobile()\n    const [openMobile, setOpenMobile] = React.useState(false)\n\n    // This is the internal state of the sidebar.\n    // We use openProp and setOpenProp for control from outside the component.\n    const [_open, _setOpen] = React.useState(defaultOpen)\n    const open = openProp ?? _open\n    const setOpen = React.useCallback(\n      (value: boolean | ((value: boolean) => boolean)) => {\n        const openState = typeof value === \"function\" ? value(open) : value\n        if (setOpenProp) {\n          setOpenProp(openState)\n        } else {\n          _setOpen(openState)\n        }\n\n        // This sets the cookie to keep the sidebar state.\n        document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`\n      },\n      [setOpenProp, open]\n    )\n\n    // Helper to toggle the sidebar.\n    const toggleSidebar = React.useCallback(() => {\n      return isMobile\n        ? setOpenMobile((open) => !open)\n        : setOpen((open) => !open)\n    }, [isMobile, setOpen, setOpenMobile])\n\n    // Adds a keyboard shortcut to toggle the sidebar.\n    React.useEffect(() => {\n      const handleKeyDown = (event: KeyboardEvent) => {\n        if (\n          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&\n          (event.metaKey || event.ctrlKey)\n        ) {\n          event.preventDefault()\n          toggleSidebar()\n        }\n      }\n\n      window.addEventListener(\"keydown\", handleKeyDown)\n      return () => window.removeEventListener(\"keydown\", handleKeyDown)\n    }, [toggleSidebar])\n\n    // We add a state so that we can do data-state=\"expanded\" or \"collapsed\".\n    // This makes it easier to style the sidebar with Tailwind classes.\n    const state = open ? \"expanded\" : \"collapsed\"\n\n    const contextValue = React.useMemo<SidebarContextProps>(\n      () => ({\n        state,\n        open,\n        setOpen,\n        isMobile,\n        openMobile,\n        setOpenMobile,\n        toggleSidebar,\n      }),\n      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]\n    )\n\n    return (\n      <SidebarContext.Provider value={contextValue}>\n        <TooltipProvider delayDuration={0}>\n          <div\n            style={\n              {\n                \"--sidebar-width\": SIDEBAR_WIDTH,\n                \"--sidebar-width-icon\": SIDEBAR_WIDTH_ICON,\n                ...style,\n              } as React.CSSProperties\n            }\n            className={cn(\n              \"group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar\",\n              className\n            )}\n            ref={ref}\n            {...props}\n          >\n            {children}\n          </div>\n        </TooltipProvider>\n      </SidebarContext.Provider>\n    )\n  }\n)\nSidebarProvider.displayName = \"SidebarProvider\"\n\nconst Sidebar = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & {\n    side?: \"left\" | \"right\"\n    variant?: \"sidebar\" | \"floating\" | \"inset\"\n    collapsible?: \"offcanvas\" | \"icon\" | \"none\"\n  }\n>(\n  (\n    {\n      side = \"left\",\n      variant = \"sidebar\",\n      collapsible = \"offcanvas\",\n      className,\n      children,\n      ...props\n    },\n    ref\n  ) => {\n    const { isMobile, state, openMobile, setOpenMobile } = useSidebar()\n\n    if (collapsible === \"none\") {\n      return (\n        <div\n          className={cn(\n            \"flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground\",\n            className\n          )}\n          ref={ref}\n          {...props}\n        >\n          {children}\n        </div>\n      )\n    }\n\n    if (isMobile) {\n      return (\n        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>\n          <SheetContent\n            data-sidebar=\"sidebar\"\n            data-mobile=\"true\"\n            className=\"w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden\"\n            style={\n              {\n                \"--sidebar-width\": SIDEBAR_WIDTH_MOBILE,\n              } as React.CSSProperties\n            }\n            side={side}\n          >\n            <SheetHeader className=\"sr-only\">\n              <SheetTitle>Sidebar</SheetTitle>\n              <SheetDescription>Displays the mobile sidebar.</SheetDescription>\n            </SheetHeader>\n            <div className=\"flex h-full w-full flex-col\">{children}</div>\n          </SheetContent>\n        </Sheet>\n      )\n    }\n\n    return (\n      <div\n        ref={ref}\n        className=\"group peer hidden text-sidebar-foreground md:block\"\n        data-state={state}\n        data-collapsible={state === \"collapsed\" ? collapsible : \"\"}\n        data-variant={variant}\n        data-side={side}\n      >\n        {/* This is what handles the sidebar gap on desktop */}\n        <div\n          className={cn(\n            \"relative w-[--sidebar-width] bg-transparent transition-[width] duration-200 ease-linear\",\n            \"group-data-[collapsible=offcanvas]:w-0\",\n            \"group-data-[side=right]:rotate-180\",\n            variant === \"floating\" || variant === \"inset\"\n              ? \"group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]\"\n              : \"group-data-[collapsible=icon]:w-[--sidebar-width-icon]\"\n          )}\n        />\n        <div\n          className={cn(\n            \"fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] duration-200 ease-linear md:flex\",\n            side === \"left\"\n              ? \"left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]\"\n              : \"right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]\",\n            // Adjust the padding for floating and inset variants.\n            variant === \"floating\" || variant === \"inset\"\n              ? \"p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]\"\n              : \"group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l\",\n            className\n          )}\n          {...props}\n        >\n          <div\n            data-sidebar=\"sidebar\"\n            className=\"flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow\"\n          >\n            {children}\n          </div>\n        </div>\n      </div>\n    )\n  }\n)\nSidebar.displayName = \"Sidebar\"\n\nconst SidebarTrigger = React.forwardRef<\n  React.ElementRef<typeof Button>,\n  React.ComponentProps<typeof Button>\n>(({ className, onClick, ...props }, ref) => {\n  const { toggleSidebar } = useSidebar()\n\n  return (\n    <Button\n      ref={ref}\n      data-sidebar=\"trigger\"\n      variant=\"ghost\"\n      size=\"icon\"\n      className={cn(\"h-7 w-7\", className)}\n      onClick={(event) => {\n        onClick?.(event)\n        toggleSidebar()\n      }}\n      {...props}\n    >\n      <PanelLeft />\n      <span className=\"sr-only\">Toggle Sidebar</span>\n    </Button>\n  )\n})\nSidebarTrigger.displayName = \"SidebarTrigger\"\n\nconst SidebarRail = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<\"button\">\n>(({ className, ...props }, ref) => {\n  const { toggleSidebar } = useSidebar()\n\n  return (\n    <button\n      ref={ref}\n      data-sidebar=\"rail\"\n      aria-label=\"Toggle Sidebar\"\n      tabIndex={-1}\n      onClick={toggleSidebar}\n      title=\"Toggle Sidebar\"\n      className={cn(\n        \"absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex\",\n        \"[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize\",\n        \"[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize\",\n        \"group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar\",\n        \"[[data-side=left][data-collapsible=offcanvas]_&]:-right-2\",\n        \"[[data-side=right][data-collapsible=offcanvas]_&]:-left-2\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarRail.displayName = \"SidebarRail\"\n\nconst SidebarInset = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"main\">\n>(({ className, ...props }, ref) => {\n  return (\n    <main\n      ref={ref}\n      className={cn(\n        \"relative flex w-full flex-1 flex-col bg-background\",\n        \"md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarInset.displayName = \"SidebarInset\"\n\nconst SidebarInput = React.forwardRef<\n  React.ElementRef<typeof Input>,\n  React.ComponentProps<typeof Input>\n>(({ className, ...props }, ref) => {\n  return (\n    <Input\n      ref={ref}\n      data-sidebar=\"input\"\n      className={cn(\n        \"h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarInput.displayName = \"SidebarInput\"\n\nconst SidebarHeader = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"header\"\n      className={cn(\"flex flex-col gap-2 p-2\", className)}\n      {...props}\n    />\n  )\n})\nSidebarHeader.displayName = \"SidebarHeader\"\n\nconst SidebarFooter = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"footer\"\n      className={cn(\"flex flex-col gap-2 p-2\", className)}\n      {...props}\n    />\n  )\n})\nSidebarFooter.displayName = \"SidebarFooter\"\n\nconst SidebarSeparator = React.forwardRef<\n  React.ElementRef<typeof Separator>,\n  React.ComponentProps<typeof Separator>\n>(({ className, ...props }, ref) => {\n  return (\n    <Separator\n      ref={ref}\n      data-sidebar=\"separator\"\n      className={cn(\"mx-2 w-auto bg-sidebar-border\", className)}\n      {...props}\n    />\n  )\n})\nSidebarSeparator.displayName = \"SidebarSeparator\"\n\nconst SidebarContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"content\"\n      className={cn(\n        \"flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarContent.displayName = \"SidebarContent\"\n\nconst SidebarGroup = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"group\"\n      className={cn(\"relative flex w-full min-w-0 flex-col p-2\", className)}\n      {...props}\n    />\n  )\n})\nSidebarGroup.displayName = \"SidebarGroup\"\n\nconst SidebarGroupLabel = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & { asChild?: boolean }\n>(({ className, asChild = false, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"div\"\n\n  return (\n    <Comp\n      ref={ref}\n      data-sidebar=\"group-label\"\n      className={cn(\n        \"flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0\",\n        \"group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarGroupLabel.displayName = \"SidebarGroupLabel\"\n\nconst SidebarGroupAction = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<\"button\"> & { asChild?: boolean }\n>(({ className, asChild = false, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"button\"\n\n  return (\n    <Comp\n      ref={ref}\n      data-sidebar=\"group-action\"\n      className={cn(\n        \"absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0\",\n        // Increases the hit area of the button on mobile.\n        \"after:absolute after:-inset-2 after:md:hidden\",\n        \"group-data-[collapsible=icon]:hidden\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarGroupAction.displayName = \"SidebarGroupAction\"\n\nconst SidebarGroupContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    data-sidebar=\"group-content\"\n    className={cn(\"w-full text-sm\", className)}\n    {...props}\n  />\n))\nSidebarGroupContent.displayName = \"SidebarGroupContent\"\n\nconst SidebarMenu = React.forwardRef<\n  HTMLUListElement,\n  React.ComponentProps<\"ul\">\n>(({ className, ...props }, ref) => (\n  <ul\n    ref={ref}\n    data-sidebar=\"menu\"\n    className={cn(\"flex w-full min-w-0 flex-col gap-1\", className)}\n    {...props}\n  />\n))\nSidebarMenu.displayName = \"SidebarMenu\"\n\nconst SidebarMenuItem = React.forwardRef<\n  HTMLLIElement,\n  React.ComponentProps<\"li\">\n>(({ className, ...props }, ref) => (\n  <li\n    ref={ref}\n    data-sidebar=\"menu-item\"\n    className={cn(\"group/menu-item relative\", className)}\n    {...props}\n  />\n))\nSidebarMenuItem.displayName = \"SidebarMenuItem\"\n\nconst sidebarMenuButtonVariants = cva(\n  \"peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0\",\n  {\n    variants: {\n      variant: {\n        default: \"hover:bg-sidebar-accent hover:text-sidebar-accent-foreground\",\n        outline:\n          \"bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]\",\n      },\n      size: {\n        default: \"h-8 text-sm\",\n        sm: \"h-7 text-xs\",\n        lg: \"h-12 text-sm group-data-[collapsible=icon]:!p-0\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nconst SidebarMenuButton = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<\"button\"> & {\n    asChild?: boolean\n    isActive?: boolean\n    tooltip?: string | React.ComponentProps<typeof TooltipContent>\n  } & VariantProps<typeof sidebarMenuButtonVariants>\n>(\n  (\n    {\n      asChild = false,\n      isActive = false,\n      variant = \"default\",\n      size = \"default\",\n      tooltip,\n      className,\n      ...props\n    },\n    ref\n  ) => {\n    const Comp = asChild ? Slot : \"button\"\n    const { isMobile, state } = useSidebar()\n\n    const button = (\n      <Comp\n        ref={ref}\n        data-sidebar=\"menu-button\"\n        data-size={size}\n        data-active={isActive}\n        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}\n        {...props}\n      />\n    )\n\n    if (!tooltip) {\n      return button\n    }\n\n    if (typeof tooltip === \"string\") {\n      tooltip = {\n        children: tooltip,\n      }\n    }\n\n    return (\n      <Tooltip>\n        <TooltipTrigger asChild>{button}</TooltipTrigger>\n        <TooltipContent\n          side=\"right\"\n          align=\"center\"\n          hidden={state !== \"collapsed\" || isMobile}\n          {...tooltip}\n        />\n      </Tooltip>\n    )\n  }\n)\nSidebarMenuButton.displayName = \"SidebarMenuButton\"\n\nconst SidebarMenuAction = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<\"button\"> & {\n    asChild?: boolean\n    showOnHover?: boolean\n  }\n>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"button\"\n\n  return (\n    <Comp\n      ref={ref}\n      data-sidebar=\"menu-action\"\n      className={cn(\n        \"absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0\",\n        // Increases the hit area of the button on mobile.\n        \"after:absolute after:-inset-2 after:md:hidden\",\n        \"peer-data-[size=sm]/menu-button:top-1\",\n        \"peer-data-[size=default]/menu-button:top-1.5\",\n        \"peer-data-[size=lg]/menu-button:top-2.5\",\n        \"group-data-[collapsible=icon]:hidden\",\n        showOnHover &&\n          \"group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarMenuAction.displayName = \"SidebarMenuAction\"\n\nconst SidebarMenuBadge = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    data-sidebar=\"menu-badge\"\n    className={cn(\n      \"pointer-events-none absolute right-1 flex h-5 min-w-5 select-none items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground\",\n      \"peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground\",\n      \"peer-data-[size=sm]/menu-button:top-1\",\n      \"peer-data-[size=default]/menu-button:top-1.5\",\n      \"peer-data-[size=lg]/menu-button:top-2.5\",\n      \"group-data-[collapsible=icon]:hidden\",\n      className\n    )}\n    {...props}\n  />\n))\nSidebarMenuBadge.displayName = \"SidebarMenuBadge\"\n\nconst SidebarMenuSkeleton = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & {\n    showIcon?: boolean\n  }\n>(({ className, showIcon = false, ...props }, ref) => {\n  // Random width between 50 to 90%.\n  const width = React.useMemo(() => {\n    return `${Math.floor(Math.random() * 40) + 50}%`\n  }, [])\n\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"menu-skeleton\"\n      className={cn(\"flex h-8 items-center gap-2 rounded-md px-2\", className)}\n      {...props}\n    >\n      {showIcon && (\n        <Skeleton\n          className=\"size-4 rounded-md\"\n          data-sidebar=\"menu-skeleton-icon\"\n        />\n      )}\n      <Skeleton\n        className=\"h-4 max-w-[--skeleton-width] flex-1\"\n        data-sidebar=\"menu-skeleton-text\"\n        style={\n          {\n            \"--skeleton-width\": width,\n          } as React.CSSProperties\n        }\n      />\n    </div>\n  )\n})\nSidebarMenuSkeleton.displayName = \"SidebarMenuSkeleton\"\n\nconst SidebarMenuSub = React.forwardRef<\n  HTMLUListElement,\n  React.ComponentProps<\"ul\">\n>(({ className, ...props }, ref) => (\n  <ul\n    ref={ref}\n    data-sidebar=\"menu-sub\"\n    className={cn(\n      \"mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5\",\n      \"group-data-[collapsible=icon]:hidden\",\n      className\n    )}\n    {...props}\n  />\n))\nSidebarMenuSub.displayName = \"SidebarMenuSub\"\n\nconst SidebarMenuSubItem = React.forwardRef<\n  HTMLLIElement,\n  React.ComponentProps<\"li\">\n>(({ ...props }, ref) => <li ref={ref} {...props} />)\nSidebarMenuSubItem.displayName = \"SidebarMenuSubItem\"\n\nconst SidebarMenuSubButton = React.forwardRef<\n  HTMLAnchorElement,\n  React.ComponentProps<\"a\"> & {\n    asChild?: boolean\n    size?: \"sm\" | \"md\"\n    isActive?: boolean\n  }\n>(({ asChild = false, size = \"md\", isActive, className, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"a\"\n\n  return (\n    <Comp\n      ref={ref}\n      data-sidebar=\"menu-sub-button\"\n      data-size={size}\n      data-active={isActive}\n      className={cn(\n        \"flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground\",\n        \"data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground\",\n        size === \"sm\" && \"text-xs\",\n        size === \"md\" && \"text-sm\",\n        \"group-data-[collapsible=icon]:hidden\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarMenuSubButton.displayName = \"SidebarMenuSubButton\"\n\nexport {\n  Sidebar,\n  SidebarContent,\n  SidebarFooter,\n  SidebarGroup,\n  SidebarGroupAction,\n  SidebarGroupContent,\n  SidebarGroupLabel,\n  SidebarHeader,\n  SidebarInput,\n  SidebarInset,\n  SidebarMenu,\n  SidebarMenuAction,\n  SidebarMenuBadge,\n  SidebarMenuButton,\n  SidebarMenuItem,\n  SidebarMenuSkeleton,\n  SidebarMenuSub,\n  SidebarMenuSubButton,\n  SidebarMenuSubItem,\n  SidebarProvider,\n  SidebarRail,\n  SidebarSeparator,\n  SidebarTrigger,\n  useSidebar,\n}\n","size_bytes":23567},"client/src/components/ui/skeleton.tsx":{"content":"import { cn } from \"@/lib/utils\"\n\nfunction Skeleton({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) {\n  return (\n    <div\n      className={cn(\"animate-pulse rounded-md bg-muted\", className)}\n      {...props}\n    />\n  )\n}\n\nexport { Skeleton }\n","size_bytes":261},"client/src/components/ui/slider.tsx":{"content":"import * as React from \"react\"\nimport * as SliderPrimitive from \"@radix-ui/react-slider\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Slider = React.forwardRef<\n  React.ElementRef<typeof SliderPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <SliderPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative flex w-full touch-none select-none items-center\",\n      className\n    )}\n    {...props}\n  >\n    <SliderPrimitive.Track className=\"relative h-2 w-full grow overflow-hidden rounded-full bg-secondary\">\n      <SliderPrimitive.Range className=\"absolute h-full bg-primary\" />\n    </SliderPrimitive.Track>\n    <SliderPrimitive.Thumb className=\"block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\" />\n  </SliderPrimitive.Root>\n))\nSlider.displayName = SliderPrimitive.Root.displayName\n\nexport { Slider }\n","size_bytes":1077},"client/src/components/ui/switch.tsx":{"content":"import * as React from \"react\"\nimport * as SwitchPrimitives from \"@radix-ui/react-switch\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Switch = React.forwardRef<\n  React.ElementRef<typeof SwitchPrimitives.Root>,\n  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>\n>(({ className, ...props }, ref) => (\n  <SwitchPrimitives.Root\n    className={cn(\n      \"peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input\",\n      className\n    )}\n    {...props}\n    ref={ref}\n  >\n    <SwitchPrimitives.Thumb\n      className={cn(\n        \"pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0\"\n      )}\n    />\n  </SwitchPrimitives.Root>\n))\nSwitch.displayName = SwitchPrimitives.Root.displayName\n\nexport { Switch }\n","size_bytes":1139},"client/src/components/ui/table.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Table = React.forwardRef<\n  HTMLTableElement,\n  React.HTMLAttributes<HTMLTableElement>\n>(({ className, ...props }, ref) => (\n  <div className=\"relative w-full overflow-auto\">\n    <table\n      ref={ref}\n      className={cn(\"w-full caption-bottom text-sm\", className)}\n      {...props}\n    />\n  </div>\n))\nTable.displayName = \"Table\"\n\nconst TableHeader = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <thead ref={ref} className={cn(\"[&_tr]:border-b\", className)} {...props} />\n))\nTableHeader.displayName = \"TableHeader\"\n\nconst TableBody = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <tbody\n    ref={ref}\n    className={cn(\"[&_tr:last-child]:border-0\", className)}\n    {...props}\n  />\n))\nTableBody.displayName = \"TableBody\"\n\nconst TableFooter = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <tfoot\n    ref={ref}\n    className={cn(\n      \"border-t bg-muted/50 font-medium [&>tr]:last:border-b-0\",\n      className\n    )}\n    {...props}\n  />\n))\nTableFooter.displayName = \"TableFooter\"\n\nconst TableRow = React.forwardRef<\n  HTMLTableRowElement,\n  React.HTMLAttributes<HTMLTableRowElement>\n>(({ className, ...props }, ref) => (\n  <tr\n    ref={ref}\n    className={cn(\n      \"border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted\",\n      className\n    )}\n    {...props}\n  />\n))\nTableRow.displayName = \"TableRow\"\n\nconst TableHead = React.forwardRef<\n  HTMLTableCellElement,\n  React.ThHTMLAttributes<HTMLTableCellElement>\n>(({ className, ...props }, ref) => (\n  <th\n    ref={ref}\n    className={cn(\n      \"h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0\",\n      className\n    )}\n    {...props}\n  />\n))\nTableHead.displayName = \"TableHead\"\n\nconst TableCell = React.forwardRef<\n  HTMLTableCellElement,\n  React.TdHTMLAttributes<HTMLTableCellElement>\n>(({ className, ...props }, ref) => (\n  <td\n    ref={ref}\n    className={cn(\"p-4 align-middle [&:has([role=checkbox])]:pr-0\", className)}\n    {...props}\n  />\n))\nTableCell.displayName = \"TableCell\"\n\nconst TableCaption = React.forwardRef<\n  HTMLTableCaptionElement,\n  React.HTMLAttributes<HTMLTableCaptionElement>\n>(({ className, ...props }, ref) => (\n  <caption\n    ref={ref}\n    className={cn(\"mt-4 text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nTableCaption.displayName = \"TableCaption\"\n\nexport {\n  Table,\n  TableHeader,\n  TableBody,\n  TableFooter,\n  TableHead,\n  TableRow,\n  TableCell,\n  TableCaption,\n}\n","size_bytes":2765},"client/src/components/ui/tabs.tsx":{"content":"import * as React from \"react\"\nimport * as TabsPrimitive from \"@radix-ui/react-tabs\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Tabs = TabsPrimitive.Root\n\nconst TabsList = React.forwardRef<\n  React.ElementRef<typeof TabsPrimitive.List>,\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>\n>(({ className, ...props }, ref) => (\n  <TabsPrimitive.List\n    ref={ref}\n    className={cn(\n      \"inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\nTabsList.displayName = TabsPrimitive.List.displayName\n\nconst TabsTrigger = React.forwardRef<\n  React.ElementRef<typeof TabsPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>\n>(({ className, ...props }, ref) => (\n  <TabsPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm\",\n      className\n    )}\n    {...props}\n  />\n))\nTabsTrigger.displayName = TabsPrimitive.Trigger.displayName\n\nconst TabsContent = React.forwardRef<\n  React.ElementRef<typeof TabsPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <TabsPrimitive.Content\n    ref={ref}\n    className={cn(\n      \"mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\",\n      className\n    )}\n    {...props}\n  />\n))\nTabsContent.displayName = TabsPrimitive.Content.displayName\n\nexport { Tabs, TabsList, TabsTrigger, TabsContent }\n","size_bytes":1883},"client/src/components/ui/textarea.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Textarea = React.forwardRef<\n  HTMLTextAreaElement,\n  React.ComponentProps<\"textarea\">\n>(({ className, ...props }, ref) => {\n  return (\n    <textarea\n      className={cn(\n        \"flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n        className\n      )}\n      ref={ref}\n      {...props}\n    />\n  )\n})\nTextarea.displayName = \"Textarea\"\n\nexport { Textarea }\n","size_bytes":689},"client/src/components/ui/toast.tsx":{"content":"import * as React from \"react\"\nimport * as ToastPrimitives from \"@radix-ui/react-toast\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ToastProvider = ToastPrimitives.Provider\n\nconst ToastViewport = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Viewport>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Viewport\n    ref={ref}\n    className={cn(\n      \"fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]\",\n      className\n    )}\n    {...props}\n  />\n))\nToastViewport.displayName = ToastPrimitives.Viewport.displayName\n\nconst toastVariants = cva(\n  \"group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full\",\n  {\n    variants: {\n      variant: {\n        default: \"border bg-background text-foreground\",\n        destructive:\n          \"destructive group border-destructive bg-destructive text-destructive-foreground\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nconst Toast = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Root>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &\n    VariantProps<typeof toastVariants>\n>(({ className, variant, ...props }, ref) => {\n  return (\n    <ToastPrimitives.Root\n      ref={ref}\n      className={cn(toastVariants({ variant }), className)}\n      {...props}\n    />\n  )\n})\nToast.displayName = ToastPrimitives.Root.displayName\n\nconst ToastAction = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Action>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Action\n    ref={ref}\n    className={cn(\n      \"inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive\",\n      className\n    )}\n    {...props}\n  />\n))\nToastAction.displayName = ToastPrimitives.Action.displayName\n\nconst ToastClose = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Close>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Close\n    ref={ref}\n    className={cn(\n      \"absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600\",\n      className\n    )}\n    toast-close=\"\"\n    {...props}\n  >\n    <X className=\"h-4 w-4\" />\n  </ToastPrimitives.Close>\n))\nToastClose.displayName = ToastPrimitives.Close.displayName\n\nconst ToastTitle = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Title>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Title\n    ref={ref}\n    className={cn(\"text-sm font-semibold\", className)}\n    {...props}\n  />\n))\nToastTitle.displayName = ToastPrimitives.Title.displayName\n\nconst ToastDescription = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Description>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Description\n    ref={ref}\n    className={cn(\"text-sm opacity-90\", className)}\n    {...props}\n  />\n))\nToastDescription.displayName = ToastPrimitives.Description.displayName\n\ntype ToastProps = React.ComponentPropsWithoutRef<typeof Toast>\n\ntype ToastActionElement = React.ReactElement<typeof ToastAction>\n\nexport {\n  type ToastProps,\n  type ToastActionElement,\n  ToastProvider,\n  ToastViewport,\n  Toast,\n  ToastTitle,\n  ToastDescription,\n  ToastClose,\n  ToastAction,\n}\n","size_bytes":4845},"client/src/components/ui/toaster.tsx":{"content":"import { useToast } from \"@/hooks/use-toast\"\nimport {\n  Toast,\n  ToastClose,\n  ToastDescription,\n  ToastProvider,\n  ToastTitle,\n  ToastViewport,\n} from \"@/components/ui/toast\"\n\nexport function Toaster() {\n  const { toasts } = useToast()\n\n  return (\n    <ToastProvider>\n      {toasts.map(function ({ id, title, description, action, ...props }) {\n        return (\n          <Toast key={id} {...props}>\n            <div className=\"grid gap-1\">\n              {title && <ToastTitle>{title}</ToastTitle>}\n              {description && (\n                <ToastDescription>{description}</ToastDescription>\n              )}\n            </div>\n            {action}\n            <ToastClose />\n          </Toast>\n        )\n      })}\n      <ToastViewport />\n    </ToastProvider>\n  )\n}\n","size_bytes":772},"client/src/components/ui/toggle-group.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as ToggleGroupPrimitive from \"@radix-ui/react-toggle-group\"\nimport { type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\nimport { toggleVariants } from \"@/components/ui/toggle\"\n\nconst ToggleGroupContext = React.createContext<\n  VariantProps<typeof toggleVariants>\n>({\n  size: \"default\",\n  variant: \"default\",\n})\n\nconst ToggleGroup = React.forwardRef<\n  React.ElementRef<typeof ToggleGroupPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &\n    VariantProps<typeof toggleVariants>\n>(({ className, variant, size, children, ...props }, ref) => (\n  <ToggleGroupPrimitive.Root\n    ref={ref}\n    className={cn(\"flex items-center justify-center gap-1\", className)}\n    {...props}\n  >\n    <ToggleGroupContext.Provider value={{ variant, size }}>\n      {children}\n    </ToggleGroupContext.Provider>\n  </ToggleGroupPrimitive.Root>\n))\n\nToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName\n\nconst ToggleGroupItem = React.forwardRef<\n  React.ElementRef<typeof ToggleGroupPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &\n    VariantProps<typeof toggleVariants>\n>(({ className, children, variant, size, ...props }, ref) => {\n  const context = React.useContext(ToggleGroupContext)\n\n  return (\n    <ToggleGroupPrimitive.Item\n      ref={ref}\n      className={cn(\n        toggleVariants({\n          variant: context.variant || variant,\n          size: context.size || size,\n        }),\n        className\n      )}\n      {...props}\n    >\n      {children}\n    </ToggleGroupPrimitive.Item>\n  )\n})\n\nToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName\n\nexport { ToggleGroup, ToggleGroupItem }\n","size_bytes":1753},"client/src/components/ui/toggle.tsx":{"content":"import * as React from \"react\"\nimport * as TogglePrimitive from \"@radix-ui/react-toggle\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst toggleVariants = cva(\n  \"inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 gap-2\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-transparent\",\n        outline:\n          \"border border-input bg-transparent hover:bg-accent hover:text-accent-foreground\",\n      },\n      size: {\n        default: \"h-10 px-3 min-w-10\",\n        sm: \"h-9 px-2.5 min-w-9\",\n        lg: \"h-11 px-5 min-w-11\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nconst Toggle = React.forwardRef<\n  React.ElementRef<typeof TogglePrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &\n    VariantProps<typeof toggleVariants>\n>(({ className, variant, size, ...props }, ref) => (\n  <TogglePrimitive.Root\n    ref={ref}\n    className={cn(toggleVariants({ variant, size, className }))}\n    {...props}\n  />\n))\n\nToggle.displayName = TogglePrimitive.Root.displayName\n\nexport { Toggle, toggleVariants }\n","size_bytes":1527},"client/src/components/ui/tooltip.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as TooltipPrimitive from \"@radix-ui/react-tooltip\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst TooltipProvider = TooltipPrimitive.Provider\n\nconst Tooltip = TooltipPrimitive.Root\n\nconst TooltipTrigger = TooltipPrimitive.Trigger\n\nconst TooltipContent = React.forwardRef<\n  React.ElementRef<typeof TooltipPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>\n>(({ className, sideOffset = 4, ...props }, ref) => (\n  <TooltipPrimitive.Content\n    ref={ref}\n    sideOffset={sideOffset}\n    className={cn(\n      \"z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-tooltip-content-transform-origin]\",\n      className\n    )}\n    {...props}\n  />\n))\nTooltipContent.displayName = TooltipPrimitive.Content.displayName\n\nexport { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }\n","size_bytes":1209},"client/src/lib/SemanticAnalyzer.ts":{"content":"\n/**\n * Gelişmiş Anlamlandırma Sistemi\n * Kullanıcının ne demek istediğini derin analiz ederek anlayan sistem\n */\n\nimport { TurkishDictionary } from './TurkishDictionary';\nimport { EnhancedMemorySystem } from './EnhancedMemorySystem';\n\nexport interface SemanticContext {\n  intent: string;\n  entities: Entity[];\n  relationships: Relationship[];\n  confidence: number;\n  contextualClues: string[];\n  inferredMeaning: string;\n  possibleResponses: string[];\n}\n\nexport interface Entity {\n  text: string;\n  type: 'person' | 'place' | 'thing' | 'concept' | 'action' | 'quality' | 'time' | 'emotion';\n  role: 'subject' | 'object' | 'predicate' | 'modifier' | 'context';\n  confidence: number;\n}\n\nexport interface Relationship {\n  source: string;\n  target: string;\n  type: 'causes' | 'requires' | 'is_type_of' | 'located_in' | 'belongs_to' | 'describes' | 'temporal';\n  strength: number;\n}\n\nexport interface TrainingPair {\n  id: string;\n  input: string;\n  output: string;\n  category: string;\n  timestamp: number;\n  usageCount: number;\n}\n\nexport class SemanticAnalyzer {\n  private dictionary: TurkishDictionary | null;\n  private memorySystem: EnhancedMemorySystem;\n  private contextPatterns: Map<string, RegExp>;\n  private intentClassifiers: Map<string, (text: string) => number>;\n  private semanticCache: Map<string, SemanticContext>;\n\n  constructor(dictionary: TurkishDictionary | null, memorySystem: EnhancedMemorySystem) {\n    this.dictionary = dictionary || null as any;\n    this.memorySystem = memorySystem;\n    this.contextPatterns = new Map();\n    this.intentClassifiers = new Map();\n    this.semanticCache = new Map();\n    \n    this.initializePatterns();\n    this.initializeIntentClassifiers();\n  }\n\n  /**\n   * Ana anlamlandırma fonksiyonu\n   */\n  public async analyzeUserIntent(\n    userInput: string, \n    trainingData: TrainingPair[] = [], \n    conversationHistory: string[] = []\n  ): Promise<SemanticContext> {\n    \n    // Cache kontrolü\n    const cacheKey = this.generateCacheKey(userInput, conversationHistory);\n    if (this.semanticCache.has(cacheKey)) {\n      return this.semanticCache.get(cacheKey)!;\n    }\n\n    const normalizedInput = this.normalizeInput(userInput);\n    \n    // 1. Temel linguistic analiz\n    const linguisticAnalysis = this.performLinguisticAnalysis(normalizedInput);\n    \n    // 2. Bağlamsal ipuçlarını topla\n    const contextualClues = this.extractContextualClues(normalizedInput, conversationHistory);\n    \n    // 3. Varlık tanıma ve ilişki çıkarımı\n    const entities = this.extractEntities(normalizedInput, linguisticAnalysis);\n    const relationships = this.inferRelationships(entities, contextualClues);\n    \n    // 4. Niyet sınıflandırması\n    const intent = this.classifyIntent(normalizedInput, entities, relationships);\n    \n    // 5. Bilgi kaynakları arama\n    const knowledgeResults = await this.searchKnowledgeSources(\n      normalizedInput, entities, intent, trainingData\n    );\n    \n    // 6. Anlamsal çıkarım\n    const inferredMeaning = this.inferMeaning(\n      intent, entities, relationships, knowledgeResults, contextualClues\n    );\n    \n    // 7. Olası yanıtları oluştur\n    const possibleResponses = this.generatePossibleResponses(\n      inferredMeaning, knowledgeResults, intent\n    );\n    \n    // 8. Güven skoru hesapla\n    const confidence = this.calculateConfidence(\n      intent, entities, knowledgeResults, contextualClues\n    );\n\n    const semanticContext: SemanticContext = {\n      intent,\n      entities,\n      relationships,\n      confidence,\n      contextualClues,\n      inferredMeaning,\n      possibleResponses\n    };\n\n    // Cache'e kaydet\n    this.semanticCache.set(cacheKey, semanticContext);\n    \n    return semanticContext;\n  }\n\n  /**\n   * Dilbilimsel analiz\n   */\n  private performLinguisticAnalysis(input: string): any {\n    const words = input.toLowerCase().split(/\\s+/);\n    const analysis = {\n      words: [],\n      syntax: {\n        subject: null,\n        predicate: null,\n        object: null,\n        modifiers: []\n      },\n      morphology: [],\n      semanticFields: []\n    };\n\n    words.forEach((word, index) => {\n      const dictionaryEntry = this.dictionary ? this.dictionary.getWord(word) : null;\n      const wordAnalysis = {\n        text: word,\n        position: index,\n        type: dictionaryEntry?.type || 'unknown',\n        meanings: dictionaryEntry?.meaning || [],\n        root: this.extractRoot(word),\n        suffixes: this.extractSuffixes(word),\n        semanticWeight: this.calculateSemanticWeight(word, dictionaryEntry)\n      };\n\n      analysis.words.push(wordAnalysis);\n\n      // Sözcüksel rolleri belirle\n      if (dictionaryEntry) {\n        switch (dictionaryEntry.type) {\n          case 'isim':\n            if (!analysis.syntax.subject && index < words.length / 2) {\n              analysis.syntax.subject = word;\n            } else if (!analysis.syntax.object) {\n              analysis.syntax.object = word;\n            }\n            break;\n          case 'fiil':\n            analysis.syntax.predicate = word;\n            break;\n          case 'sıfat':\n            analysis.syntax.modifiers.push(word);\n            break;\n        }\n      }\n    });\n\n    return analysis;\n  }\n\n  /**\n   * Bağlamsal ipuçları çıkarımı\n   */\n  private extractContextualClues(input: string, history: string[]): string[] {\n    const clues: string[] = [];\n    \n    // Zaman ifadeleri\n    const timePatterns = [\n      /dün|bugün|yarın|geçen|önce|sonra|şimdi|henüz|hâlâ/g,\n      /sabah|öğle|akşam|gece|sabahleyin/g,\n      /hafta|ay|yıl|gün|saat|dakika/g\n    ];\n    \n    timePatterns.forEach(pattern => {\n      const matches = input.match(pattern);\n      if (matches) {\n        clues.push(...matches.map(m => `time:${m}`));\n      }\n    });\n\n    // Duygusal ifadeler\n    const emotionPatterns = [\n      /mutlu|üzgün|kızgın|sevinçli|endişeli|heyecanlı/g,\n      /seviyorum|nefret|beğeniyorum|hoşlanıyorum/g\n    ];\n    \n    emotionPatterns.forEach(pattern => {\n      const matches = input.match(pattern);\n      if (matches) {\n        clues.push(...matches.map(m => `emotion:${m}`));\n      }\n    });\n\n    // Referanslar (bu, şu, o)\n    if (/\\b(bu|şu|o)\\b/.test(input)) {\n      clues.push('reference:demonstrative');\n      \n      // Son konuşmalardan referans bul\n      if (history.length > 0) {\n        const lastTopic = this.extractMainTopic(history[history.length - 1]);\n        if (lastTopic) {\n          clues.push(`reference:${lastTopic}`);\n        }\n      }\n    }\n\n    // Soru kalıpları\n    const questionWords = ['ne', 'kim', 'nerede', 'nasıl', 'neden', 'hangi', 'kaç'];\n    questionWords.forEach(qword => {\n      if (input.includes(qword)) {\n        clues.push(`question:${qword}`);\n      }\n    });\n\n    return clues;\n  }\n\n  /**\n   * Varlık çıkarımı (Named Entity Recognition)\n   */\n  private extractEntities(input: string, linguisticAnalysis: any): Entity[] {\n    const entities: Entity[] = [];\n    const words = input.split(/\\s+/);\n\n    linguisticAnalysis.words.forEach((wordInfo: any, index: number) => {\n      const { text, type, meanings, semanticWeight } = wordInfo;\n      \n      // Varlık tipini belirle\n      let entityType: Entity['type'] = 'concept';\n      let role: Entity['role'] = 'context';\n      \n      // Büyük harfle başlayan kelimeler (özel isimler)\n      if (/^[A-ZÇĞIİÖŞÜ]/.test(words[index])) {\n        entityType = this.classifyProperNoun(text);\n      } else {\n        // Sözlük tipine göre varlık tipi\n        switch (type) {\n          case 'isim':\n            entityType = 'thing';\n            role = index < words.length / 2 ? 'subject' : 'object';\n            break;\n          case 'fiil':\n            entityType = 'action';\n            role = 'predicate';\n            break;\n          case 'sıfat':\n            entityType = 'quality';\n            role = 'modifier';\n            break;\n          case 'zamir':\n            entityType = 'person';\n            role = 'subject';\n            break;\n        }\n      }\n\n      // Duygusal kelimeler\n      if (this.isEmotionalWord(text)) {\n        entityType = 'emotion';\n      }\n\n      // Zaman ifadeleri\n      if (this.isTimeExpression(text)) {\n        entityType = 'time';\n      }\n\n      entities.push({\n        text,\n        type: entityType,\n        role,\n        confidence: Math.min(1, semanticWeight + (meanings.length * 0.1))\n      });\n    });\n\n    return entities.filter(e => e.confidence > 0.3);\n  }\n\n  /**\n   * İlişki çıkarımı\n   */\n  private inferRelationships(entities: Entity[], contextualClues: string[]): Relationship[] {\n    const relationships: Relationship[] = [];\n    \n    // Subject-Predicate-Object ilişkileri\n    const subject = entities.find(e => e.role === 'subject');\n    const predicate = entities.find(e => e.role === 'predicate');\n    const object = entities.find(e => e.role === 'object');\n    \n    if (subject && predicate) {\n      relationships.push({\n        source: subject.text,\n        target: predicate.text,\n        type: 'requires',\n        strength: 0.8\n      });\n    }\n    \n    if (predicate && object) {\n      relationships.push({\n        source: predicate.text,\n        target: object.text,\n        type: 'requires',\n        strength: 0.7\n      });\n    }\n\n    // Modifiers ile ana varlıklar arası ilişki\n    const modifiers = entities.filter(e => e.role === 'modifier');\n    const mainEntities = entities.filter(e => e.role !== 'modifier');\n    \n    modifiers.forEach(modifier => {\n      mainEntities.forEach(entity => {\n        relationships.push({\n          source: modifier.text,\n          target: entity.text,\n          type: 'describes',\n          strength: 0.6\n        });\n      });\n    });\n\n    // Bağlamsal ipuçlarına dayalı ilişkiler\n    contextualClues.forEach(clue => {\n      if (clue.startsWith('time:')) {\n        const timeEntity = clue.split(':')[1];\n        entities.forEach(entity => {\n          if (entity.type !== 'time') {\n            relationships.push({\n              source: timeEntity,\n              target: entity.text,\n              type: 'temporal',\n              strength: 0.5\n            });\n          }\n        });\n      }\n    });\n\n    return relationships;\n  }\n\n  /**\n   * Niyet sınıflandırması\n   */\n  private classifyIntent(\n    input: string, \n    entities: Entity[], \n    relationships: Relationship[]\n  ): string {\n    let maxScore = 0;\n    let bestIntent = 'unknown';\n\n    this.intentClassifiers.forEach((classifier, intent) => {\n      const score = classifier(input);\n      if (score > maxScore) {\n        maxScore = score;\n        bestIntent = intent;\n      }\n    });\n\n    // Varlık tipelerine göre niyet düzeltmesi\n    const hasQuestion = entities.some(e => \n      ['ne', 'kim', 'nerede', 'nasıl', 'neden'].includes(e.text)\n    );\n    \n    if (hasQuestion && bestIntent === 'unknown') {\n      bestIntent = 'information_request';\n    }\n\n    // Duygusal varlıklar varsa\n    const hasEmotion = entities.some(e => e.type === 'emotion');\n    if (hasEmotion) {\n      bestIntent = bestIntent === 'unknown' ? 'emotional_expression' : bestIntent;\n    }\n\n    return bestIntent;\n  }\n\n  /**\n   * Bilgi kaynaklarında arama\n   */\n  private async searchKnowledgeSources(\n    input: string,\n    entities: Entity[],\n    intent: string,\n    trainingData: TrainingPair[]\n  ): Promise<{\n    trainingMatches: TrainingPair[];\n    dictionaryMatches: any[];\n    memoryMatches: any[];\n    directAnswer: string | null;\n  }> {\n    \n    // Eğitim verilerinde arama\n    const trainingMatches = this.searchTrainingData(input, entities, trainingData);\n    \n    // Sözlük araması\n    const dictionaryMatches = this.searchDictionary(entities);\n    \n    // Bellek araması\n    const memoryMatches = this.memorySystem.findSimilarMemories(input, 5);\n    \n    // Direkt cevap arama\n    const directAnswer = this.findDirectAnswer(input, trainingMatches, entities);\n\n    return {\n      trainingMatches,\n      dictionaryMatches,\n      memoryMatches,\n      directAnswer\n    };\n  }\n\n  /**\n   * Eğitim verilerinde akıllı arama\n   */\n  private searchTrainingData(\n    input: string, \n    entities: Entity[], \n    trainingData: TrainingPair[]\n  ): TrainingPair[] {\n    const inputWords = input.toLowerCase().split(/\\s+/);\n    const entityTexts = entities.map(e => e.text.toLowerCase());\n    \n    return trainingData\n      .map(pair => {\n        const pairWords = pair.input.toLowerCase().split(/\\s+/);\n        \n        // Direkt eşleşme\n        if (pair.input.toLowerCase() === input.toLowerCase()) {\n          return { pair, score: 1.0 };\n        }\n        \n        // Kelime bazlı benzerlik\n        const wordMatches = inputWords.filter(word => pairWords.includes(word)).length;\n        const wordScore = wordMatches / Math.max(inputWords.length, pairWords.length);\n        \n        // Varlık bazlı benzerlik\n        const entityMatches = entityTexts.filter(entity => \n          pair.input.toLowerCase().includes(entity)\n        ).length;\n        const entityScore = entityTexts.length > 0 ? entityMatches / entityTexts.length : 0;\n        \n        // Semantic benzerlik\n        const semanticScore = this.calculateSemanticSimilarity(input, pair.input);\n        \n        const totalScore = (wordScore * 0.4) + (entityScore * 0.3) + (semanticScore * 0.3);\n        \n        return { pair, score: totalScore };\n      })\n      .filter(item => item.score > 0.2)\n      .sort((a, b) => b.score - a.score)\n      .slice(0, 3)\n      .map(item => item.pair);\n  }\n\n  /**\n   * Sözlük araması\n   */\n  private searchDictionary(entities: Entity[]): any[] {\n    const matches: any[] = [];\n    \n    entities.forEach(entity => {\n      const entry = this.dictionary.getWord(entity.text);\n      if (entry) {\n        matches.push({\n          word: entity.text,\n          entry,\n          relevance: entity.confidence\n        });\n      }\n    });\n    \n    return matches.sort((a, b) => b.relevance - a.relevance);\n  }\n\n  /**\n   * Direkt cevap bulma\n   */\n  private findDirectAnswer(\n    input: string, \n    trainingMatches: TrainingPair[], \n    entities: Entity[]\n  ): string | null {\n    \n    // En iyi eşleşme varsa\n    if (trainingMatches.length > 0) {\n      const bestMatch = trainingMatches[0];\n      const similarity = this.calculateSemanticSimilarity(input, bestMatch.input);\n      \n      if (similarity > 0.8) {\n        return bestMatch.output;\n      }\n    }\n\n    // Sözlük tanımları için\n    const questionEntity = entities.find(e => \n      ['ne', 'nedir', 'kim', 'kimdir'].includes(e.text)\n    );\n    \n    if (questionEntity) {\n      const targetWord = entities.find(e => \n        e.type === 'thing' || e.type === 'concept' || e.type === 'person'\n      );\n      \n      if (targetWord) {\n        const entry = this.dictionary.getWord(targetWord.text);\n        if (entry) {\n          return `${targetWord.text}: ${entry.meaning[0]}`;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Anlam çıkarımı\n   */\n  private inferMeaning(\n    intent: string,\n    entities: Entity[],\n    relationships: Relationship[],\n    knowledgeResults: any,\n    contextualClues: string[]\n  ): string {\n    \n    // Direkt cevap varsa\n    if (knowledgeResults.directAnswer) {\n      return knowledgeResults.directAnswer;\n    }\n\n    // Intent bazlı çıkarım\n    switch (intent) {\n      case 'information_request':\n        return this.generateInformationResponse(entities, knowledgeResults);\n      \n      case 'greeting':\n        return this.generateGreetingResponse(contextualClues);\n      \n      case 'emotional_expression':\n        return this.generateEmotionalResponse(entities);\n      \n      case 'definition_request':\n        return this.generateDefinitionResponse(entities, knowledgeResults);\n      \n      default:\n        return this.generateGenericResponse(entities, relationships, knowledgeResults);\n    }\n  }\n\n  /**\n   * Bilgi isteği yanıtı\n   */\n  private generateInformationResponse(entities: Entity[], knowledgeResults: any): string {\n    if (knowledgeResults.trainingMatches.length > 0) {\n      return knowledgeResults.trainingMatches[0].output;\n    }\n    \n    if (knowledgeResults.memoryMatches.length > 0) {\n      return knowledgeResults.memoryMatches[0].content;\n    }\n    \n    const mainEntity = entities.find(e => e.type === 'thing' || e.type === 'concept');\n    if (mainEntity) {\n      return `${mainEntity.text} hakkında daha fazla bilgi verebilir misiniz?`;\n    }\n    \n    return \"Bu konu hakkında daha detaylı bilgi verebilir misiniz?\";\n  }\n\n  /**\n   * Selamlama yanıtı\n   */\n  private generateGreetingResponse(contextualClues: string[]): string {\n    const timeClue = contextualClues.find(c => c.startsWith('time:'));\n    \n    if (timeClue?.includes('sabah')) {\n      return \"Günaydın! Size nasıl yardımcı olabilirim?\";\n    } else if (timeClue?.includes('akşam')) {\n      return \"İyi akşamlar! Ne yapabilirim sizin için?\";\n    }\n    \n    return \"Merhaba! Size nasıl yardımcı olabilirim?\";\n  }\n\n  /**\n   * Duygusal ifade yanıtı\n   */\n  private generateEmotionalResponse(entities: Entity[]): string {\n    const emotion = entities.find(e => e.type === 'emotion');\n    \n    if (emotion) {\n      const positiveEmotions = ['mutlu', 'sevinçli', 'heyecanlı'];\n      const negativeEmotions = ['üzgün', 'kızgın', 'endişeli'];\n      \n      if (positiveEmotions.includes(emotion.text)) {\n        return \"Bu harika! Mutluluğunuza ortak olmak güzel. 😊\";\n      } else if (negativeEmotions.includes(emotion.text)) {\n        return \"Üzgünüm, böyle hissediyorsunuz. Size nasıl yardımcı olabilirim? 🤗\";\n      }\n    }\n    \n    return \"Duygularınızı anlıyorum. Daha fazlasını anlatmak ister misiniz?\";\n  }\n\n  /**\n   * Tanım isteği yanıtı\n   */\n  private generateDefinitionResponse(entities: Entity[], knowledgeResults: any): string {\n    if (knowledgeResults.dictionaryMatches.length > 0) {\n      const match = knowledgeResults.dictionaryMatches[0];\n      return `${match.word}: ${match.entry.meaning[0]}`;\n    }\n    \n    const targetEntity = entities.find(e => e.type === 'thing' || e.type === 'concept');\n    if (targetEntity) {\n      return `\"${targetEntity.text}\" kelimesinin tanımını sözlükte bulamadım. Bana öğretebilir misiniz?`;\n    }\n    \n    return \"Hangi kelimenin tanımını istiyorsunuz?\";\n  }\n\n  /**\n   * Genel yanıt\n   */\n  private generateGenericResponse(\n    entities: Entity[], \n    relationships: Relationship[], \n    knowledgeResults: any\n  ): string {\n    \n    if (knowledgeResults.trainingMatches.length > 0) {\n      return knowledgeResults.trainingMatches[0].output;\n    }\n    \n    if (knowledgeResults.memoryMatches.length > 0) {\n      return knowledgeResults.memoryMatches[0].content;\n    }\n    \n    const mainEntities = entities.filter(e => e.confidence > 0.6);\n    if (mainEntities.length > 0) {\n      const entityNames = mainEntities.map(e => e.text).join(', ');\n      return `${entityNames} hakkında konuşuyorsunuz. Bu konuda daha spesifik bir soru sorabilir misiniz?`;\n    }\n    \n    return \"Size nasıl yardımcı olabilirim?\";\n  }\n\n  /**\n   * Olası yanıtları oluştur\n   */\n  private generatePossibleResponses(\n    inferredMeaning: string,\n    knowledgeResults: any,\n    intent: string\n  ): string[] {\n    const responses = [inferredMeaning];\n    \n    // Alternatif yanıtlar\n    if (knowledgeResults.trainingMatches.length > 1) {\n      responses.push(knowledgeResults.trainingMatches[1].output);\n    }\n    \n    if (knowledgeResults.memoryMatches.length > 0) {\n      responses.push(knowledgeResults.memoryMatches[0].content);\n    }\n    \n    // Intent bazlı alternatifler\n    switch (intent) {\n      case 'greeting':\n        responses.push(\"Selam!\", \"Merhaba! Nasıl gidiyor?\");\n        break;\n      case 'information_request':\n        responses.push(\"Bu konuda daha fazla bilgiye ihtiyacım var.\", \"Daha detayına inelim mi?\");\n        break;\n    }\n    \n    return [...new Set(responses)].slice(0, 3);\n  }\n\n  /**\n   * Güven skoru hesaplama\n   */\n  private calculateConfidence(\n    intent: string,\n    entities: Entity[],\n    knowledgeResults: any,\n    contextualClues: string[]\n  ): number {\n    let confidence = 0.5; // Temel güven\n    \n    // Direkt cevap varsa\n    if (knowledgeResults.directAnswer) {\n      confidence += 0.4;\n    }\n    \n    // Eğitim eşleşmeleri\n    if (knowledgeResults.trainingMatches.length > 0) {\n      confidence += 0.2 * knowledgeResults.trainingMatches.length;\n    }\n    \n    // Varlık güveni\n    const avgEntityConfidence = entities.length > 0 \n      ? entities.reduce((sum, e) => sum + e.confidence, 0) / entities.length \n      : 0;\n    confidence += avgEntityConfidence * 0.2;\n    \n    // Bağlamsal ipuçları\n    confidence += contextualClues.length * 0.05;\n    \n    // Intent kesinliği\n    if (intent !== 'unknown') {\n      confidence += 0.1;\n    }\n    \n    return Math.min(1.0, confidence);\n  }\n\n  // Yardımcı metodlar\n  private initializePatterns(): void {\n    this.contextPatterns.set('question', /\\b(ne|kim|nerede|nasıl|neden|hangi|kaç)\\b/i);\n    this.contextPatterns.set('time', /\\b(dün|bugün|yarın|şimdi|sonra|önce)\\b/i);\n    this.contextPatterns.set('emotion', /\\b(mutlu|üzgün|kızgın|sevinçli|endişeli)\\b/i);\n  }\n\n  private initializeIntentClassifiers(): void {\n    this.intentClassifiers.set('greeting', (text: string) => {\n      const greetings = ['merhaba', 'selam', 'selamün', 'günaydın', 'iyi akşamlar'];\n      return greetings.some(g => text.toLowerCase().includes(g)) ? 0.9 : 0;\n    });\n\n    this.intentClassifiers.set('information_request', (text: string) => {\n      const questionWords = ['ne', 'kim', 'nerede', 'nasıl', 'neden', 'hangi'];\n      return questionWords.some(q => text.toLowerCase().includes(q)) ? 0.8 : 0;\n    });\n\n    this.intentClassifiers.set('definition_request', (text: string) => {\n      return /\\b\\w+\\s+(nedir|ne demek|anlamı ne)\\b/i.test(text) ? 0.85 : 0;\n    });\n  }\n\n  private normalizeInput(input: string): string {\n    return input.trim().replace(/[^\\w\\sçğıöşüÇĞIİÖŞÜ]/g, '').toLowerCase();\n  }\n\n  private generateCacheKey(input: string, history: string[]): string {\n    return `${input.toLowerCase()}_${history.slice(-2).join('_')}`;\n  }\n\n  private extractRoot(word: string): string {\n    // Basit kök çıkarımı - geliştirilmeli\n    const suffixes = ['ler', 'lar', 'den', 'dan', 'de', 'da', 'yi', 'yı', 'yu', 'yü'];\n    for (const suffix of suffixes) {\n      if (word.endsWith(suffix)) {\n        return word.slice(0, -suffix.length);\n      }\n    }\n    return word;\n  }\n\n  private extractSuffixes(word: string): string[] {\n    const root = this.extractRoot(word);\n    return word.length > root.length ? [word.slice(root.length)] : [];\n  }\n\n  private calculateSemanticWeight(word: string, entry: any): number {\n    let weight = 0.5;\n    if (entry) {\n      weight += entry.meaning.length * 0.1;\n      if (entry.examples) weight += entry.examples.length * 0.05;\n    }\n    return Math.min(1, weight);\n  }\n\n  private classifyProperNoun(word: string): Entity['type'] {\n    // Basit özel isim sınıflandırması\n    const places = ['ankara', 'istanbul', 'izmir', 'türkiye'];\n    if (places.includes(word.toLowerCase())) return 'place';\n    return 'person';\n  }\n\n  private isEmotionalWord(word: string): boolean {\n    const emotions = ['mutlu', 'üzgün', 'kızgın', 'sevinçli', 'endişeli', 'heyecanlı'];\n    return emotions.includes(word.toLowerCase());\n  }\n\n  private isTimeExpression(word: string): boolean {\n    const timeWords = ['dün', 'bugün', 'yarın', 'şimdi', 'sonra', 'önce', 'sabah', 'akşam'];\n    return timeWords.includes(word.toLowerCase());\n  }\n\n  private extractMainTopic(text: string): string | null {\n    const words = text.split(/\\s+/);\n    // En uzun kelimeyi ana konu olarak al (basit yaklaşım)\n    return words.reduce((longest, word) => \n      word.length > longest.length ? word : longest, ''\n    );\n  }\n\n  private calculateSemanticSimilarity(text1: string, text2: string): number {\n    const words1 = text1.toLowerCase().split(/\\s+/);\n    const words2 = text2.toLowerCase().split(/\\s+/);\n    \n    const commonWords = words1.filter(word => words2.includes(word));\n    const totalWords = new Set([...words1, ...words2]).size;\n    \n    return totalWords > 0 ? commonWords.length / totalWords : 0;\n  }\n}\n","size_bytes":24248},"client/src/lib/TrainingDataAnalyzer.ts":{"content":"\n/**\n * Eğitim Verisi Analiz Sistemi\n * Eğitim verilerini derinlemesine analiz ederek ilişkileri ve bağlamları çıkarır\n */\n\nimport { TurkishDictionary } from './TurkishDictionary';\nimport { EnhancedMemorySystem } from './EnhancedMemorySystem';\n\nexport interface TrainingPair {\n  id: string;\n  input: string;\n  output: string;\n  timestamp: number;\n  category?: string;\n  confidence?: number;\n  relatedPairs?: string[];\n  semanticTags?: string[];\n  contextualInfo?: {\n    entities: string[];\n    sentiment: number;\n    complexity: number;\n    questionType?: string;\n    answerType?: string;\n  };\n}\n\nexport interface DataPattern {\n  id: string;\n  pattern: string;\n  frequency: number;\n  examples: TrainingPair[];\n  contextualRules: string[];\n  semanticWeight: number;\n}\n\nexport interface ContextualRelation {\n  sourceId: string;\n  targetId: string;\n  relationType: 'semantic' | 'sequential' | 'causal' | 'categorical' | 'linguistic';\n  strength: number;\n  confidence: number;\n  context: string[];\n}\n\nexport class TrainingDataAnalyzer {\n  private dictionary: TurkishDictionary;\n  private memorySystem: EnhancedMemorySystem;\n  private patterns: Map<string, DataPattern>;\n  private relations: Map<string, ContextualRelation[]>;\n  private semanticClusters: Map<string, TrainingPair[]>;\n\n  constructor(dictionary: TurkishDictionary | null, memorySystem: EnhancedMemorySystem) {\n    this.dictionary = dictionary || null as any;\n    this.memorySystem = memorySystem;\n    this.patterns = new Map();\n    this.relations = new Map();\n    this.semanticClusters = new Map();\n  }\n\n  /**\n   * Eğitim verilerini kapsamlı analiz et\n   */\n  public analyzeTrainingData(trainingPairs: TrainingPair[]): {\n    analyzedPairs: TrainingPair[];\n    discoveredPatterns: DataPattern[];\n    contextualRelations: ContextualRelation[];\n    semanticClusters: Map<string, TrainingPair[]>;\n    insights: {\n      totalPairs: number;\n      patternCount: number;\n      relationCount: number;\n      clusterCount: number;\n      averageConfidence: number;\n      topCategories: string[];\n    };\n  } {\n    console.log('🔍 Eğitim verisi analizi başlatılıyor...', trainingPairs.length, 'veri');\n\n    // 1. Her veriyi ayrıntılı analiz et\n    const analyzedPairs = trainingPairs.map(pair => this.analyzeTrainingPair(pair));\n\n    // 2. Kalıpları keşfet\n    this.discoverPatterns(analyzedPairs);\n\n    // 3. Bağlamsal ilişkileri bul\n    this.findContextualRelations(analyzedPairs);\n\n    // 4. Semantik kümeleme yap\n    this.performSemanticClustering(analyzedPairs);\n\n    // 5. İstatistikler ve içgörüler\n    const insights = this.generateInsights(analyzedPairs);\n\n    return {\n      analyzedPairs,\n      discoveredPatterns: Array.from(this.patterns.values()),\n      contextualRelations: Array.from(this.relations.values()).flat(),\n      semanticClusters: this.semanticClusters,\n      insights\n    };\n  }\n\n  /**\n   * Tek bir eğitim verisini detaylı analiz et\n   */\n  private analyzeTrainingPair(pair: TrainingPair): TrainingPair {\n    const analyzedPair = { ...pair };\n\n    // Girdi analizi\n    const inputAnalysis = this.analyzeText(pair.input);\n    \n    // Çıktı analizi\n    const outputAnalysis = this.analyzeText(pair.output);\n\n    // Bağlamsal bilgileri çıkar\n    analyzedPair.contextualInfo = {\n      entities: [...inputAnalysis.entities, ...outputAnalysis.entities],\n      sentiment: (inputAnalysis.sentiment + outputAnalysis.sentiment) / 2,\n      complexity: Math.max(inputAnalysis.complexity, outputAnalysis.complexity),\n      questionType: this.detectQuestionType(pair.input),\n      answerType: this.detectAnswerType(pair.output)\n    };\n\n    // Kategori belirle\n    analyzedPair.category = this.categorizeTrainingPair(pair);\n\n    // Semantik etiketler\n    analyzedPair.semanticTags = this.extractSemanticTags(pair);\n\n    // Güven skoru hesapla\n    analyzedPair.confidence = this.calculatePairConfidence(pair, analyzedPair.contextualInfo);\n\n    return analyzedPair;\n  }\n\n  /**\n   * Metni detaylı analiz et\n   */\n  private analyzeText(text: string): {\n    entities: string[];\n    sentiment: number;\n    complexity: number;\n    keywords: string[];\n    structure: string;\n  } {\n    const words = text.toLowerCase().split(/\\s+/);\n    \n    // Varlık tanıma\n    const entities = this.extractEntities(text);\n    \n    // Duygu analizi\n    const sentiment = this.analyzeSentiment(text);\n    \n    // Karmaşıklık skoru\n    const complexity = this.calculateComplexity(text);\n    \n    // Anahtar kelimeler\n    const keywords = this.extractKeywords(text);\n    \n    // Cümle yapısı\n    const structure = this.analyzeStructure(text);\n\n    return { entities, sentiment, complexity, keywords, structure };\n  }\n\n  /**\n   * Varlık tanıma\n   */\n  private extractEntities(text: string): string[] {\n    const entities: string[] = [];\n    const words = text.split(/\\s+/);\n\n    // Özel isimler (büyük harfle başlayanlar)\n    words.forEach(word => {\n      if (/^[A-ZÇĞIİÖŞÜ]/.test(word) && word.length > 2) {\n        entities.push(word);\n      }\n    });\n\n    // Sözlükteki önemli kelimeler\n    words.forEach(word => {\n      const cleanWord = word.toLowerCase().replace(/[^\\wçğıöşü]/g, '');\n      const entry = this.dictionary.getWord(cleanWord);\n      if (entry && ['isim', 'fiil'].includes(entry.type)) {\n        entities.push(cleanWord);\n      }\n    });\n\n    return [...new Set(entities)];\n  }\n\n  /**\n   * Duygu analizi\n   */\n  private analyzeSentiment(text: string): number {\n    const positiveWords = [\n      'iyi', 'güzel', 'harika', 'mükemmel', 'sevgi', 'mutlu', 'başarı',\n      'teşekkür', 'memnun', 'keyif', 'hoş', 'olumlu', 'yararlı'\n    ];\n\n    const negativeWords = [\n      'kötü', 'berbat', 'üzgün', 'problem', 'sorun', 'hata', 'yanlış',\n      'eksik', 'olumsuz', 'başarısız', 'zorlu', 'sıkıntı'\n    ];\n\n    const words = text.toLowerCase().split(/\\s+/);\n    let score = 0;\n\n    words.forEach(word => {\n      const cleanWord = word.replace(/[^\\wçğıöşü]/g, '');\n      if (positiveWords.includes(cleanWord)) score += 1;\n      if (negativeWords.includes(cleanWord)) score -= 1;\n    });\n\n    return Math.max(-1, Math.min(1, score / words.length));\n  }\n\n  /**\n   * Karmaşıklık hesaplama\n   */\n  private calculateComplexity(text: string): number {\n    const words = text.split(/\\s+/);\n    const uniqueWords = new Set(words.map(w => w.toLowerCase())).size;\n    const avgWordLength = words.reduce((sum, word) => sum + word.length, 0) / words.length;\n    const sentenceCount = text.split(/[.!?]+/).length;\n    \n    // Normalize edilmiş karmaşıklık skoru\n    return Math.min(1, (uniqueWords * 0.1 + avgWordLength * 0.05 + sentenceCount * 0.1) / 3);\n  }\n\n  /**\n   * Anahtar kelime çıkarımı\n   */\n  private extractKeywords(text: string): string[] {\n    const words = text.toLowerCase().split(/\\s+/);\n    const stopWords = ['ve', 'veya', 'ama', 'fakat', 'için', 'ile', 'bu', 'şu', 'o', 'bir', 'de', 'da'];\n    \n    return words\n      .filter(word => word.length > 3 && !stopWords.includes(word))\n      .map(word => word.replace(/[^\\wçğıöşü]/g, ''))\n      .filter(word => word.length > 2);\n  }\n\n  /**\n   * Cümle yapısı analizi\n   */\n  private analyzeStructure(text: string): string {\n    if (text.includes('?')) return 'question';\n    if (text.includes('!')) return 'exclamation';\n    if (text.includes(',')) return 'complex';\n    return 'simple';\n  }\n\n  /**\n   * Soru tipi tespit et\n   */\n  private detectQuestionType(text: string): string | undefined {\n    const questionPatterns = {\n      'what': /\\b(ne|nedir|hangi)\\b/i,\n      'who': /\\b(kim|kimdir)\\b/i,\n      'where': /\\b(nerede|neresi)\\b/i,\n      'when': /\\b(ne zaman|kaç)\\b/i,\n      'how': /\\b(nasıl|ne şekilde)\\b/i,\n      'why': /\\b(neden|niçin)\\b/i\n    };\n\n    for (const [type, pattern] of Object.entries(questionPatterns)) {\n      if (pattern.test(text)) return type;\n    }\n\n    return text.includes('?') ? 'general' : undefined;\n  }\n\n  /**\n   * Cevap tipi tespit et\n   */\n  private detectAnswerType(text: string): string | undefined {\n    if (text.includes('çünkü') || text.includes('nedeni')) return 'explanation';\n    if (text.match(/\\d+/)) return 'numerical';\n    if (text.toLowerCase().includes('evet') || text.toLowerCase().includes('hayır')) return 'confirmation';\n    if (text.includes('!')) return 'enthusiastic';\n    return 'descriptive';\n  }\n\n  /**\n   * Eğitim çiftini kategorize et\n   */\n  private categorizeTrainingPair(pair: TrainingPair): string {\n    const text = (pair.input + ' ' + pair.output).toLowerCase();\n    \n    const categories = {\n      'greeting': ['merhaba', 'selam', 'günaydın', 'iyi akşamlar'],\n      'personal': ['adım', 'yaş', 'nereli', 'kim'],\n      'emotion': ['nasıl', 'iyi', 'kötü', 'mutlu', 'üzgün'],\n      'information': ['nedir', 'ne demek', 'bilgi', 'öğren'],\n      'action': ['yap', 'git', 'gel', 'ver', 'al'],\n      'time': ['zaman', 'saat', 'gün', 'ay', 'yıl'],\n      'location': ['nerede', 'yer', 'konum', 'adres']\n    };\n\n    for (const [category, keywords] of Object.entries(categories)) {\n      if (keywords.some(keyword => text.includes(keyword))) {\n        return category;\n      }\n    }\n\n    return 'general';\n  }\n\n  /**\n   * Semantik etiketler çıkar\n   */\n  private extractSemanticTags(pair: TrainingPair): string[] {\n    const tags: string[] = [];\n    const allText = (pair.input + ' ' + pair.output).toLowerCase();\n\n    // Duygusal etiketler\n    if (/mutlu|sevinç|güzel|harika/.test(allText)) tags.push('positive');\n    if (/üzgün|kötü|problem|sıkıntı/.test(allText)) tags.push('negative');\n\n    // Konu etiketleri\n    if (/öğren|bil|anla|kavra/.test(allText)) tags.push('learning');\n    if (/yardım|destek|çöz/.test(allText)) tags.push('help');\n    if (/oyun|eğlen|şaka/.test(allText)) tags.push('entertainment');\n\n    // Yapısal etiketler\n    if (pair.input.includes('?')) tags.push('interrogative');\n    if (pair.output.includes('!')) tags.push('emphatic');\n\n    return tags;\n  }\n\n  /**\n   * Çift güven skoru hesapla\n   */\n  private calculatePairConfidence(pair: TrainingPair, contextInfo: any): number {\n    let confidence = 0.5;\n\n    // Uzunluk uyumluluğu\n    const inputWords = pair.input.split(/\\s+/).length;\n    const outputWords = pair.output.split(/\\s+/).length;\n    const lengthRatio = Math.min(inputWords, outputWords) / Math.max(inputWords, outputWords);\n    confidence += lengthRatio * 0.2;\n\n    // Varlık uyumluluğu\n    if (contextInfo.entities.length > 0) confidence += 0.1;\n\n    // Duygu uyumluluğu\n    if (Math.abs(contextInfo.sentiment) < 0.5) confidence += 0.1;\n    else confidence += 0.2;\n\n    // Karmaşıklık uyumluluğu\n    confidence += (1 - contextInfo.complexity) * 0.1;\n\n    // Soru-cevap uyumluluğu\n    if (contextInfo.questionType && contextInfo.answerType) confidence += 0.1;\n\n    return Math.min(1, confidence);\n  }\n\n  /**\n   * Kalıpları keşfet\n   */\n  private discoverPatterns(pairs: TrainingPair[]): void {\n    // Girdi kalıpları\n    const inputPatterns = new Map<string, TrainingPair[]>();\n    \n    pairs.forEach(pair => {\n      // Basit kelime kalıpları\n      const words = pair.input.toLowerCase().split(/\\s+/);\n      words.forEach(word => {\n        if (word.length > 3) {\n          if (!inputPatterns.has(word)) {\n            inputPatterns.set(word, []);\n          }\n          inputPatterns.get(word)!.push(pair);\n        }\n      });\n\n      // Yapısal kalıplar\n      const structure = this.getStructuralPattern(pair.input);\n      if (!inputPatterns.has(structure)) {\n        inputPatterns.set(structure, []);\n      }\n      inputPatterns.get(structure)!.push(pair);\n    });\n\n    // Kalıpları değerlendir ve kaydet\n    inputPatterns.forEach((examples, pattern) => {\n      if (examples.length >= 2) { // En az 2 örnek olmalı\n        this.patterns.set(pattern, {\n          id: `pattern_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n          pattern,\n          frequency: examples.length,\n          examples: examples.slice(0, 10), // En fazla 10 örnek sakla\n          contextualRules: this.extractContextualRules(examples),\n          semanticWeight: this.calculateSemanticWeight(examples)\n        });\n      }\n    });\n  }\n\n  /**\n   * Yapısal kalıp çıkar\n   */\n  private getStructuralPattern(text: string): string {\n    let pattern = text.toLowerCase();\n    \n    // Sayıları [NUM] ile değiştir\n    pattern = pattern.replace(/\\d+/g, '[NUM]');\n    \n    // Özel isimleri [NAME] ile değiştir\n    pattern = pattern.replace(/\\b[A-ZÇĞIİÖŞÜ][a-zçğıöşü]+\\b/g, '[NAME]');\n    \n    // Çok spesifik kelimeleri [WORD] ile değiştir\n    const commonWords = ['merhaba', 'selam', 'nedir', 'nasıl', 'kim'];\n    pattern = pattern.split(' ').map(word => {\n      if (commonWords.includes(word)) return word;\n      if (word.length > 6) return '[WORD]';\n      return word;\n    }).join(' ');\n\n    return pattern;\n  }\n\n  /**\n   * Bağlamsal kurallar çıkar\n   */\n  private extractContextualRules(examples: TrainingPair[]): string[] {\n    const rules: string[] = [];\n\n    // Ortak kategoriler\n    const categories = examples.map(ex => ex.category).filter(Boolean);\n    const mostCommonCategory = this.getMostFrequent(categories);\n    if (mostCommonCategory) {\n      rules.push(`category:${mostCommonCategory}`);\n    }\n\n    // Ortak semantik etiketler\n    const allTags = examples.flatMap(ex => ex.semanticTags || []);\n    const commonTags = this.getMostFrequentItems(allTags, 2);\n    commonTags.forEach(tag => rules.push(`tag:${tag}`));\n\n    // Güven aralığı\n    const confidences = examples.map(ex => ex.confidence || 0.5);\n    const avgConfidence = confidences.reduce((sum, c) => sum + c, 0) / confidences.length;\n    rules.push(`confidence:${avgConfidence.toFixed(2)}`);\n\n    return rules;\n  }\n\n  /**\n   * Semantik ağırlık hesapla\n   */\n  private calculateSemanticWeight(examples: TrainingPair[]): number {\n    const factors = {\n      frequency: Math.min(1, examples.length / 10),\n      avgConfidence: examples.reduce((sum, ex) => sum + (ex.confidence || 0.5), 0) / examples.length,\n      complexity: examples.reduce((sum, ex) => sum + (ex.contextualInfo?.complexity || 0.5), 0) / examples.length,\n      entityDensity: examples.reduce((sum, ex) => sum + (ex.contextualInfo?.entities.length || 0), 0) / examples.length / 5\n    };\n\n    return Object.values(factors).reduce((sum, val) => sum + val, 0) / Object.keys(factors).length;\n  }\n\n  /**\n   * Bağlamsal ilişkileri bul\n   */\n  private findContextualRelations(pairs: TrainingPair[]): void {\n    for (let i = 0; i < pairs.length; i++) {\n      for (let j = i + 1; j < pairs.length; j++) {\n        const pair1 = pairs[i];\n        const pair2 = pairs[j];\n\n        const relations = this.analyzeRelationship(pair1, pair2);\n        \n        relations.forEach(relation => {\n          const key = `${pair1.id}_${pair2.id}`;\n          if (!this.relations.has(key)) {\n            this.relations.set(key, []);\n          }\n          this.relations.get(key)!.push(relation);\n        });\n      }\n    }\n  }\n\n  /**\n   * İki çift arasındaki ilişkiyi analiz et\n   */\n  private analyzeRelationship(pair1: TrainingPair, pair2: TrainingPair): ContextualRelation[] {\n    const relations: ContextualRelation[] = [];\n\n    // Semantik benzerlik\n    const semanticSimilarity = this.calculateSemanticSimilarity(pair1, pair2);\n    if (semanticSimilarity > 0.7) {\n      relations.push({\n        sourceId: pair1.id,\n        targetId: pair2.id,\n        relationType: 'semantic',\n        strength: semanticSimilarity,\n        confidence: 0.8,\n        context: ['similar_meaning', 'related_concepts']\n      });\n    }\n\n    // Kategori ilişkisi\n    if (pair1.category === pair2.category && pair1.category !== 'general') {\n      relations.push({\n        sourceId: pair1.id,\n        targetId: pair2.id,\n        relationType: 'categorical',\n        strength: 0.9,\n        confidence: 0.9,\n        context: [`same_category:${pair1.category}`]\n      });\n    }\n\n    // Dil yapısı ilişkisi\n    const structuralSimilarity = this.calculateStructuralSimilarity(pair1, pair2);\n    if (structuralSimilarity > 0.8) {\n      relations.push({\n        sourceId: pair1.id,\n        targetId: pair2.id,\n        relationType: 'linguistic',\n        strength: structuralSimilarity,\n        confidence: 0.7,\n        context: ['similar_structure', 'linguistic_pattern']\n      });\n    }\n\n    return relations;\n  }\n\n  /**\n   * Semantik benzerlik hesapla\n   */\n  private calculateSemanticSimilarity(pair1: TrainingPair, pair2: TrainingPair): number {\n    const entities1 = new Set(pair1.contextualInfo?.entities || []);\n    const entities2 = new Set(pair2.contextualInfo?.entities || []);\n    \n    const commonEntities = [...entities1].filter(e => entities2.has(e)).length;\n    const totalEntities = entities1.size + entities2.size - commonEntities;\n    \n    const entitySimilarity = totalEntities > 0 ? commonEntities / totalEntities : 0;\n\n    // Etiket benzerliği\n    const tags1 = new Set(pair1.semanticTags || []);\n    const tags2 = new Set(pair2.semanticTags || []);\n    \n    const commonTags = [...tags1].filter(t => tags2.has(t)).length;\n    const totalTags = tags1.size + tags2.size - commonTags;\n    \n    const tagSimilarity = totalTags > 0 ? commonTags / totalTags : 0;\n\n    return (entitySimilarity + tagSimilarity) / 2;\n  }\n\n  /**\n   * Yapısal benzerlik hesapla\n   */\n  private calculateStructuralSimilarity(pair1: TrainingPair, pair2: TrainingPair): number {\n    const pattern1 = this.getStructuralPattern(pair1.input);\n    const pattern2 = this.getStructuralPattern(pair2.input);\n    \n    return pattern1 === pattern2 ? 1.0 : 0.0;\n  }\n\n  /**\n   * Semantik kümeleme yap\n   */\n  private performSemanticClustering(pairs: TrainingPair[]): void {\n    // Kategori bazlı kümeleme\n    pairs.forEach(pair => {\n      const category = pair.category || 'general';\n      if (!this.semanticClusters.has(category)) {\n        this.semanticClusters.set(category, []);\n      }\n      this.semanticClusters.get(category)!.push(pair);\n    });\n\n    // Etiket bazlı kümeleme\n    pairs.forEach(pair => {\n      (pair.semanticTags || []).forEach(tag => {\n        const clusterKey = `tag:${tag}`;\n        if (!this.semanticClusters.has(clusterKey)) {\n          this.semanticClusters.set(clusterKey, []);\n        }\n        this.semanticClusters.get(clusterKey)!.push(pair);\n      });\n    });\n  }\n\n  /**\n   * İçgörüler ve istatistikler üret\n   */\n  private generateInsights(pairs: TrainingPair[]): any {\n    const totalPairs = pairs.length;\n    const patternCount = this.patterns.size;\n    const relationCount = Array.from(this.relations.values()).flat().length;\n    const clusterCount = this.semanticClusters.size;\n    \n    const averageConfidence = pairs.reduce((sum, pair) => sum + (pair.confidence || 0.5), 0) / totalPairs;\n    \n    const categoryCount = new Map<string, number>();\n    pairs.forEach(pair => {\n      const category = pair.category || 'general';\n      categoryCount.set(category, (categoryCount.get(category) || 0) + 1);\n    });\n    \n    const topCategories = Array.from(categoryCount.entries())\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, 5)\n      .map(([category]) => category);\n\n    return {\n      totalPairs,\n      patternCount,\n      relationCount,\n      clusterCount,\n      averageConfidence,\n      topCategories\n    };\n  }\n\n  /**\n   * En sık görülen öğeyi bul\n   */\n  private getMostFrequent<T>(items: T[]): T | null {\n    if (items.length === 0) return null;\n    \n    const counts = new Map<T, number>();\n    items.forEach(item => {\n      counts.set(item, (counts.get(item) || 0) + 1);\n    });\n    \n    return Array.from(counts.entries())\n      .sort((a, b) => b[1] - a[1])[0][0];\n  }\n\n  /**\n   * En sık görülen N öğeyi bul\n   */\n  private getMostFrequentItems<T>(items: T[], limit: number): T[] {\n    const counts = new Map<T, number>();\n    items.forEach(item => {\n      counts.set(item, (counts.get(item) || 0) + 1);\n    });\n    \n    return Array.from(counts.entries())\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, limit)\n      .map(([item]) => item);\n  }\n\n  /**\n   * Analiz sonuçlarını dışa aktar\n   */\n  public exportAnalysis(): {\n    patterns: DataPattern[];\n    relations: ContextualRelation[];\n    clusters: { [key: string]: TrainingPair[] };\n    statistics: any;\n  } {\n    return {\n      patterns: Array.from(this.patterns.values()),\n      relations: Array.from(this.relations.values()).flat(),\n      clusters: Object.fromEntries(this.semanticClusters),\n      statistics: {\n        totalPatterns: this.patterns.size,\n        totalRelations: Array.from(this.relations.values()).flat().length,\n        totalClusters: this.semanticClusters.size\n      }\n    };\n  }\n}\n","size_bytes":20706},"client/src/temp_patch.js":{"content":"// Toplu eğitim sistemi düzeltme yama\n// Problem: Eğitim verileri localStorage'a kaydediliyor ama sorularda bulunmuyor\n\nconst fixTrainingDataAccess = () => {\n  // 1. localStorage'dan eğitim verilerini oku\n  const localData = JSON.parse(localStorage.getItem('neural_training_history') || '[]');\n  console.log('Kayıtlı eğitim verileri:', localData.length);\n  \n  // 2. Her veriyi kontrol et\n  localData.forEach((item, index) => {\n    console.log(`${index}: \"${item.input}\" -> \"${item.output}\"`);\n  });\n  \n  return localData;\n};\n\n// Test örneği\nconst testQuestion = \"abandırma ne demek\";\nconst data = fixTrainingDataAccess();\nconst match = data.find(item => \n  item.input && item.input.toLowerCase().includes(\"abandırma\")\n);\nconsole.log('Test eşleşme:', match);","size_bytes":770},"prepare_training_data.js":{"content":"// Script to prepare comprehensive chat training data for batch training\nimport fs from 'fs';\nconsole.log('Sohbet eğitim verisi hazırlanıyor...');\n\n// Read the training file\nconst trainingContent = fs.readFileSync('sohbet_egitim_verisi.txt', 'utf8');\n\n// Parse the training data (format: input => output)\nconst pairs = [];\nconst lines = trainingContent.split('\\n');\n\nfor (const line of lines) {\n  const trimmed = line.trim();\n  \n  // Skip comments and empty lines\n  if (!trimmed || trimmed.startsWith('#')) continue;\n  \n  // Process lines with => separator\n  if (trimmed.includes(' => ')) {\n    const [input, output] = trimmed.split(' => ', 2);\n    if (input && output) {\n      pairs.push({\n        input: input.trim(),\n        output: output.trim()\n      });\n    }\n  }\n}\n\nconsole.log(`${pairs.length} eğitim çifti hazırlandı.`);\n\n// Save as JSON for easy import\nconst jsonData = JSON.stringify(pairs, null, 2);\nfs.writeFileSync('sohbet_training_pairs.json', jsonData);\n\nconsole.log('Eğitim verisi sohbet_training_pairs.json dosyasına kaydedildi.');\n\n// Also create a formatted version for manual entry\nlet formatted = '';\nfor (const pair of pairs) {\n  formatted += `${pair.input} => ${pair.output}\\n`;\n}\nfs.writeFileSync('sohbet_formatted.txt', formatted);\n\nconsole.log('Manuel giriş için formatted dosya oluşturuldu.');","size_bytes":1333}}}